{"commit":"0b747b4d1c4194a25a0f89957f582b3fef0c8651","old_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","new_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","old_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","new_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  public ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","code_block_diff":"{'diff_0': ['    super(builder);\\n  }\\n\\n  ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n', '    super(builder);\\n  }\\n\\n  public ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n']}","subject":"","message":"Add public visibility to ProviderList.entries()\n\n","lang":"Java","license":"","repos":""}
{"commit":"fd7ebab7f293fe63aef55565969187a02a56d799","old_file":"src\/modules\/rest\/impl\/src\/test\/java\/it\/geosolutions\/geostore\/rest\/security\/GeoStoreLdapAuthoritiesPopulatorTest.java","new_file":"src\/modules\/rest\/impl\/src\/test\/java\/it\/geosolutions\/geostore\/rest\/security\/GeoStoreLdapAuthoritiesPopulatorTest.java","old_contents":"package it.geosolutions.geostore.rest.security;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.junit.Test;\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.security.core.GrantedAuthority;\nimport it.geosolutions.geostore.core.ldap.IterableNamingEnumeration;\nimport it.geosolutions.geostore.core.ldap.MockContextSource;\nimport it.geosolutions.geostore.services.rest.security.GeoStoreLdapAuthoritiesPopulator;\n\npublic class GeoStoreLdapAuthoritiesPopulatorTest {\n    \n    DirContext ctx = new DirContextAdapter() {\n        @Override\n        public NamingEnumeration<SearchResult> search(String name, String filter, SearchControls cons)\n                throws NamingException {\n            if (\"ou=groups\".equals(name)) {\n                if(\"(member=uid=bill,ou=people)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=group1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=parentgroup1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"parentgroup1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                }\n            }\n            return new IterableNamingEnumeration(Collections.EMPTY_LIST);\n        }\n        \n    };\n    \n    @Test\n    public void testNestedGroupsEnabled() {\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(2, authorities.size());\n    }\n    \n    @Test\n    public void testNestedGroupsDisabled() {\n        \n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(1, authorities.size());\n    }\n}\n","new_contents":"package it.geosolutions.geostore.rest.security;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport it.geosolutions.geostore.core.security.SimpleGrantedAuthoritiesMapper;\nimport org.junit.Test;\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.security.core.GrantedAuthority;\nimport it.geosolutions.geostore.core.ldap.IterableNamingEnumeration;\nimport it.geosolutions.geostore.core.ldap.MockContextSource;\nimport it.geosolutions.geostore.services.rest.security.GeoStoreLdapAuthoritiesPopulator;\n\npublic class GeoStoreLdapAuthoritiesPopulatorTest {\n    \n    DirContext ctx = new DirContextAdapter() {\n        @Override\n        public NamingEnumeration<SearchResult> search(String name, String filter, SearchControls cons)\n                throws NamingException {\n            if (\"ou=groups\".equals(name)) {\n                if(\"(member=uid=bill,ou=people)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=group1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n\n                    SearchResult sr2 = new SearchResult(\"cn=group2\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group2,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group2\";\n                            }\n                            return \"\";\n                        }\n\n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Arrays.asList(sr, sr2));\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=parentgroup1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"parentgroup1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                }\n            }\n            return new IterableNamingEnumeration(Collections.EMPTY_LIST);\n        }\n        \n    };\n    \n    @Test\n    public void testNestedGroupsEnabled() {\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(3, authorities.size());\n    }\n    \n    @Test\n    public void testNestedGroupsDisabled() {\n        \n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(2, authorities.size());\n    }\n\n    @Test\n    public void testDropUnmappedRoles() {\n\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=groups\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Map<String,String>  mappings=new HashMap<>();\n        mappings.put(\"ROLE_GROUP2\",\"ROLE_ADMIN\");\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\n        mapper.setDropUnmapped(true);\n        authoritiesPopulator.setRoleMapper(mapper);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        List<String> expected=Arrays.asList(\"ROLE_ADMIN\",\"GROUP1\",\"GROUP2\");\n        List<String> stringAuthorities=authorities.stream().map(a->a.getAuthority()).collect(Collectors.toList());\n        assertEquals(expected.size(), stringAuthorities.size());\n        assertTrue(stringAuthorities.containsAll(expected));\n    }\n\n\n    @Test\n    public void testDropUnmappedGroups() {\n\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Map<String,String>  mappings=new HashMap<>();\n        mappings.put(\"GROUP2\",\"MAPPED_GROUP\");\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\n        mapper.setDropUnmapped(true);\n        authoritiesPopulator.setGroupMapper(mapper);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(1, authorities.size());\n        assertEquals(\"MAPPED_GROUP\",authorities.iterator().next().getAuthority());\n    }\n}\n","code_block_diff":"{'diff_0': ['package it.geosolutions.geostore.rest.security;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nimport javax.naming.Name;\\nimport javax.naming.NamingEnumeration;\\n', 'package it.geosolutions.geostore.rest.security;\\n\\nimport static org.junit.Assert.assertEquals;\\nimport static org.junit.Assert.assertTrue;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.stream.Collectors;\\n\\nimport javax.naming.Name;\\nimport javax.naming.NamingEnumeration;\\n'], 'diff_1': ['import javax.naming.directory.SearchControls;\\nimport javax.naming.directory.SearchResult;\\n\\nimport org.junit.Test;\\nimport org.springframework.ldap.core.DirContextAdapter;\\nimport org.springframework.security.core.GrantedAuthority;\\n', 'import javax.naming.directory.SearchControls;\\nimport javax.naming.directory.SearchResult;\\n\\nimport it.geosolutions.geostore.core.security.SimpleGrantedAuthoritiesMapper;\\nimport org.junit.Test;\\nimport org.springframework.ldap.core.DirContextAdapter;\\nimport org.springframework.security.core.GrantedAuthority;\\n'], 'diff_2': ['                        }\\n                        \\n                    }, new BasicAttributes());\\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\\n', '                        }\\n                        \\n                    }, new BasicAttributes());\\n\\n                    SearchResult sr2 = new SearchResult(\"cn=group2\", null, new MockDirContextOperations() {\\n\\n                        @Override\\n                        public String getNameInNamespace() {\\n                            return \"cn=group2,ou=groups\";\\n                        }\\n\\n                        @Override\\n                        public String getStringAttribute(String name) {\\n                            if (\"cn\".equals(name)) {\\n                                return \"group2\";\\n                            }\\n                            return \"\";\\n                        }\\n\\n                    }, new BasicAttributes());\\n                    return new IterableNamingEnumeration(Arrays.asList(sr, sr2));\\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\\n'], 'diff_3': ['                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(2, authorities.size());\\n    }\\n    \\n    @Test\\n', '                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(3, authorities.size());\\n    }\\n    \\n    @Test\\n'], 'diff_4': ['                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(1, authorities.size());\\n    }\\n}\\n', '                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(2, authorities.size());\\n    }\\n\\n    @Test\\n    public void testDropUnmappedRoles() {\\n\\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=groups\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Map<String,String>  mappings=new HashMap<>();\\n        mappings.put(\"ROLE_GROUP2\",\"ROLE_ADMIN\");\\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\\n        mapper.setDropUnmapped(true);\\n        authoritiesPopulator.setRoleMapper(mapper);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        List<String> expected=Arrays.asList(\"ROLE_ADMIN\",\"GROUP1\",\"GROUP2\");\\n        List<String> stringAuthorities=authorities.stream().map(a->a.getAuthority()).collect(Collectors.toList());\\n        assertEquals(expected.size(), stringAuthorities.size());\\n        assertTrue(stringAuthorities.containsAll(expected));\\n    }\\n\\n\\n    @Test\\n    public void testDropUnmappedGroups() {\\n\\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Map<String,String>  mappings=new HashMap<>();\\n        mappings.put(\"GROUP2\",\"MAPPED_GROUP\");\\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\\n        mapper.setDropUnmapped(true);\\n        authoritiesPopulator.setGroupMapper(mapper);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(1, authorities.size());\\n        assertEquals(\"MAPPED_GROUP\",authorities.iterator().next().getAuthority());\\n    }\\n}\\n']}","subject":"","message":"Tests for LDAP groups and roles concepts are mixed (#272)\n\n\n","lang":"Java","license":"","repos":""}
{"commit":"92305c4113ea3b2f419a712ba399eaf3ed59c382","old_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/core\/internal\/provider\/SliceBindingsProvider.java","new_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/core\/internal\/provider\/SliceBindingsProvider.java","old_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\npackage com.cognifide.slice.core.internal.provider;\n\nimport javax.script.Bindings;\n\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceUtil;\nimport org.apache.sling.scripting.api.BindingsValuesProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.cognifide.slice.api.model.ModelClassResolver;\n\n@Component\n@Service\npublic class SliceBindingsProvider implements BindingsValuesProvider {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(SliceBindingsProvider.class);\n\n\t@Reference\n\tprivate ModelClassResolver modelClassNameResolver;\n\n\t@Override\n\tpublic void addBindings(Bindings bindings) {\n\t\tfinal Resource resource = (Resource) bindings.get(\"resource\");\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tfinal Class<?> modelClass = getModel(resource);\n\t\t\tif (modelClass != null) {\n\t\t\t\tbindings.put(\"model\", resource.adaptTo(modelClass));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tLOG.error(\"Can't resolver Slice model class\", e);\n\t\t}\n\t}\n\n\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\n\t\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\n\t\tif (modelClass == null) {\n\t\t\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\n\t\t\tif (resourceSuperType != null) {\n\t\t\t\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\n\t\t\t}\n\t\t}\n\t\treturn modelClass;\n\t}\n\n}\n","new_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\npackage com.cognifide.slice.core.internal.provider;\n\nimport javax.script.Bindings;\n\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceUtil;\nimport org.apache.sling.scripting.api.BindingsValuesProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.cognifide.slice.api.model.ModelClassResolver;\n\n@Component\n@Service\npublic class SliceBindingsProvider implements BindingsValuesProvider {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(SliceBindingsProvider.class);\n\n\t@Reference\n\tprivate ModelClassResolver modelClassNameResolver;\n\n\t@Override\n\tpublic void addBindings(Bindings bindings) {\n\t\tfinal Resource resource = (Resource) bindings.get(\"resource\");\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tfinal Class<?> modelClass = getModel(resource);\n\t\t\tif (modelClass != null) {\n\t\t\t\tbindings.put(\"model\", resource.adaptTo(modelClass));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tLOG.error(\"Can't resolver Slice model class\", e);\n\t\t}\n\t}\n\n\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\n\t\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\n\t\twhile (modelClass == null) {\n\t\t\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\n\t\t\tif (resourceSuperType == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\n\t\t\tresource = resource.getResourceResolver().getResource(resourceSuperType);\n\t\t}\n\t\treturn modelClass;\n\t}\n\n}\n","code_block_diff":"{'diff_0': ['\\n\\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\\n\\t\\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\\n\\t\\tif (modelClass == null) {\\n\\t\\t\\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\\n\\t\\t\\tif (resourceSuperType != null) {\\n\\t\\t\\t\\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn modelClass;\\n\\t}\\n', '\\n\\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\\n\\t\\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\\n\\t\\twhile (modelClass == null) {\\n\\t\\t\\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\\n\\t\\t\\tif (resourceSuperType == null) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\\n\\t\\t\\tresource = resource.getResourceResolver().getResource(resourceSuperType);\\n\\t\\t}\\n\\t\\treturn modelClass;\\n\\t}\\n']}","subject":"","message":"SLICE-135: Added inheritance support for resourceSuperType\n\n","lang":"Java","license":"","repos":""}
{"commit":"38f7b2b6e2a3aee52598bcea9407fe4298705299","old_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/commons\/SliceModulesFactory.java","new_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/commons\/SliceModulesFactory.java","old_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\n\npackage com.cognifide.slice.commons;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ops4j.peaberry.Peaberry;\nimport org.osgi.framework.BundleContext;\n\nimport com.cognifide.slice.api.context.ContextScope;\nimport com.cognifide.slice.core.internal.context.SliceContextScope;\nimport com.cognifide.slice.core.internal.module.JcrModule;\nimport com.cognifide.slice.core.internal.module.SliceMonitoringModule;\nimport com.cognifide.slice.core.internal.module.SliceModule;\nimport com.cognifide.slice.core.internal.module.SliceResourceModule;\nimport com.cognifide.slice.core.internal.module.SlingModule;\nimport com.cognifide.slice.persistence.impl.module.PersistenceModule;\nimport com.google.inject.Module;\n\n\/**\n * Factory for all Slice-related modules. It should be used in application's activator to register\n * Slice-related modules\n * \n * @author maciej.majchrzak\n * \n *\/\npublic class SliceModulesFactory {\n\n\tprivate SliceModulesFactory() {\n\t}\n\n\t\/**\n\t * Creates and returns a list of all Slice-related modules, including framework's internal modules as well\n\t * as Sling's and JCR's ones. The list includes:<br>\n\t * <ul>\n\t * <li>Peaberry module<\/li>\n\t * <li>{@link SliceModule}<\/li>\n\t * <li>{@link SlingModule}<\/li>\n\t * <li>{@link JcrModule}<\/li>\n\t * <li>{@link SliceResourceModule}<\/li>\n\t * <\/ul>\n\t * @param bundleContext bundle Context\n\t * @return list of Slice-related modules\n\t *\/\n\tpublic static List<Module> createModules(final BundleContext bundleContext) {\n\t\tfinal ContextScope contextScope = new SliceContextScope();\n\t\tList<Module> modules = new ArrayList<Module>();\n\t\tmodules.add(Peaberry.osgiModule(bundleContext));\n\t\tmodules.add(new SliceModule(contextScope, bundleContext.getBundle()));\n\t\tmodules.add(new SlingModule(contextScope));\n\t\tmodules.add(new JcrModule());\n\t\tmodules.add(new SliceResourceModule());\n\t\tmodules.add(new PersistenceModule());\n\t\tmodules.add(new SliceMonitoringModule());\n\t\treturn modules;\n\t}\n}\n","new_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\n\npackage com.cognifide.slice.commons;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ops4j.peaberry.Peaberry;\nimport org.osgi.framework.BundleContext;\n\nimport com.cognifide.slice.api.context.ContextScope;\nimport com.cognifide.slice.core.internal.context.SliceContextScope;\nimport com.cognifide.slice.core.internal.module.JcrModule;\nimport com.cognifide.slice.core.internal.module.SliceMonitoringModule;\nimport com.cognifide.slice.core.internal.module.SliceModule;\nimport com.cognifide.slice.core.internal.module.SliceResourceModule;\nimport com.cognifide.slice.core.internal.module.SlingModule;\nimport com.cognifide.slice.persistence.impl.module.PersistenceModule;\nimport com.google.inject.Module;\n\n\/**\n * Factory for all Slice-related modules. It should be used in application's activator to register\n * Slice-related modules\n * \n * @author maciej.majchrzak\n * \n *\/\npublic class SliceModulesFactory {\n\n\tprivate SliceModulesFactory() {\n\t}\n\n\t\/**\n\t * Creates and returns a list of all Slice-related modules, including framework's internal modules as well\n\t * as Sling's and JCR's ones. The list includes:<br>\n\t * <ul>\n\t * <li>Peaberry module<\/li>\n\t * <li>{@link SliceModule}<\/li>\n\t * <li>{@link SlingModule}<\/li>\n\t * <li>{@link JcrModule}<\/li>\n\t * <li>{@link SliceResourceModule}<\/li>\n\t * <li>{@link SliceMonitoringModule}<\/li>\n\t * <\/ul>\n\t * @param bundleContext bundle Context\n\t * @return list of Slice-related modules\n\t *\/\n\tpublic static List<Module> createModules(final BundleContext bundleContext) {\n\t\tfinal ContextScope contextScope = new SliceContextScope();\n\t\tList<Module> modules = new ArrayList<Module>();\n\t\tmodules.add(Peaberry.osgiModule(bundleContext));\n\t\tmodules.add(new SliceModule(contextScope, bundleContext.getBundle()));\n\t\tmodules.add(new SlingModule(contextScope));\n\t\tmodules.add(new JcrModule());\n\t\tmodules.add(new SliceResourceModule());\n\t\tmodules.add(new PersistenceModule());\n\t\tmodules.add(new SliceMonitoringModule());\n\t\treturn modules;\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t * <li>{@link SlingModule}<\/li>\\n\\t * <li>{@link JcrModule}<\/li>\\n\\t * <li>{@link SliceResourceModule}<\/li>\\n\\t * <\/ul>\\n\\t * @param bundleContext bundle Context\\n\\t * @return list of Slice-related modules\\n', '\\t * <li>{@link SlingModule}<\/li>\\n\\t * <li>{@link JcrModule}<\/li>\\n\\t * <li>{@link SliceResourceModule}<\/li>\\n\\t * <li>{@link SliceMonitoringModule}<\/li>\\n\\t * <\/ul>\\n\\t * @param bundleContext bundle Context\\n\\t * @return list of Slice-related modules\\n']}","subject":"","message":"Revert \"SLICE-139 Replacing AOP based implementation with strict coupling\"\n\nThis reverts commit 4ee6ffe2a469079ecdbdfa00a703984e31e5c947.\n\n","lang":"Java","license":"","repos":""}
{"commit":"947de263721911fe939f80a64126c0c7b287b3d0","old_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","new_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","old_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","new_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t}\\n\\n\\t@Override\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n', '\\t}\\n\\n\\t@Override\\n\\t@SuppressWarnings(\"unchecked\")\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n'], 'diff_1': ['\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n', '\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n']}","subject":"","message":"Minor code cleanup\n\n","lang":"Java","license":"","repos":""}
{"commit":"eebdcbf007299a2d765e6e2861a7d915fbc6fe96","old_file":"Code\/src\/main\/java\/otld\/otld\/intermediate\/Program.java","new_file":"Code\/src\/main\/java\/otld\/otld\/intermediate\/Program.java","old_contents":"package otld.otld.intermediate;\n\nimport otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\/**\n * Represents a program.\n *\n * A program has a unique identifier.\n *\n * A Program instance is responsible for keeping administration on all variables, functions, etc.\n *\/\npublic class Program {\n    \/** The identifier of the program. *\/\n    private String id;\n\n    \/** The variables in this program indexed by identifier. *\/\n    private Map<String, Variable> variables;\n\n    \/** The functions in this program indexed by identifier. *\/\n    private Map<String, Function> functions;\n\n    \/** The operations that form the program. *\/\n    private OperationSequence body;\n\n    \/**\n     * @param id The unique identifier of the program.\n     *\/\n    public Program(final String id) {\n        this.id = id;\n        this.variables = new HashMap<String, Variable>();\n        this.functions = new HashMap<String, Function>();\n    }\n\n    \/**\n     * @return The unique identifier of the program.\n     *\/\n    public final String getId() {\n        return this.id;\n    }\n\n    \/**\n     * @param id The identifier of the variable.\n     * @return The variable or {@code null} if there is no variable with the given identifier.\n     *\/\n    public final Variable getVariable(final String id) {\n        return this.variables.get(id);\n    }\n\n    \/**\n     * @param var The variable to add.\n     * @throws VariableAlreadyDeclared There already exists a variable with the given name.\n     *\/\n    public final void addVariable(final Variable var) throws VariableAlreadyDeclared {\n        if (this.variables.containsKey(var.getId())) {\n            throw new VariableAlreadyDeclared();\n        }\n        this.variables.put(var.getId(), var);\n    }\n\n    \/**\n     * @param id The identifier of the function.\n     * @return The function or {@code null} if there is no function with the given identifier.\n     *\/\n    public final Function getFunction(final String id) {\n        return this.functions.get(id);\n    }\n\n    \/**\n     * @param function The function to add.\n     * @throws FunctionAlreadyDeclared There already exists a function with the given name.\n     *\/\n    public final void addFunction(final Function function) throws FunctionAlreadyDeclared {\n        if (this.functions.containsKey(function.getId())) {\n            throw new FunctionAlreadyDeclared();\n        }\n        this.functions.put(function.getId(), function);\n    }\n\n    \/**\n     * @return The body of the program.\n     *\/\n    public final OperationSequence getBody() {\n        return this.body;\n    }\n\n    @Override\n    public final String toString() {\n        return String.format(\"Program %s\", this.getId());\n    }\n}\n","new_contents":"package otld.otld.intermediate;\n\nimport otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\n\nimport java.util.*;\n\n\/**\n * Represents a program.\n *\n * A program has a unique identifier.\n *\n * A Program instance is responsible for keeping administration on all variables, functions, etc.\n *\/\npublic class Program {\n    \/** The identifier of the program. *\/\n    private String id;\n\n    \/** The variables in this program indexed by identifier. *\/\n    private Map<String, Variable> variables;\n\n    \/** The functions in this program indexed by identifier. *\/\n    private Map<String, Function> functions;\n\n    \/** The operations that form the program. *\/\n    private OperationSequence body;\n\n    \/**\n     * @param id The unique identifier of the program.\n     *\/\n    public Program(final String id) {\n        this.id = id;\n        this.variables = new HashMap<String, Variable>();\n        this.functions = new HashMap<String, Function>();\n\n        for (Function function : getDefaultFunctions()) {\n            this.functions.put(function.getId(), function);\n        }\n    }\n\n    \/**\n     * Returns the default functions for a program based on the available operators.\n     * @return The default functions for a program.\n     *\/\n    private static Set<Function> getDefaultFunctions() {\n        final Set<Function> functions = new HashSet<>();\n\n        for (Operator op : Operator.values()) {\n            final Type[] opArgs = op.getArgs();\n            final Type[] types = Arrays.copyOf(opArgs, opArgs.length + 1);\n            types[opArgs.length] = op.getType();\n\n            functions.add(new Function(op.name(), types));\n        }\n\n        return functions;\n    }\n\n    \/**\n     * @return The unique identifier of the program.\n     *\/\n    public final String getId() {\n        return this.id;\n    }\n\n    \/**\n     * @param id The identifier of the variable.\n     * @return The variable or {@code null} if there is no variable with the given identifier.\n     *\/\n    public final Variable getVariable(final String id) {\n        return this.variables.get(id);\n    }\n\n    \/**\n     * @param var The variable to add.\n     * @throws VariableAlreadyDeclared There already exists a variable with the given name.\n     *\/\n    public final void addVariable(final Variable var) throws VariableAlreadyDeclared {\n        if (this.variables.containsKey(var.getId())) {\n            throw new VariableAlreadyDeclared();\n        }\n        this.variables.put(var.getId(), var);\n    }\n\n    \/**\n     * @param id The identifier of the function.\n     * @return The function or {@code null} if there is no function with the given identifier.\n     *\/\n    public final Function getFunction(final String id) {\n        return this.functions.get(id);\n    }\n\n    \/**\n     * @param function The function to add.\n     * @throws FunctionAlreadyDeclared There already exists a function with the given name.\n     *\/\n    public final void addFunction(final Function function) throws FunctionAlreadyDeclared {\n        if (this.functions.containsKey(function.getId())) {\n            throw new FunctionAlreadyDeclared();\n        }\n        this.functions.put(function.getId(), function);\n    }\n\n    \/**\n     * @return The body of the program.\n     *\/\n    public final OperationSequence getBody() {\n        return this.body;\n    }\n\n    @Override\n    public final String toString() {\n        return String.format(\"Program %s\", this.getId());\n    }\n}\n","code_block_diff":"{'diff_0': ['import otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n\/**\\n * Represents a program.\\n', 'import otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\\n\\nimport java.util.*;\\n\\n\/**\\n * Represents a program.\\n'], 'diff_1': ['        this.id = id;\\n        this.variables = new HashMap<String, Variable>();\\n        this.functions = new HashMap<String, Function>();\\n    }\\n\\n    \/**\\n', '        this.id = id;\\n        this.variables = new HashMap<String, Variable>();\\n        this.functions = new HashMap<String, Function>();\\n\\n        for (Function function : getDefaultFunctions()) {\\n            this.functions.put(function.getId(), function);\\n        }\\n    }\\n\\n    \/**\\n     * Returns the default functions for a program based on the available operators.\\n     * @return The default functions for a program.\\n     *\/\\n    private static Set<Function> getDefaultFunctions() {\\n        final Set<Function> functions = new HashSet<>();\\n\\n        for (Operator op : Operator.values()) {\\n            final Type[] opArgs = op.getArgs();\\n            final Type[] types = Arrays.copyOf(opArgs, opArgs.length + 1);\\n            types[opArgs.length] = op.getType();\\n\\n            functions.add(new Function(op.name(), types));\\n        }\\n\\n        return functions;\\n    }\\n\\n    \/**\\n']}","subject":"","message":"Add default functions\n\n","lang":"Java","license":"","repos":""}
{"commit":"07c9fe87aae60ecb1b18f8d6df3ad82777c64307","old_file":"mapserver-protocols\/src\/main\/java\/org\/geolatte\/mapserver\/protocols\/wms_1_3_0\/WmsBbox.java","new_file":"mapserver-protocols\/src\/main\/java\/org\/geolatte\/mapserver\/protocols\/wms_1_3_0\/WmsBbox.java","old_contents":"package org.geolatte.mapserver.protocols.wms_1_3_0;\n\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CoordinateReferenceSystem;\nimport org.geolatte.geom.crs.CoordinateReferenceSystems;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.geom.crs.CrsRegistry;\n\nimport java.util.Objects;\n\nimport static java.lang.String.format;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 10\/05\/2018.\n *\/\npublic class WmsBbox {\n\n    private final double minX;\n    private final double minY;\n    private final double maxX;\n    private final double maxY;\n\n    public WmsBbox(double minX, double minY, double maxX, double maxY) {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    public double getMinX() {\n        return minX;\n    }\n\n    public double getMinY() {\n        return minY;\n    }\n\n    public double getMaxX() {\n        return maxX;\n    }\n\n    public double getMaxY() {\n        return maxY;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WmsBbox wmsBbox = (WmsBbox) o;\n        return Double.compare(wmsBbox.minX, minX) == 0 &&\n                Double.compare(wmsBbox.minY, minY) == 0 &&\n                Double.compare(wmsBbox.maxX, maxX) == 0 &&\n                Double.compare(wmsBbox.maxY, maxY) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(minX, minY, maxX, maxY);\n    }\n\n    Envelope<C2D> toEnvelope(String srs) {\n        CrsId crsId = CrsId.parse(srs);\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\n            throw new RuntimeException(format(\"Only EPSG CRS strings are supported (%s)\", srs));\n        }\n        CoordinateReferenceSystem<?> crs = CrsRegistry.getCoordinateReferenceSystemForEPSG(crsId.getCode(), CoordinateReferenceSystems.PROJECTED_2D_METER);\n        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\n        }  else {\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.WEB_MERCATOR);\n        }\n\n    }\n}\n","new_contents":"package org.geolatte.mapserver.protocols.wms_1_3_0;\n\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CoordinateReferenceSystem;\nimport org.geolatte.geom.crs.CoordinateReferenceSystems;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.geom.crs.CrsRegistry;\nimport org.geolatte.geom.crs.GeographicCoordinateReferenceSystem;\n\nimport java.util.Objects;\n\nimport static java.lang.String.format;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 10\/05\/2018.\n *\/\npublic class WmsBbox {\n\n    private final double minX;\n    private final double minY;\n    private final double maxX;\n    private final double maxY;\n\n    public WmsBbox(double minX, double minY, double maxX, double maxY) {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    public double getMinX() {\n        return minX;\n    }\n\n    public double getMinY() {\n        return minY;\n    }\n\n    public double getMaxX() {\n        return maxX;\n    }\n\n    public double getMaxY() {\n        return maxY;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WmsBbox wmsBbox = (WmsBbox) o;\n        return Double.compare(wmsBbox.minX, minX) == 0 &&\n                Double.compare(wmsBbox.minY, minY) == 0 &&\n                Double.compare(wmsBbox.maxX, maxX) == 0 &&\n                Double.compare(wmsBbox.maxY, maxY) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(minX, minY, maxX, maxY);\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    Envelope<C2D> toEnvelope(String srs) {\n        CrsId crsId = CrsId.parse(srs);\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\n            throw new RuntimeException(format(\"Only EPSG CRS strings are supported (%s)\", srs));\n        }\n        CoordinateReferenceSystem<?> crs = CrsRegistry.getCoordinateReferenceSystemForEPSG(crsId.getCode(), CoordinateReferenceSystems.PROJECTED_2D_METER);\n        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\n        }  else {\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.asProjected(crs));\n        }\n    }\n}\n","code_block_diff":"{'diff_0': ['import org.geolatte.geom.crs.CoordinateReferenceSystems;\\nimport org.geolatte.geom.crs.CrsId;\\nimport org.geolatte.geom.crs.CrsRegistry;\\n\\nimport java.util.Objects;\\n\\n', 'import org.geolatte.geom.crs.CoordinateReferenceSystems;\\nimport org.geolatte.geom.crs.CrsId;\\nimport org.geolatte.geom.crs.CrsRegistry;\\nimport org.geolatte.geom.crs.GeographicCoordinateReferenceSystem;\\n\\nimport java.util.Objects;\\n\\n'], 'diff_1': ['        return Objects.hash(minX, minY, maxX, maxY);\\n    }\\n\\n    Envelope<C2D> toEnvelope(String srs) {\\n        CrsId crsId = CrsId.parse(srs);\\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\\n', '        return Objects.hash(minX, minY, maxX, maxY);\\n    }\\n\\n    @SuppressWarnings( \"unchecked\" )\\n    Envelope<C2D> toEnvelope(String srs) {\\n        CrsId crsId = CrsId.parse(srs);\\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\\n'], 'diff_2': ['        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\\n        }  else {\\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.WEB_MERCATOR);\\n        }\\n\\n    }\\n}\\n', '        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\\n        }  else {\\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.asProjected(crs));\\n        }\\n    }\\n}\\n']}","subject":"","message":"Support non-projected SRS in maprequest\n\n","lang":"Java","license":"","repos":""}
{"commit":"947de263721911fe939f80a64126c0c7b287b3d0","old_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","new_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","old_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","new_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t}\\n\\n\\t@Override\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n', '\\t}\\n\\n\\t@Override\\n\\t@SuppressWarnings(\"unchecked\")\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n'], 'diff_1': ['\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n', '\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n']}","subject":"","message":"Minor code cleanup\n\n","lang":"Java","license":"","repos":""}
{"commit":"85fff46b5c6c5ecef67d1a2bbbd57dd7e99ea58c","old_file":"src\/cryptography\/ciphers\/elgamal\/ElgamalTest.java","new_file":"src\/cryptography\/ciphers\/elgamal\/ElgamalTest.java","old_contents":"\/**\n * This class is part of running automated tests\n *\/\npackage cryptography.ciphers.elgamal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\nimport cryptography.Logging;\nimport cryptography.Mode;\n\npublic class ElgamalTest {\n\n\t@Test\n\tpublic void runTest() {\n\t\t\n\t\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\n\n\t\tElgamal elgamal = new Elgamal(Logging.DISABLED);\n\t\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\n\n\t\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\n\t\tassertEquals(128, elgamal.getKeyBlockLength());\n\n\t}\n\n}\n","new_contents":"\/**\n * This class is part of running automated tests\n *\/\npackage cryptography.ciphers.elgamal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\nimport cryptography.Logging;\nimport cryptography.Mode;\n\npublic class ElgamalTest {\n\n\t@Test\n\tpublic void runTest() {\n\t\t\n\t\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\n\n\t\t\/*\n\t\tElgamal elgamal = new Elgamal(Logging.DISABLED);\n\t\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\n\n\t\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\n\t\tassertEquals(128, elgamal.getKeyBlockLength());\n\t\t*\/\n\t\t\n\t\t\/\/ TODO: Jenkins will throw JCE cannot authenticate the provider BC because of JDK version. Fix this later.\n\t\t\n\t\tassertEquals(1, 1);\n\n\t}\n\n}\n","code_block_diff":"{'diff_0': ['\\t\\t\\n\\t\\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\\n\\n\\t\\tElgamal elgamal = new Elgamal(Logging.DISABLED);\\n\\t\\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\\n\\n\\t\\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\\n\\t\\tassertEquals(128, elgamal.getKeyBlockLength());\\n\\n\\t}\\n\\n', '\\t\\t\\n\\t\\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\\n\\n\\t\\t\/*\\n\\t\\tElgamal elgamal = new Elgamal(Logging.DISABLED);\\n\\t\\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\\n\\n\\t\\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\\n\\t\\tassertEquals(128, elgamal.getKeyBlockLength());\\n\\t\\t*\/\\n\\t\\t\\n\\t\\t\/\/ TODO: Jenkins will throw JCE cannot authenticate the provider BC because of JDK version. Fix this later.\\n\\t\\t\\n\\t\\tassertEquals(1, 1);\\n\\n\\t}\\n\\n']}","subject":"","message":"Update ElgamalTest.java\n\n","lang":"Java","license":"","repos":""}
{"commit":"de1fcbd8c4de81f24d0339a66e80190fba3149db","old_file":"junit\/src\/test\/java\/com\/github\/fluentxml4j\/junit\/XmlResultTest.java","new_file":"junit\/src\/test\/java\/com\/github\/fluentxml4j\/junit\/XmlResultTest.java","old_contents":"package com.github.fluentxml4j.junit;\n\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class XmlResultTest\n{\n\tprivate static final Charset UTF8 = Charset.forName(\"UTF-8\");\n\n\t@Rule\n\tpublic XmlResult result = XmlResult.empty();\n\n\t@Test\n\tpublic void stringViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n\n\t@Test\n\tpublic void stringViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n}\n","new_contents":"package com.github.fluentxml4j.junit;\n\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\n\nimport com.github.fluentxml4j.junit.XmlSource;\nimport com.github.fluentxml4j.junit.XmlResult;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class XmlResultTest\n{\n\tprivate static final Charset UTF8 = Charset.forName(\"UTF-8\");\n\n\t@Rule\n\tpublic XmlResult result = XmlResult.empty();\n\n\t@Test\n\tpublic void stringViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n\n\t@Test\n\tpublic void stringViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n}\n","code_block_diff":"{'diff_0': ['import java.io.Writer;\\nimport java.nio.charset.Charset;\\n\\nimport static org.hamcrest.CoreMatchers.is;\\nimport static org.hamcrest.MatcherAssert.assertThat;\\n\\n', 'import java.io.Writer;\\nimport java.nio.charset.Charset;\\n\\nimport com.github.fluentxml4j.junit.XmlSource;\\nimport com.github.fluentxml4j.junit.XmlResult;\\n\\nimport static org.hamcrest.CoreMatchers.is;\\nimport static org.hamcrest.MatcherAssert.assertThat;\\n\\n']}","subject":"","message":"more\n\nTask: none\n\nReviewed by noone.\n\n","lang":"Java","license":"","repos":""}
{"commit":"09016a53aa37f23ff54e8a1dd4df81fd73c064e9","old_file":"sampleapp\/src\/main\/java\/com\/mindscapehq\/raygun4java\/sampleapp\/SampleApp.java","new_file":"sampleapp\/src\/main\/java\/com\/mindscapehq\/raygun4java\/sampleapp\/SampleApp.java","old_contents":"package com.mindscapehq.raygun4java.sampleapp;\n\nimport com.mindscapehq.raygun4java.core.IRaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.IRaygunOnAfterSend;\nimport com.mindscapehq.raygun4java.core.IRaygunOnBeforeSend;\nimport com.mindscapehq.raygun4java.core.IRaygunSendEventFactory;\nimport com.mindscapehq.raygun4java.core.RaygunClient;\nimport com.mindscapehq.raygun4java.core.RaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.RaygunSettings;\nimport com.mindscapehq.raygun4java.core.messages.RaygunIdentifier;\nimport com.mindscapehq.raygun4java.core.messages.RaygunMessage;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\n\/**\n * To test with getting the version from the jar\n * mvn clean package install\n * java -jar sampleapp\\target\\sampleapp-3.0.0-SNAPSHOT-jar-with-dependencies.jar\n *\/\npublic class SampleApp {\n\n    public static final String API_KEY = \"YOUR_API_KEY\";\n\n    \/**\n     * An example of how to use Raygun4Java\n     *\/\n    public static void main(String[] args) throws Throwable {\n\n        final Exception exceptionToThrowLater = new Exception(\"Raygun4Java test exception\");\n\n        \/\/ sets the global unhandled exception handler\n        Thread.setDefaultUncaughtExceptionHandler(MyExceptionHandler.instance());\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"App starting up\");\n\n        RaygunIdentifier userIdentity = new RaygunIdentifier(\"a@b.com\")\n                .withEmail(\"a@b.com\")\n                .withFirstName(\"Foo\")\n                .withFullName(\"Foo Bar\")\n                .withAnonymous(false)\n                .withUuid(UUID.randomUUID().toString());\n        MyExceptionHandler.getClient().setUser(userIdentity);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                MyExceptionHandler.getClient().recordBreadcrumb(\"different thread starting\");\n\n                \/\/ note that use info not set on this thread\n\n                try {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception\");\n                    throw exceptionToThrowLater;\n                } catch (Exception e) {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception\");\n\n                    Map<String, String> customData = new HashMap<String, String>();\n                    customData.put(\"thread id\", \"\" + Thread.currentThread().getId());\n                    MyExceptionHandler.getClient()\n                            .withTag(\"thrown from thread\")\n                            .withTag(\"no user withData\")\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\n                            .send(exceptionToThrowLater);\n\n                    \/\/ this should appear in the raygun console as its already been sed\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This should not appear because we're sending the same exception on the same thread\");\n                    Set<String> tags = new HashSet<String>();\n                    tags.add(\"should not appear in console\");\n                    MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\n                }\n\n                \/\/ test offline storage by breaking the proxy\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\n\n                System.out.println(\"No Send below this line\");\n                MyExceptionHandler.getClient().send(new Exception(\"occurred while offline offline\"));\n                System.out.println(\"No Send above this lines ^\");\n\n                \/\/ fix the proxy and send offline data\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\n                MyExceptionHandler.getClient().send(new Exception(\"This should trigger offline\"));\n\n            }\n        }).start();\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\n        throw exceptionToThrowLater;\n    }\n}\n\nclass BeforeSendImplementation implements IRaygunOnBeforeSend, IRaygunSendEventFactory<IRaygunOnBeforeSend> {\n    @Override\n    public RaygunMessage onBeforeSend(RaygunClient client, RaygunMessage message) {\n        String errorMessage = message.getDetails().getError().getMessage();\n        message.getDetails().getError().setMessage(errorMessage + \" - I have been mutated by onBeforeSend\");\n\n        message.getDetails().setGroupingKey(\"baz2\");\n\n        return message;\n    }\n\n    @Override\n    public IRaygunOnBeforeSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}\n\nclass MyExceptionHandler implements Thread.UncaughtExceptionHandler {\n\n    private static MyExceptionHandler instance;\n\n    static {\n        instance = new MyExceptionHandler();\n    }\n\n    public static Thread.UncaughtExceptionHandler instance() {\n        return instance;\n    }\n\n    private IRaygunClientFactory factory;\n    private ThreadLocal<RaygunClient> clients = new ThreadLocal<RaygunClient>();\n\n    public MyExceptionHandler() {\n        factory = new RaygunClientFactory(SampleApp.API_KEY)\n                .withBreadcrumbLocations() \/\/ don't do this in production\n                .withBeforeSend(new BeforeSendImplementation())\n                .withAfterSend(new MyOnAfterHandler())\n                .withOfflineStorage()\n                .withTag(\"from sample app\")\n                .withData(\"how now\", \"brown cow\")\n                .withData(1, Arrays.asList(123));\n    }\n\n    public static RaygunClient getClient() {\n        RaygunClient client = instance.clients.get();\n        if (client == null) {\n            client = instance.factory.newClient();\n            instance.clients.set(client);\n        }\n        return client;\n    }\n\n    public void uncaughtException(Thread t, Throwable e) {\n        getClient().sendUnhandled(e);\n    }\n}\n\nclass MyOnAfterHandler implements IRaygunOnAfterSend, IRaygunSendEventFactory<IRaygunOnAfterSend> {\n\n    @Override\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\n        System.out.println(\"We sent a error to ragun!\");\n        return message;\n    }\n\n    @Override\n    public IRaygunOnAfterSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}","new_contents":"package com.mindscapehq.raygun4java.sampleapp;\n\nimport com.mindscapehq.raygun4java.core.IRaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.IRaygunOnAfterSend;\nimport com.mindscapehq.raygun4java.core.IRaygunOnBeforeSend;\nimport com.mindscapehq.raygun4java.core.IRaygunSendEventFactory;\nimport com.mindscapehq.raygun4java.core.RaygunClient;\nimport com.mindscapehq.raygun4java.core.RaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.RaygunSettings;\nimport com.mindscapehq.raygun4java.core.messages.RaygunIdentifier;\nimport com.mindscapehq.raygun4java.core.messages.RaygunMessage;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\n\/**\n * To test with getting the version from the jar\n * mvn clean package install\n * java -jar sampleapp\\target\\sampleapp-<version>-jar-with-dependencies.jar\n *\/\npublic class SampleApp {\n\n    public static final String API_KEY = \"YOUR_API_KEY\";\n\n    \/**\n     * An example of how to use Raygun4Java\n     *\/\n    public static void main(String[] args) throws Throwable {\n\n        final Exception exceptionToThrowLater = new Exception(\"Raygun4Java test exception\");\n\n        \/\/ sets the global unhandled exception handler\n        Thread.setDefaultUncaughtExceptionHandler(MyExceptionHandler.instance());\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"App starting up\");\n\n        RaygunIdentifier userIdentity = new RaygunIdentifier(\"a@b.com\")\n                .withEmail(\"a@b.com\")\n                .withFirstName(\"Foo\")\n                .withFullName(\"Foo Bar\")\n                .withAnonymous(false)\n                .withUuid(UUID.randomUUID().toString());\n        MyExceptionHandler.getClient().setUser(userIdentity);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                MyExceptionHandler.getClient().recordBreadcrumb(\"first thread starting\");\n\n                \/\/ note that user info is not set on this thread\n                try {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception in a thread\");\n                    throw exceptionToThrowLater;\n                } catch (Exception e) {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception in a thread\");\n\n                    int result_thread = MyExceptionHandler.getClient()\n                            .withTag(\"thrown from a thread\")\n                            .withTag(\"no user withData\")\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\n                            .send(exceptionToThrowLater);\n\n                    System.out.println(\"[SampleApp-Thread] First sending of the exception from a thread, result: \" + result_thread);\n\n                    \/\/ Breadcrumb will be set on the RaygunClient object\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This will appear in exceptions further down, outside of this catch\");\n\n                    \/\/ This additional send should not appear in the Raygun back end as the exception has already been sent\n                    Set<String> tags = new HashSet<String>();\n                    tags.add(\"should not appear in console\");\n                    int result_notSucessful = MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\n                    System.out.println(\"[SampleApp-Thread] Second sending of the same exception from same thread, result: \" + result_notSucessful);\n                }\n\n                \/\/ test offline storage by breaking the proxy\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\n\n                System.out.println(\"[SampleApp-Thread] No send below this line\");\n                int result_fakeOffline = MyExceptionHandler.getClient().send(new Exception(\"This occurred while offline\"));\n                System.out.println(\"[SampleApp-Thread] Sending an exception while offline, result: \" + result_fakeOffline);\n                System.out.println(\"[SampleApp-Thread] No send above this line ^\");\n\n                \/\/ fix the proxy and send offline data\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\n                int result_backOnline = MyExceptionHandler.getClient().send(new Exception(\"This should trigger sending the previous offline report\"));\n                System.out.println(\"[SampleApp-Thread] Sending an exception when back online, result: \" + result_backOnline);\n            }\n        }).start();\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\n        \/\/ This can be thrown *again* from the main thread\n        throw exceptionToThrowLater;\n    }\n}\n\nclass BeforeSendImplementation implements IRaygunOnBeforeSend, IRaygunSendEventFactory<IRaygunOnBeforeSend> {\n    @Override\n    public RaygunMessage onBeforeSend(RaygunClient client, RaygunMessage message) {\n        String errorMessage = message.getDetails().getError().getMessage();\n        message.getDetails().getError().setMessage(errorMessage + \" - I have been mutated by onBeforeSend\");\n\n        message.getDetails().setGroupingKey(\"baz2\");\n\n        return message;\n    }\n\n    @Override\n    public IRaygunOnBeforeSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}\n\nclass MyExceptionHandler implements Thread.UncaughtExceptionHandler {\n\n    private static MyExceptionHandler instance;\n\n    static {\n        instance = new MyExceptionHandler();\n    }\n\n    public static Thread.UncaughtExceptionHandler instance() {\n        return instance;\n    }\n\n    private IRaygunClientFactory factory;\n    private ThreadLocal<RaygunClient> clients = new ThreadLocal<RaygunClient>();\n\n    public MyExceptionHandler() {\n        factory = new RaygunClientFactory(SampleApp.API_KEY)\n                .withBreadcrumbLocations() \/\/ don't do this in production\n                .withBeforeSend(new BeforeSendImplementation())\n                .withAfterSend(new MyOnAfterHandler())\n                .withOfflineStorage()\n                .withTag(\"from sample app\")\n                .withData(\"how now\", \"brown cow\")\n                .withData(1, Arrays.asList(123));\n    }\n\n    public static RaygunClient getClient() {\n        RaygunClient client = instance.clients.get();\n        if (client == null) {\n            client = instance.factory.newClient();\n            instance.clients.set(client);\n        }\n        return client;\n    }\n\n    public void uncaughtException(Thread t, Throwable e) {\n        getClient().sendUnhandled(e);\n    }\n}\n\nclass MyOnAfterHandler implements IRaygunOnAfterSend, IRaygunSendEventFactory<IRaygunOnAfterSend> {\n\n    @Override\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\n        System.out.println(\"[OnAfterSend] We sent a error to Raygun!\");\n        return message;\n    }\n\n    @Override\n    public IRaygunOnAfterSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}","code_block_diff":"{'diff_0': ['\/**\\n * To test with getting the version from the jar\\n * mvn clean package install\\n * java -jar sampleapp\\\\target\\\\sampleapp-3.0.0-SNAPSHOT-jar-with-dependencies.jar\\n *\/\\npublic class SampleApp {\\n\\n', '\/**\\n * To test with getting the version from the jar\\n * mvn clean package install\\n * java -jar sampleapp\\\\target\\\\sampleapp-<version>-jar-with-dependencies.jar\\n *\/\\npublic class SampleApp {\\n\\n'], 'diff_1': ['        new Thread(new Runnable() {\\n            @Override\\n            public void run() {\\n                MyExceptionHandler.getClient().recordBreadcrumb(\"different thread starting\");\\n\\n                \/\/ note that use info not set on this thread\\n\\n                try {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception\");\\n                    throw exceptionToThrowLater;\\n                } catch (Exception e) {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception\");\\n\\n                    Map<String, String> customData = new HashMap<String, String>();\\n                    customData.put(\"thread id\", \"\" + Thread.currentThread().getId());\\n                    MyExceptionHandler.getClient()\\n                            .withTag(\"thrown from thread\")\\n                            .withTag(\"no user withData\")\\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\\n                            .send(exceptionToThrowLater);\\n\\n                    \/\/ this should appear in the raygun console as its already been sed\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This should not appear because we\\'re sending the same exception on the same thread\");\\n                    Set<String> tags = new HashSet<String>();\\n                    tags.add(\"should not appear in console\");\\n                    MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\\n                }\\n\\n                \/\/ test offline storage by breaking the proxy\\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\\n\\n                System.out.println(\"No Send below this line\");\\n                MyExceptionHandler.getClient().send(new Exception(\"occurred while offline offline\"));\\n                System.out.println(\"No Send above this lines ^\");\\n\\n                \/\/ fix the proxy and send offline data\\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\\n                MyExceptionHandler.getClient().send(new Exception(\"This should trigger offline\"));\\n\\n            }\\n        }).start();\\n\\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\\n        throw exceptionToThrowLater;\\n    }\\n}\\n', '        new Thread(new Runnable() {\\n            @Override\\n            public void run() {\\n                MyExceptionHandler.getClient().recordBreadcrumb(\"first thread starting\");\\n\\n                \/\/ note that user info is not set on this thread\\n                try {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception in a thread\");\\n                    throw exceptionToThrowLater;\\n                } catch (Exception e) {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception in a thread\");\\n\\n                    int result_thread = MyExceptionHandler.getClient()\\n                            .withTag(\"thrown from a thread\")\\n                            .withTag(\"no user withData\")\\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\\n                            .send(exceptionToThrowLater);\\n\\n                    System.out.println(\"[SampleApp-Thread] First sending of the exception from a thread, result: \" + result_thread);\\n\\n                    \/\/ Breadcrumb will be set on the RaygunClient object\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This will appear in exceptions further down, outside of this catch\");\\n\\n                    \/\/ This additional send should not appear in the Raygun back end as the exception has already been sent\\n                    Set<String> tags = new HashSet<String>();\\n                    tags.add(\"should not appear in console\");\\n                    int result_notSucessful = MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\\n                    System.out.println(\"[SampleApp-Thread] Second sending of the same exception from same thread, result: \" + result_notSucessful);\\n                }\\n\\n                \/\/ test offline storage by breaking the proxy\\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\\n\\n                System.out.println(\"[SampleApp-Thread] No send below this line\");\\n                int result_fakeOffline = MyExceptionHandler.getClient().send(new Exception(\"This occurred while offline\"));\\n                System.out.println(\"[SampleApp-Thread] Sending an exception while offline, result: \" + result_fakeOffline);\\n                System.out.println(\"[SampleApp-Thread] No send above this line ^\");\\n\\n                \/\/ fix the proxy and send offline data\\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\\n                int result_backOnline = MyExceptionHandler.getClient().send(new Exception(\"This should trigger sending the previous offline report\"));\\n                System.out.println(\"[SampleApp-Thread] Sending an exception when back online, result: \" + result_backOnline);\\n            }\\n        }).start();\\n\\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\\n        \/\/ This can be thrown *again* from the main thread\\n        throw exceptionToThrowLater;\\n    }\\n}\\n'], 'diff_2': ['\\n    @Override\\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\\n        System.out.println(\"We sent a error to ragun!\");\\n        return message;\\n    }\\n\\n', '\\n    @Override\\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\\n        System.out.println(\"[OnAfterSend] We sent a error to Raygun!\");\\n        return message;\\n    }\\n\\n']}","subject":"","message":"Cleanup and improvements for sample app\n\n","lang":"Java","license":"","repos":""}
{"commit":"a78138cde8583de24cf182261649b100482db16e","old_file":"core\/src\/main\/java\/com\/mindscapehq\/raygun4java\/core\/messages\/RaygunEnvironmentMessage.java","new_file":"core\/src\/main\/java\/com\/mindscapehq\/raygun4java\/core\/messages\/RaygunEnvironmentMessage.java","old_contents":"package com.mindscapehq.raygun4java.core.messages;\n\nimport java.awt.*;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.lang.management.OperatingSystemMXBean;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class RaygunEnvironmentMessage {\n\n\tprivate String cpu;\n\tprivate String architecture;\n\tprivate int processorCount;\n\tprivate String osVersion;\n\tprivate int windowBoundsWidth;\n\tprivate int windowBoundsHeight;\n\tprivate String currentOrientation;\n\tprivate String locale;\n\tprivate long totalPhysicalMemory;\n\tprivate long availablePhysicalMemory;\n\tprivate long totalVirtualMemory;\n\tprivate long availableVirtualMemory;\n\tprivate int diskSpaceFree;\n\tprivate double utcOffset;\n\tprivate static String message = \"Couldn't access all environment data. If you are running in GAE or a restricted environment this is expected\";\n\tprivate static Logger logger = Logger.getLogger(\"Raygun4Java.environment\");\n\n\tpublic RaygunEnvironmentMessage() {\n\t\ttry {\n\t\t\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tlocale = Locale.getDefault().getLanguage() + \"-\"\n\t\t\t\t\t+ Locale.getDefault().getCountry();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\twindowBoundsWidth = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;\n\t\t\twindowBoundsHeight = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tprocessorCount = Runtime.getRuntime().availableProcessors();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tMemoryMXBean memBean = ManagementFactory.getMemoryMXBean();\n\n\t\t\ttotalVirtualMemory = memBean.getHeapMemoryUsage().getMax()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getMax();\n\t\t\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getUsed();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tOperatingSystemMXBean osMXBean = ManagementFactory\n\t\t\t\t\t.getOperatingSystemMXBean();\n\t\t\tarchitecture = osMXBean.getArch();\n\t\t\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\t}\n}\n","new_contents":"package com.mindscapehq.raygun4java.core.messages;\n\nimport java.awt.*;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.lang.management.OperatingSystemMXBean;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class RaygunEnvironmentMessage {\n\n\tprivate String cpu;\n\tprivate String architecture;\n\tprivate int processorCount;\n\tprivate String osVersion;\n\tprivate int windowBoundsWidth;\n\tprivate int windowBoundsHeight;\n\tprivate String currentOrientation;\n\tprivate String locale;\n\tprivate long totalPhysicalMemory;\n\tprivate long availablePhysicalMemory;\n\tprivate long totalVirtualMemory;\n\tprivate long availableVirtualMemory;\n\tprivate int diskSpaceFree;\n\tprivate double utcOffset;\n\tprivate static String message = \"Couldn't access all environment data. If you are running in GAE or a restricted environment this is expected\";\n\tprivate static Logger logger = Logger.getLogger(\"Raygun4Java.environment\");\n\n\tpublic RaygunEnvironmentMessage() {\n\t\ttry {\n\t\t\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tlocale = Locale.getDefault().getLanguage() + \"-\"\n\t\t\t\t\t+ Locale.getDefault().getCountry();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\twindowBoundsWidth = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;\n\t\t\twindowBoundsHeight = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tprocessorCount = Runtime.getRuntime().availableProcessors();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tMemoryMXBean memBean = ManagementFactory.getMemoryMXBean();\n\n\t\t\ttotalVirtualMemory = memBean.getHeapMemoryUsage().getMax()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getMax();\n\t\t\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getUsed();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tOperatingSystemMXBean osMXBean = ManagementFactory\n\t\t\t\t\t.getOperatingSystemMXBean();\n\t\t\tarchitecture = osMXBean.getArch();\n\t\t\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t\\ttry {\\n\\t\\t\\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tlocale = Locale.getDefault().getLanguage() + \"-\"\\n\\t\\t\\t\\t\\t+ Locale.getDefault().getCountry();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\ttry {\\n\\t\\t\\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tlocale = Locale.getDefault().getLanguage() + \"-\"\\n\\t\\t\\t\\t\\t+ Locale.getDefault().getCountry();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_1': ['\\t\\t\\twindowBoundsHeight = GraphicsEnvironment\\n\\t\\t\\t\\t\\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tprocessorCount = Runtime.getRuntime().availableProcessors();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\t\\twindowBoundsHeight = GraphicsEnvironment\\n\\t\\t\\t\\t\\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tprocessorCount = Runtime.getRuntime().availableProcessors();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_2': ['\\t\\t\\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\\n\\t\\t\\t\\t\\t+ memBean.getNonHeapMemoryUsage().getUsed();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\t\\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\\n\\t\\t\\t\\t\\t+ memBean.getNonHeapMemoryUsage().getUsed();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_3': ['\\t\\t\\tarchitecture = osMXBean.getArch();\\n\\t\\t\\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\t}\\n}\\n', '\\t\\t\\tarchitecture = osMXBean.getArch();\\n\\t\\t\\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\t}\\n}\\n']}","subject":"","message":"Lower environment logging error level to Finest\n\nref #26\n\n","lang":"Java","license":"","repos":""}
{"commit":"23ad57d8ff1e6f95c9f80a297d47f00a662eff30","old_file":"reark\/src\/main\/java\/io\/reark\/reark\/data\/stores\/cores\/MemoryStoreCore.java","new_file":"reark\/src\/main\/java\/io\/reark\/reark\/data\/stores\/cores\/MemoryStoreCore.java","old_contents":"\/*\n * The MIT License\n *\n * Copyright (c) 2013-2016 reark project contributors\n *\n * https:\/\/github.com\/reark\/reark\/graphs\/contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage io.reark.reark.data.stores.cores;\n\nimport android.support.annotation.NonNull;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport io.reactivex.Maybe;\nimport io.reactivex.Observable;\nimport io.reactivex.Single;\nimport io.reactivex.functions.BiFunction;\nimport io.reactivex.subjects.PublishSubject;\nimport io.reactivex.subjects.Subject;\nimport io.reark.reark.data.stores.StoreItem;\nimport io.reark.reark.data.stores.interfaces.StoreCoreInterface;\nimport io.reark.reark.utils.Log;\n\nimport static io.reark.reark.utils.Preconditions.checkNotNull;\nimport static io.reark.reark.utils.Preconditions.get;\n\n\/**\n * A simple StoreCore that only uses an in-memory ConcurrentHashMap to persist the data. This means\n * that the MemoryStoreCore cannot be shared across Android processes and it will be destroyed with\n * the app.\n *\n * @param <T> Type of the id used in this store core.\n * @param <U> Type of the data this store core contains.\n *\/\npublic class MemoryStoreCore<T, U> implements StoreCoreInterface<T, U> {\n    private static final String TAG = MemoryStoreCore.class.getSimpleName();\n\n    @NonNull\n    private final BiFunction<U, U, U> putMergeFunction;\n\n    @NonNull\n    private final Map<Integer, U> cache = new ConcurrentHashMap<>(10);\n\n    @NonNull\n    private final PublishSubject<StoreItem<T, U>> subject = PublishSubject.create();\n\n    @NonNull\n    private final ConcurrentMap<Integer, Subject<U>> subjectCache = new ConcurrentHashMap<>(20, 0.75f, 4);\n\n    public MemoryStoreCore() {\n        this((v1, v2) -> v2);\n    }\n\n    public MemoryStoreCore(@NonNull final BiFunction<U, U, U> putMergeFunction) {\n        this.putMergeFunction = get(putMergeFunction);\n    }\n\n    @NonNull\n    @Override\n    public Maybe<U> getCached(@NonNull final T id) {\n        checkNotNull(id);\n\n        final U value = cache.get(getHashCodeForId(id));\n\n        return value == null\n                ? Maybe.empty()\n                : Maybe.just(value);\n    }\n\n    @NonNull\n    @Override\n    public Single<List<U>> getCached() {\n        return Observable.fromIterable(() -> cache.keySet().iterator())\n                .map(cache::get)\n                .toList();\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream(@NonNull final T id) {\n        checkNotNull(id);\n\n        int hash = getHashCodeForId(id);\n        subjectCache.putIfAbsent(hash, PublishSubject.create());\n\n        return subjectCache.get(hash);\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream() {\n        return subject.map(StoreItem::item);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> put(@NonNull final T id, @NonNull final U item) {\n        checkNotNull(id);\n        checkNotNull(item);\n\n        final int hash = getHashCodeForId(id);\n        U newItem = item;\n        boolean valuesEqual = false;\n\n        if (cache.containsKey(hash)) {\n            final U currentItem = cache.get(hash);\n\n            valuesEqual = newItem.equals(currentItem);\n\n            if (!valuesEqual) {\n                Log.v(TAG, \"Merging values at \" + id);\n                try {\n                    newItem = putMergeFunction.apply(currentItem, newItem);\n                } catch (Exception e) {\n                    return Single.error(e);\n                }\n                valuesEqual = newItem.equals(currentItem);\n            }\n        }\n\n        if (valuesEqual) {\n            Log.v(TAG, \"Data already up to date at \" + id);\n            return Single.just(false);\n        }\n\n        cache.put(hash, newItem);\n        subject.onNext(new StoreItem<>(id, newItem));\n\n        if (subjectCache.containsKey(hash)) {\n            subjectCache.get(hash).onNext(newItem);\n        }\n\n        return Single.just(true);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> delete(@NonNull final T id) {\n        return Single.fromCallable(() -> cache.remove(getHashCodeForId(id)) != null);\n    }\n\n    protected int getHashCodeForId(@NonNull final T id) {\n        checkNotNull(id);\n\n        return id.hashCode();\n    }\n}\n","new_contents":"\/*\n * The MIT License\n *\n * Copyright (c) 2013-2016 reark project contributors\n *\n * https:\/\/github.com\/reark\/reark\/graphs\/contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage io.reark.reark.data.stores.cores;\n\nimport android.support.annotation.NonNull;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport io.reactivex.Maybe;\nimport io.reactivex.Observable;\nimport io.reactivex.Single;\nimport io.reactivex.functions.BiFunction;\nimport io.reactivex.subjects.PublishSubject;\nimport io.reactivex.subjects.Subject;\nimport io.reark.reark.data.stores.StoreItem;\nimport io.reark.reark.data.stores.interfaces.StoreCoreInterface;\nimport io.reark.reark.utils.Log;\n\nimport static io.reark.reark.utils.Preconditions.checkNotNull;\nimport static io.reark.reark.utils.Preconditions.get;\n\n\/**\n * A simple StoreCore that only uses an in-memory ConcurrentHashMap to persist the data. This means\n * that the MemoryStoreCore cannot be shared across Android processes and it will be destroyed with\n * the app.\n *\n * @param <T> Type of the id used in this store core.\n * @param <U> Type of the data this store core contains.\n *\/\npublic class MemoryStoreCore<T, U> implements StoreCoreInterface<T, U> {\n    private static final String TAG = MemoryStoreCore.class.getSimpleName();\n\n    @NonNull\n    private final BiFunction<U, U, U> putMergeFunction;\n\n    @NonNull\n    private final Map<Integer, U> cache = new ConcurrentHashMap<>(10);\n\n    @NonNull\n    private final PublishSubject<StoreItem<T, U>> subject = PublishSubject.create();\n\n    @NonNull\n    private final ConcurrentMap<Integer, Subject<U>> subjectCache = new ConcurrentHashMap<>(20, 0.75f, 4);\n\n    public MemoryStoreCore() {\n        this((v1, v2) -> v2);\n    }\n\n    public MemoryStoreCore(@NonNull final BiFunction<U, U, U> putMergeFunction) {\n        this.putMergeFunction = get(putMergeFunction);\n    }\n\n    @NonNull\n    @Override\n    public Maybe<U> getCached(@NonNull final T id) {\n        checkNotNull(id);\n\n        final U value = cache.get(getHashCodeForId(id));\n\n        return value == null\n                ? Maybe.empty()\n                : Maybe.just(value);\n    }\n\n    @NonNull\n    @Override\n    public Single<List<U>> getCached() {\n        return Observable.fromIterable(cache.keySet())\n                .map(cache::get)\n                .toList();\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream(@NonNull final T id) {\n        checkNotNull(id);\n\n        int hash = getHashCodeForId(id);\n        subjectCache.putIfAbsent(hash, PublishSubject.create());\n\n        return subjectCache.get(hash);\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream() {\n        return subject.map(StoreItem::item);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> put(@NonNull final T id, @NonNull final U item) {\n        checkNotNull(id);\n        checkNotNull(item);\n\n        final int hash = getHashCodeForId(id);\n        U newItem = item;\n        boolean valuesEqual = false;\n\n        if (cache.containsKey(hash)) {\n            final U currentItem = cache.get(hash);\n\n            valuesEqual = newItem.equals(currentItem);\n\n            if (!valuesEqual) {\n                Log.v(TAG, \"Merging values at \" + id);\n                try {\n                    newItem = putMergeFunction.apply(currentItem, newItem);\n                } catch (Exception e) {\n                    return Single.error(e);\n                }\n                valuesEqual = newItem.equals(currentItem);\n            }\n        }\n\n        if (valuesEqual) {\n            Log.v(TAG, \"Data already up to date at \" + id);\n            return Single.just(false);\n        }\n\n        cache.put(hash, newItem);\n        subject.onNext(new StoreItem<>(id, newItem));\n\n        if (subjectCache.containsKey(hash)) {\n            subjectCache.get(hash).onNext(newItem);\n        }\n\n        return Single.just(true);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> delete(@NonNull final T id) {\n        return Single.fromCallable(() -> cache.remove(getHashCodeForId(id)) != null);\n    }\n\n    protected int getHashCodeForId(@NonNull final T id) {\n        checkNotNull(id);\n\n        return id.hashCode();\n    }\n}\n","code_block_diff":"{'diff_0': ['    @NonNull\\n    @Override\\n    public Single<List<U>> getCached() {\\n        return Observable.fromIterable(() -> cache.keySet().iterator())\\n                .map(cache::get)\\n                .toList();\\n    }\\n', '    @NonNull\\n    @Override\\n    public Single<List<U>> getCached() {\\n        return Observable.fromIterable(cache.keySet())\\n                .map(cache::get)\\n                .toList();\\n    }\\n']}","subject":"","message":"No need to explicitly get the iterator\n\n","lang":"Java","license":"","repos":""}
{"commit":"30b35b28def049ccff58a79846af5e9258a7848f","old_file":"space-server\/src\/test\/java\/com\/space\/server\/engine\/impl\/ServerEngineImplTest.java","new_file":"space-server\/src\/test\/java\/com\/space\/server\/engine\/impl\/ServerEngineImplTest.java","old_contents":"package com.space.server.engine.impl;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport com.space.server.domain.api.SpaceWorld;\nimport com.space.server.engine.api.GameEngine;\nimport com.space.server.engine.api.WorldEvent;\nimport com.space.server.engine.api.WorldEventType;\nimport org.eclipse.jetty.websocket.api.RemoteEndpoint;\nimport org.eclipse.jetty.websocket.api.Session;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n\/**\n * Created by superernie77 on 11.02.2017.\n *\/\npublic class ServerEngineImplTest {\n\n    private ServerEngineImpl serverEngine;\n\n    private GameEngine gameEngine;\n\n    private ScheduledExecutorService executorService;\n\n    @Before\n    public void setup(){\n        serverEngine = new ServerEngineImpl();\n\n        gameEngine = mock(GameEngine.class);\n\n        executorService = mock(ScheduledExecutorService.class);\n        when(executorService.scheduleAtFixedRate(any(Runnable.class),anyLong(),anyLong(),any(TimeUnit.class))).thenReturn(mock(ScheduledFuture.class));\n\n        serverEngine.setEngine(gameEngine);\n        serverEngine.setScheduledExecutorService(executorService);\n    }\n\n    @Test\n    public void testDBSchutdown(){\n        serverEngine.shutdownDatabase();\n        verify(gameEngine,times(1)).shutdownDatabase();\n    }\n\n    @Test\n    public void testAddEvent(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        SpaceWorld world = mock(SpaceWorld.class);\n        when(gameEngine.getWorld(anyInt())).thenReturn(world);\n\n        serverEngine.addEvent(event);\n\n        verify(world,times(1)).addEvent(event);\n    }\n\n    @Test\n    public void testStopGame(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        serverEngine.stopGame(event);\n\n        verify(gameEngine,times(1)).stopGame(anyInt(),anyInt());\n    }\n\n    @Test\n    public void testStopBroadcast(){\n\n        WorldEvent event = new WorldEventImpl();\n        event.setWorldId(0);\n        event.setPlayerId(0);\n        event.setType(WorldEventType.STOP);\n\n        \/\/ Init a world started with one player\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        serverEngine.getPlayerWorldMap().put(0, player);\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n\n        serverEngine.stopGame(event);\n\n        \/\/ world with player has been stoped\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 0);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 0);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 0);\n    }\n\n    @Test\n    public void testStartGame(){\n\n        serverEngine.startGame(0,0, mock(Session.class));\n\n        \/\/ world with player has been created and started to run\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n    }\n\n    @Test\n    public void startGameTwice(){\n        serverEngine.startGame(0,0, mock(Session.class));\n        serverEngine.startGame(0,0, mock(Session.class));\n\n        \/\/ game only started once\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n    }\n\n    @Test\n    public void startGameWith2Players(){\n\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,1, session);\n\n        \/\/ one world started\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n\n        \/\/ two player inside world 0\n        assertTrue(serverEngine.getPlayerWorldMap().get(0).size() == 2);\n\n        \/\/ one future\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n\n        \/\/ two player\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 2);\n\n        \/\/ world started for player 1\n        verify(gameEngine,times(1)).startGame(anyInt(),anyInt());\n\n        \/\/ player 2 added to world\n        verify(gameEngine,times(1)).addPlayer2World(anyInt(),anyInt());\n\n        \/\/ start game broadcasted once\n        verify(session, times(2)).getRemote();\n    }\n\n    @Test\n    public void testRunner() throws Exception {\n        ServerEngineImpl.Runner runner = serverEngine.new Runner();\n\n        \/\/ player in world 0\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        player.add(1);\n        serverEngine.getPlayerWorldMap().put(0, player);\n\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n        serverEngine.getPlayerSessionMap().put(1, mock(Session.class));\n\n        \/\/ create broadcaster\n        Broadcaster b = mock(Broadcaster.class);\n        when(b.createWorldEvent(anyInt())).thenReturn(new WorldEventImpl());\n        when(b.getEngine()).thenReturn(gameEngine);\n        runner.setBroadCaster(b);\n\n        \/\/ broadcast\n        runner.run();\n\n        \/\/ world has been broadcast by the runner the players\n        verify(b, times(2)).broadcast(any(Session.class), any(WorldEvent.class));\n    }\n\n}\n","new_contents":"package com.space.server.engine.impl;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport com.space.server.domain.api.SpaceWorld;\nimport com.space.server.engine.api.GameEngine;\nimport com.space.server.engine.api.WorldEvent;\nimport com.space.server.engine.api.WorldEventType;\nimport org.eclipse.jetty.websocket.api.RemoteEndpoint;\nimport org.eclipse.jetty.websocket.api.Session;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n\/**\n * Created by superernie77 on 11.02.2017.\n *\/\npublic class ServerEngineImplTest {\n\n    private ServerEngineImpl serverEngine;\n\n    private GameEngine gameEngine;\n\n    private ScheduledExecutorService executorService;\n\n    @Before\n    public void setup(){\n        serverEngine = new ServerEngineImpl();\n\n        gameEngine = mock(GameEngine.class);\n\n        executorService = mock(ScheduledExecutorService.class);\n        when(executorService.scheduleAtFixedRate(any(Runnable.class),anyLong(),anyLong(),any(TimeUnit.class))).thenReturn(mock(ScheduledFuture.class));\n\n        serverEngine.setEngine(gameEngine);\n        serverEngine.setScheduledExecutorService(executorService);\n    }\n\n    @Test\n    public void testDBSchutdown(){\n        serverEngine.shutdownDatabase();\n        verify(gameEngine,times(1)).shutdownDatabase();\n    }\n\n    @Test\n    public void testAddEvent(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        SpaceWorld world = mock(SpaceWorld.class);\n        when(gameEngine.getWorld(anyInt())).thenReturn(world);\n\n        serverEngine.addEvent(event);\n\n        verify(world,times(1)).addEvent(event);\n    }\n\n    @Test\n    public void testStopGame(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        serverEngine.stopGame(event);\n\n        verify(gameEngine,times(1)).stopGame(anyInt(),anyInt());\n    }\n\n    @Test\n    public void testStopBroadcast(){\n\n        WorldEvent event = new WorldEventImpl();\n        event.setWorldId(0);\n        event.setPlayerId(0);\n        event.setType(WorldEventType.STOP);\n\n        \/\/ Init a world started with one player\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        serverEngine.getPlayerWorldMap().put(0, player);\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n\n        serverEngine.stopGame(event);\n\n        \/\/ world with player has been stoped\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 0);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 0);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 0);\n    }\n\n    @Test\n    public void testStartGame(){\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n\n        \/\/ world with player has been created and started to run\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n\n        \/\/ broadcasted once\n        verify(session, times(1)).getRemote();\n    }\n\n    @Test\n    public void startGameTwice(){\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,0, session);\n\n        \/\/ game only started once\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n\n        verify(session, times(1)).getRemote();\n    }\n\n    @Test\n    public void startGameWith2Players(){\n\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,1, session);\n\n        \/\/ one world started\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n\n        \/\/ two player inside world 0\n        assertTrue(serverEngine.getPlayerWorldMap().get(0).size() == 2);\n\n        \/\/ one future\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n\n        \/\/ two player\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 2);\n\n        \/\/ world started for player 1\n        verify(gameEngine,times(1)).startGame(anyInt(),anyInt());\n\n        \/\/ player 2 added to world\n        verify(gameEngine,times(1)).addPlayer2World(anyInt(),anyInt());\n\n        \/\/ start game broadcasted once\n        verify(session, times(2)).getRemote();\n    }\n\n    @Test\n    public void testRunner() throws Exception {\n        ServerEngineImpl.Runner runner = serverEngine.new Runner();\n\n        \/\/ player in world 0\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        player.add(1);\n        serverEngine.getPlayerWorldMap().put(0, player);\n\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n        serverEngine.getPlayerSessionMap().put(1, mock(Session.class));\n\n        \/\/ create broadcaster\n        Broadcaster b = mock(Broadcaster.class);\n        when(b.createWorldEvent(anyInt())).thenReturn(new WorldEventImpl());\n        when(b.getEngine()).thenReturn(gameEngine);\n        runner.setBroadCaster(b);\n\n        \/\/ broadcast\n        runner.run();\n\n        \/\/ world has been broadcast by the runner the players\n        verify(b, times(2)).broadcast(any(Session.class), any(WorldEvent.class));\n    }\n\n}\n","code_block_diff":"{'diff_0': ['\\n    @Test\\n    public void testStartGame(){\\n\\n        serverEngine.startGame(0,0, mock(Session.class));\\n\\n        \/\/ world with player has been created and started to run\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n    }\\n\\n    @Test\\n    public void startGameTwice(){\\n        serverEngine.startGame(0,0, mock(Session.class));\\n        serverEngine.startGame(0,0, mock(Session.class));\\n\\n        \/\/ game only started once\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n    }\\n\\n    @Test\\n', '\\n    @Test\\n    public void testStartGame(){\\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\\n        Session session = mock(Session.class);\\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\\n\\n        serverEngine.startGame(0,0, session);\\n\\n        \/\/ world with player has been created and started to run\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n\\n        \/\/ broadcasted once\\n        verify(session, times(1)).getRemote();\\n    }\\n\\n    @Test\\n    public void startGameTwice(){\\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\\n        Session session = mock(Session.class);\\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\\n\\n\\n        serverEngine.startGame(0,0, session);\\n        serverEngine.startGame(0,0, session);\\n\\n        \/\/ game only started once\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n\\n        verify(session, times(1)).getRemote();\\n    }\\n\\n    @Test\\n']}","subject":"","message":"fixed unit-tests\n\n","lang":"Java","license":"","repos":""}
{"commit":"5b08ffcfac090c4099cb0f1c41f0cc2e337af446","old_file":"nuxeo-core-api\/src\/main\/java\/org\/nuxeo\/ecm\/core\/api\/event\/impl\/CoreEventImpl.java","new_file":"nuxeo-core-api\/src\/main\/java\/org\/nuxeo\/ecm\/core\/api\/event\/impl\/CoreEventImpl.java","old_contents":"\/*\n * (C) Copyright 2006-2007 Nuxeo SAS (http:\/\/nuxeo.com\/) and contributors.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the GNU Lesser General Public License\n * (LGPL) version 2.1 which accompanies this distribution, and is available at\n * http:\/\/www.gnu.org\/licenses\/lgpl.html\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * Contributors:\n *     Nuxeo - initial API and implementation\n *\n * $Id: JOOoConvertPluginImpl.java 18651 2007-05-13 20:28:53Z sfermigier $\n *\/\n\npackage org.nuxeo.ecm.core.api.event.impl;\n\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.nuxeo.ecm.core.api.event.CoreEvent;\n\n\/**\n * Nuxeo core event implementation.\n *\n * @author <a href=\"mailto:ja@nuxeo.com\">Julien Anguenot<\/a>\n * @author <a href=\"mailto:tmartins@nuxeo.com\">Thierry Martins<\/a>\n *\/\npublic class CoreEventImpl implements CoreEvent {\n\n    protected final String eventId;\n\n    protected final Object source;\n\n    protected final Map<String, ?> info;\n\n    protected final Date date;\n\n    protected final Principal principal;\n\n    \/\/ Interesting attributes to make accessible in the eventInfo\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\n\n    public static final String CATEGORY_ATTRIBUTE = \"category\";\n\n    @SuppressWarnings(\"unchecked\")\n    public CoreEventImpl(String eventId, Object source, Map<String, ?> info,\n            Principal principal, String category, String comment) {\n        date = new Date();\n        if (eventId != null) {\n            this.eventId = eventId.intern();\n        } else {\n            this.eventId = null;\n        }\n        this.source = source;\n        if (info == null) {\n            this.info = new HashMap<String, Object>();\n        } else {\n            this.info = new HashMap<String, Object>(info);\n        }\n        this.principal = principal;\n        \/\/ info map contains at least this 2 keys\n        ((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\n        ((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\n    }\n\n    public boolean isComposite() {\n        return false;\n    }\n\n    public List<CoreEvent> getNestedEvents() {\n        return null;\n    }\n\n    public String getEventId() {\n        return eventId;\n    }\n\n    public Map<String, ?> getInfo() {\n        return info;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String getCategory() {\n        return (String) this.info.get(CATEGORY_ATTRIBUTE);\n    }\n\n    public String getComment() {\n        return (String) this.info.get(COMMENT_ATTRIBUTE);\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public Principal getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(CoreEventImpl.class.getSimpleName());\n        buf.append(\" {\");\n        buf.append(\" eventId: \");\n        buf.append(eventId);\n        buf.append(\", source: \");\n        buf.append(source);\n        buf.append(\", info: \");\n        buf.append(info);\n        buf.append(\", date: \");\n        buf.append(date);\n        buf.append(\", principal name: \");\n        if (principal != null) {\n            buf.append(principal.getName());\n        }\n        buf.append(\", comment: \");\n        buf.append(this.info.get(COMMENT_ATTRIBUTE));\n        buf.append(\", category: \");\n        buf.append(this.info.get(CATEGORY_ATTRIBUTE));\n        buf.append('}');\n\n        return buf.toString();\n    }\n\n}\n","new_contents":"\/*\n * (C) Copyright 2006-2007 Nuxeo SAS (http:\/\/nuxeo.com\/) and contributors.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the GNU Lesser General Public License\n * (LGPL) version 2.1 which accompanies this distribution, and is available at\n * http:\/\/www.gnu.org\/licenses\/lgpl.html\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * Contributors:\n *     Nuxeo - initial API and implementation\n *\n * $Id: JOOoConvertPluginImpl.java 18651 2007-05-13 20:28:53Z sfermigier $\n *\/\n\npackage org.nuxeo.ecm.core.api.event.impl;\n\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.nuxeo.ecm.core.api.event.CoreEvent;\n\n\/**\n * Nuxeo core event implementation.\n *\n * @author <a href=\"mailto:ja@nuxeo.com\">Julien Anguenot<\/a>\n * @author <a href=\"mailto:tmartins@nuxeo.com\">Thierry Martins<\/a>\n *\/\npublic class CoreEventImpl implements CoreEvent {\n\n    protected final String eventId;\n\n    protected final Object source;\n\n    protected final Map<String, ?> info;\n\n    protected final Date date;\n\n    protected final Principal principal;\n\n    protected final String category;\n\n    protected final String comment;\n\n    \/\/ Interesting attributes to make accessible in the eventInfo\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\n\n    public static final String CATEGORY_ATTRIBUTE = \"category\";\n\n    @SuppressWarnings(\"unchecked\")\n    public CoreEventImpl(String eventId, Object source, Map<String, ?> info,\n            Principal principal, String category, String comment) {\n        date = new Date();\n        if (eventId != null) {\n            this.eventId = eventId.intern();\n        } else {\n            this.eventId = null;\n        }\n        this.source = source;\n        if (info == null) {\n            this.info = new HashMap<String, Object>();\n        } else {\n            this.info = new HashMap<String, Object>(info);\n        }\n        this.principal = principal;\n\n\t\t\/\/ CB: NXP-2253 - Values passed as parameters will be put into the info\n\t\t\/\/ map only if the map doesn't contain the corresponding keys.\n\t\tif (!((Map) this.info).containsKey(COMMENT_ATTRIBUTE)) {\n\t\t\t((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\n\t\t}\n\t\tif (!((Map) this.info).containsKey(CATEGORY_ATTRIBUTE)) {\n\t\t\t((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\n\t\t}\n\n\t\tthis.comment = comment;\n\t\tthis.category = category;\n    }\n\n    public boolean isComposite() {\n        return false;\n    }\n\n    public List<CoreEvent> getNestedEvents() {\n        return null;\n    }\n\n    public String getEventId() {\n        return eventId;\n    }\n\n    public Map<String, ?> getInfo() {\n        return info;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String getCategory() {\n        if (category != null) {\n            return category;\n        } else {\n            Object categoryObj = this.info.get(CATEGORY_ATTRIBUTE);\n            if (categoryObj instanceof String) {\n                return (String) categoryObj;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public String getComment() {\n        if (comment != null) {\n            return comment;\n        } else {\n            Object commentObj = this.info.get(COMMENT_ATTRIBUTE);\n            if (commentObj instanceof String) {\n                return (String) commentObj;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public Principal getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(CoreEventImpl.class.getSimpleName());\n        buf.append(\" {\");\n        buf.append(\" eventId: \");\n        buf.append(eventId);\n        buf.append(\", source: \");\n        buf.append(source);\n        buf.append(\", info: \");\n        buf.append(info);\n        buf.append(\", date: \");\n        buf.append(date);\n        buf.append(\", principal name: \");\n        if (principal != null) {\n            buf.append(principal.getName());\n        }\n        buf.append(\", comment: \");\n        buf.append(getComment());\n        buf.append(\", category: \");\n        buf.append(getCategory());\n        buf.append('}');\n\n        return buf.toString();\n    }\n\n}\n","code_block_diff":"{'diff_0': ['\\n    protected final Principal principal;\\n\\n    \/\/ Interesting attributes to make accessible in the eventInfo\\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\\n\\n', '\\n    protected final Principal principal;\\n\\n    protected final String category;\\n\\n    protected final String comment;\\n\\n    \/\/ Interesting attributes to make accessible in the eventInfo\\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\\n\\n'], 'diff_1': ['            this.info = new HashMap<String, Object>(info);\\n        }\\n        this.principal = principal;\\n        \/\/ info map contains at least this 2 keys\\n        ((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\\n        ((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\\n    }\\n\\n    public boolean isComposite() {\\n', \"            this.info = new HashMap<String, Object>(info);\\n        }\\n        this.principal = principal;\\n\\n\\t\\t\/\/ CB: NXP-2253 - Values passed as parameters will be put into the info\\n\\t\\t\/\/ map only if the map doesn't contain the corresponding keys.\\n\\t\\tif (!((Map) this.info).containsKey(COMMENT_ATTRIBUTE)) {\\n\\t\\t\\t((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\\n\\t\\t}\\n\\t\\tif (!((Map) this.info).containsKey(CATEGORY_ATTRIBUTE)) {\\n\\t\\t\\t((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\\n\\t\\t}\\n\\n\\t\\tthis.comment = comment;\\n\\t\\tthis.category = category;\\n    }\\n\\n    public boolean isComposite() {\\n\"], 'diff_2': ['    }\\n\\n    public String getCategory() {\\n        return (String) this.info.get(CATEGORY_ATTRIBUTE);\\n    }\\n\\n    public String getComment() {\\n        return (String) this.info.get(COMMENT_ATTRIBUTE);\\n    }\\n\\n    public Date getDate() {\\n', '    }\\n\\n    public String getCategory() {\\n        if (category != null) {\\n            return category;\\n        } else {\\n            Object categoryObj = this.info.get(CATEGORY_ATTRIBUTE);\\n            if (categoryObj instanceof String) {\\n                return (String) categoryObj;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n\\n    public String getComment() {\\n        if (comment != null) {\\n            return comment;\\n        } else {\\n            Object commentObj = this.info.get(COMMENT_ATTRIBUTE);\\n            if (commentObj instanceof String) {\\n                return (String) commentObj;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n\\n    public Date getDate() {\\n'], 'diff_3': ['            buf.append(principal.getName());\\n        }\\n        buf.append(\", comment: \");\\n        buf.append(this.info.get(COMMENT_ATTRIBUTE));\\n        buf.append(\", category: \");\\n        buf.append(this.info.get(CATEGORY_ATTRIBUTE));\\n        buf.append(\\'}\\');\\n\\n        return buf.toString();\\n', '            buf.append(principal.getName());\\n        }\\n        buf.append(\", comment: \");\\n        buf.append(getComment());\\n        buf.append(\", category: \");\\n        buf.append(getCategory());\\n        buf.append(\\'}\\');\\n\\n        return buf.toString();\\n']}","subject":"","message":"NXP-2806: fill log comment with modification comment on edit screen\n\n","lang":"Java","license":"","repos":""}
{"commit":"48c35f837b87759aeec81e9af0ccd424113aa1a5","old_file":"jirm-orm\/src\/main\/java\/co\/jirm\/mapper\/SqlObjectConfig.java","new_file":"jirm-orm\/src\/main\/java\/co\/jirm\/mapper\/SqlObjectConfig.java","old_contents":"\/**\n * Copyright (C) 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage co.jirm.mapper;\n\nimport co.jirm.mapper.converter.DefaultParameterConverter;\nimport co.jirm.mapper.converter.JacksonSqlObjectConverter;\nimport co.jirm.mapper.converter.SqlObjectConverter;\nimport co.jirm.mapper.converter.SqlParameterConverter;\nimport co.jirm.mapper.definition.DefaultNamingStrategy;\nimport co.jirm.mapper.definition.NamingStrategy;\nimport co.jirm.mapper.definition.SqlObjectDefinition;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\n\npublic class SqlObjectConfig {\n\t\n\tprivate final NamingStrategy namingStrategy;\n\tprivate final SqlParameterConverter converter;\n\tprivate final SqlObjectConverter objectMapper;\n\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\n\tprivate final int maximumLoadDepth = 4;\n\t\n\tprivate SqlObjectConfig(\n\t\t\tNamingStrategy namingStrategy, \n\t\t\tSqlObjectConverter objectMapper, \n\t\t\tSqlParameterConverter converter, \n\t\t\tCache<Class<?>, SqlObjectDefinition<?>> cache) {\n\t\tsuper();\n\t\tthis.namingStrategy = namingStrategy;\n\t\tthis.converter = converter;\n\t\tthis.objectMapper = objectMapper;\n\t\tthis.cache = cache;\n\t}\n\t\n\t\n\tpublic NamingStrategy getNamingStrategy() {\n\t\treturn namingStrategy;\n\t}\n\t\n\tpublic SqlParameterConverter getConverter() {\n\t\treturn converter;\n\t}\n\t\n\tpublic SqlObjectConverter getObjectMapper() {\n\t\treturn objectMapper;\n\t}\n\t\n\tpublic <T> SqlObjectDefinition<T> resolveObjectDefinition(Class<T> objectType) {\n\t\treturn SqlObjectDefinition.fromClass(objectType, this);\n\t}\n\t\n\t\n\tpublic int getMaximumLoadDepth() {\n\t\treturn maximumLoadDepth;\n\t}\n\t\n\tpublic Cache<Class<?>, SqlObjectDefinition<?>> getCache() {\n\t\treturn cache;\n\t}\n\t\n\tpublic static SqlObjectConfig DEFAULT = \n\t\t\tnew SqlObjectConfig(DefaultNamingStrategy.INSTANCE,\n\t\t\tnew JacksonSqlObjectConverter(), new DefaultParameterConverter(), \n\t\t\tCacheBuilder.newBuilder()\n\t\t\t.weakKeys()\n\t\t\t.maximumSize(1000)\n\t\t\t.<Class<?>, SqlObjectDefinition<?>>build());\n\n}\n","new_contents":"\/**\n * Copyright (C) 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage co.jirm.mapper;\n\nimport co.jirm.mapper.converter.DefaultParameterConverter;\nimport co.jirm.mapper.converter.JacksonSqlObjectConverter;\nimport co.jirm.mapper.converter.SqlObjectConverter;\nimport co.jirm.mapper.converter.SqlParameterConverter;\nimport co.jirm.mapper.definition.DefaultNamingStrategy;\nimport co.jirm.mapper.definition.NamingStrategy;\nimport co.jirm.mapper.definition.SqlObjectDefinition;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\n\npublic class SqlObjectConfig {\n\t\n\tprivate final NamingStrategy namingStrategy;\n\tprivate final SqlParameterConverter converter;\n\tprivate final SqlObjectConverter objectMapper;\n\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\n\tprivate final int maximumLoadDepth = 4;\n\t\n\tprotected SqlObjectConfig(\n\t\t\tNamingStrategy namingStrategy, \n\t\t\tSqlObjectConverter objectMapper, \n\t\t\tSqlParameterConverter converter, \n\t\t\tCache<Class<?>, SqlObjectDefinition<?>> cache) {\n\t\tsuper();\n\t\tthis.namingStrategy = namingStrategy;\n\t\tthis.converter = converter;\n\t\tthis.objectMapper = objectMapper;\n\t\tthis.cache = cache;\n\t}\n\t\n\t\n\tpublic NamingStrategy getNamingStrategy() {\n\t\treturn namingStrategy;\n\t}\n\t\n\tpublic SqlParameterConverter getConverter() {\n\t\treturn converter;\n\t}\n\t\n\tpublic SqlObjectConverter getObjectMapper() {\n\t\treturn objectMapper;\n\t}\n\t\n\tpublic <T> SqlObjectDefinition<T> resolveObjectDefinition(Class<T> objectType) {\n\t\treturn SqlObjectDefinition.fromClass(objectType, this);\n\t}\n\t\n\t\n\tpublic int getMaximumLoadDepth() {\n\t\treturn maximumLoadDepth;\n\t}\n\t\n\tpublic Cache<Class<?>, SqlObjectDefinition<?>> getCache() {\n\t\treturn cache;\n\t}\n\t\n\tpublic static SqlObjectConfig DEFAULT = \n\t\t\tnew SqlObjectConfig(DefaultNamingStrategy.INSTANCE,\n\t\t\tnew JacksonSqlObjectConverter(), new DefaultParameterConverter(), \n\t\t\tCacheBuilder.newBuilder()\n\t\t\t.weakKeys()\n\t\t\t.maximumSize(1000)\n\t\t\t.<Class<?>, SqlObjectDefinition<?>>build());\n\n}\n","code_block_diff":"{'diff_0': ['\\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\\n\\tprivate final int maximumLoadDepth = 4;\\n\\t\\n\\tprivate SqlObjectConfig(\\n\\t\\t\\tNamingStrategy namingStrategy, \\n\\t\\t\\tSqlObjectConverter objectMapper, \\n\\t\\t\\tSqlParameterConverter converter, \\n', '\\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\\n\\tprivate final int maximumLoadDepth = 4;\\n\\t\\n\\tprotected SqlObjectConfig(\\n\\t\\t\\tNamingStrategy namingStrategy, \\n\\t\\t\\tSqlObjectConverter objectMapper, \\n\\t\\t\\tSqlParameterConverter converter, \\n']}","subject":"","message":"The SqlProjectConfig class' constructor was made to be protected instead of private.\n\n","lang":"Java","license":"","repos":""}
{"commit":"014da6246ef7f224597e4df8c128d38844b312d2","old_file":"dubbo-admin-server\/src\/main\/java\/org\/apache\/dubbo\/admin\/registry\/nacos\/NacosOpenapiUtil.java","new_file":"dubbo-admin-server\/src\/main\/java\/org\/apache\/dubbo\/admin\/registry\/nacos\/NacosOpenapiUtil.java","old_contents":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.dubbo.admin.registry.nacos;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport com.alibaba.fastjson2.JSON;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NacosOpenapiUtil {\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\n        \/\/ 定义Nacos OpenAPI的URL\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\n        if (StringUtils.isNotEmpty(url.getParameter(\"namespace\"))) {\n            nacosUrl = nacosUrl + \"&namespaceId=\" + url.getParameter(\"namespace\");\n        }\n        if (StringUtils.isNotEmpty(url.getParameter(\"group\"))) {\n            nacosUrl = nacosUrl + \"&groupName=\" + url.getParameter(\"group\");\n        }\n\n        \/\/ 创建URL对象\n        java.net.URL netUrl = null;\n        try {\n            netUrl = new java.net.URL(nacosUrl);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        HttpURLConnection connection = null;\n        try {\n\n            \/\/ 创建HTTP连接\n            connection = (HttpURLConnection) netUrl.openConnection();\n\n            \/\/ 设置请求方法(GET或POST)\n            connection.setRequestMethod(\"GET\");\n\n            \/\/ 发送请求并获取响应状态码\n            int responseCode = connection.getResponseCode();\n\n            \/\/ 读取响应内容\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            \/\/ 打印响应结果\n            System.out.println(\"Response Code: \" + responseCode);\n            System.out.println(\"Response Body: \" + response.toString());\n\n            NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\n            return nacosResponse.getSubscribers();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            \/\/ 关闭连接\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n}\n","new_contents":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.dubbo.admin.registry.nacos;\n\nimport org.apache.dubbo.admin.controller.AccessesController;\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport com.alibaba.fastjson2.JSON;\nimport net.bytebuddy.implementation.bytecode.Throw;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NacosOpenapiUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(NacosOpenapiUtil.class);\n\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\n        \/\/ 定义Nacos OpenAPI的URL\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\n        if (StringUtils.isNotEmpty(url.getParameter(\"namespace\"))) {\n            nacosUrl = nacosUrl + \"&namespaceId=\" + url.getParameter(\"namespace\");\n        }\n        if (StringUtils.isNotEmpty(url.getParameter(\"group\"))) {\n            nacosUrl = nacosUrl + \"&groupName=\" + url.getParameter(\"group\");\n        }\n\n        \/\/ 创建URL对象\n        java.net.URL netUrl = null;\n        try {\n            netUrl = new java.net.URL(nacosUrl);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        HttpURLConnection connection = null;\n        try {\n\n            \/\/ 创建HTTP连接\n            connection = (HttpURLConnection) netUrl.openConnection();\n\n            \/\/ 设置请求方法(GET或POST)\n            connection.setRequestMethod(\"GET\");\n\n            \/\/ 发送请求并获取响应状态码\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == 200) {\n                \/\/ 读取响应内容\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Error requesting nacos openapi, \" + nacosUrl, t);\n                }\n\n                NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\n                return nacosResponse.getSubscribers();\n            } else {\n                logger.error(\"Error requesting nacos openapi, \" + nacosUrl + \", error code is \" + responseCode);\n            }\n        } catch (IOException e) {\n            logger.error(\"Error requesting nacos openapi, \" + nacosUrl, e);\n        } finally {\n            \/\/ 关闭连接\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n}\n","code_block_diff":"{'diff_0': [' *\/\\npackage org.apache.dubbo.admin.registry.nacos;\\n\\nimport org.apache.dubbo.common.URL;\\nimport org.apache.dubbo.common.utils.StringUtils;\\n\\nimport com.alibaba.fastjson2.JSON;\\n\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\n', ' *\/\\npackage org.apache.dubbo.admin.registry.nacos;\\n\\nimport org.apache.dubbo.admin.controller.AccessesController;\\nimport org.apache.dubbo.common.URL;\\nimport org.apache.dubbo.common.logger.Logger;\\nimport org.apache.dubbo.common.logger.LoggerFactory;\\nimport org.apache.dubbo.common.utils.StringUtils;\\n\\nimport com.alibaba.fastjson2.JSON;\\nimport net.bytebuddy.implementation.bytecode.Throw;\\n\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\n'], 'diff_1': ['import java.util.List;\\n\\npublic class NacosOpenapiUtil {\\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\\n        \/\/ 定义Nacos OpenAPI的URL\\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\\n', 'import java.util.List;\\n\\npublic class NacosOpenapiUtil {\\n\\n    private static final Logger logger = LoggerFactory.getLogger(NacosOpenapiUtil.class);\\n\\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\\n        \/\/ 定义Nacos OpenAPI的URL\\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\\n'], 'diff_2': ['            \/\/ 发送请求并获取响应状态码\\n            int responseCode = connection.getResponseCode();\\n\\n            \/\/ 读取响应内容\\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\\n            String line;\\n            StringBuilder response = new StringBuilder();\\n            while ((line = reader.readLine()) != null) {\\n                response.append(line);\\n            }\\n            reader.close();\\n\\n            \/\/ 打印响应结果\\n            System.out.println(\"Response Code: \" + responseCode);\\n            System.out.println(\"Response Body: \" + response.toString());\\n\\n            NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\\n            return nacosResponse.getSubscribers();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } finally {\\n            \/\/ 关闭连接\\n            if (connection != null) {\\n', '            \/\/ 发送请求并获取响应状态码\\n            int responseCode = connection.getResponseCode();\\n\\n            if (responseCode == 200) {\\n                \/\/ 读取响应内容\\n                StringBuilder response = new StringBuilder();\\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\\n                    String line;\\n                    while ((line = reader.readLine()) != null) {\\n                        response.append(line);\\n                    }\\n                } catch (Throwable t) {\\n                    logger.error(\"Error requesting nacos openapi, \" + nacosUrl, t);\\n                }\\n\\n                NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\\n                return nacosResponse.getSubscribers();\\n            } else {\\n                logger.error(\"Error requesting nacos openapi, \" + nacosUrl + \", error code is \" + responseCode);\\n            }\\n        } catch (IOException e) {\\n            logger.error(\"Error requesting nacos openapi, \" + nacosUrl, e);\\n        } finally {\\n            \/\/ 关闭连接\\n            if (connection != null) {\\n']}","subject":"","message":"enhance nacos openapi logic (#1227)\n\n\n","lang":"Java","license":"","repos":""}
{"commit":"cfadfbe31ba6c8742ab6fba63e78f34fd25a6a5d","old_file":"neatle\/src\/main\/java\/si\/inova\/neatle\/source\/CalllableInputSource.java","new_file":"neatle\/src\/main\/java\/si\/inova\/neatle\/source\/CalllableInputSource.java","old_contents":"package si.inova.neatle.source;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.concurrent.Callable;\r\n\r\n\/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2017 Inova IT\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\/\r\n\r\n\/**\r\n * A input source that invokes {@link Callable} just before the first chunk is requested.\r\n *\/\r\npublic class CalllableInputSource implements InputSource {\r\n\r\n    private final Callable<ByteBuffer> source;\r\n\r\n    private ByteBuffer byteBuffer;\r\n\r\n    public CalllableInputSource(Callable<ByteBuffer> source) {\r\n        this.source = source;\r\n    }\r\n\r\n    @Override\r\n    public void open() throws IOException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public byte[] nextChunk() throws IOException {\r\n        if (byteBuffer == null) {\r\n            try {\r\n                byteBuffer = source.call();\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Failed to get bytes from callback\");\r\n            }\r\n        }\r\n        if (byteBuffer == null || !byteBuffer.hasRemaining()) {\r\n            return null;\r\n        }\r\n\r\n        int remaining = Math.min(byteBuffer.remaining(), 20);\r\n        byte[] chunk = new byte[remaining];\r\n\r\n        byteBuffer.get(chunk);\r\n        return chunk;\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void close() throws IOException {\r\n        byteBuffer = null;\r\n    }\r\n}\r\n","new_contents":"package si.inova.neatle.source;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.concurrent.Callable;\r\n\r\n\/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2017 Inova IT\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\/\r\n\r\n\/**\r\n * A input source that invokes {@link Callable} just before the first chunk is requested.\r\n *\/\r\npublic class CalllableInputSource implements InputSource {\r\n\r\n    private final Callable<ByteBuffer> source;\r\n\r\n    private ByteBuffer byteBuffer;\r\n\r\n    public CalllableInputSource(Callable<ByteBuffer> source) {\r\n        this.source = source;\r\n    }\r\n\r\n    @Override\r\n    public void open() throws IOException {\r\n        \/\/nothing to do\r\n    }\r\n\r\n    @Override\r\n    public byte[] nextChunk() throws IOException {\r\n        if (byteBuffer == null) {\r\n            try {\r\n                byteBuffer = source.call();\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Failed to get bytes from callback\");\r\n            }\r\n        }\r\n        if (byteBuffer == null || !byteBuffer.hasRemaining()) {\r\n            return null;\r\n        }\r\n\r\n        int remaining = Math.min(byteBuffer.remaining(), 20);\r\n        byte[] chunk = new byte[remaining];\r\n\r\n        byteBuffer.get(chunk);\r\n        return chunk;\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void close() throws IOException {\r\n        byteBuffer = null;\r\n    }\r\n}\r\n","code_block_diff":"{'diff_0': ['\\n    @Override\\n    public void open() throws IOException {\\n\\n    }\\n\\n    @Override\\n', '\\n    @Override\\n    public void open() throws IOException {\\n        \/\/nothing to do\\n    }\\n\\n    @Override\\n']}","subject":"","message":"Codacy: Document empty method body\n\n","lang":"Java","license":"","repos":""}
{"commit":"c3ac4797a4b2d34d031ef5fe07761417a876ffb7","old_file":"core\/src\/main\/java\/com\/nuodb\/migrator\/jdbc\/metadata\/inspector\/MySQLIndexInspector.java","new_file":"core\/src\/main\/java\/com\/nuodb\/migrator\/jdbc\/metadata\/inspector\/MySQLIndexInspector.java","old_contents":"\/**\n * Copyright (c) 2014, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.jdbc.metadata.inspector;\n\nimport static com.google.common.collect.Lists.newArrayList;\nimport static com.nuodb.migrator.jdbc.query.QueryUtils.union;\nimport static com.nuodb.migrator.utils.StringUtils.isEmpty;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.slf4j.Logger;\n\nimport com.nuodb.migrator.jdbc.metadata.Index;\nimport com.nuodb.migrator.jdbc.query.ParameterizedQuery;\nimport com.nuodb.migrator.jdbc.query.Query;\nimport com.nuodb.migrator.jdbc.query.SelectQuery;\nimport com.nuodb.migrator.utils.StringUtils;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class MySQLIndexInspector extends SimpleIndexInspector {\n\n    private static final String PRIMARY = \"PRIMARY\";\n    \n    @Override\n    protected void processIndex(InspectionContext inspectionContext, ResultSet indexes,\n                                Index index) throws SQLException {\n        super.processIndex(inspectionContext, indexes, index);\n        if (StringUtils.equals(index.getName(), PRIMARY)) {\n            index.setPrimary(true);\n        }\n        \/* Extract the Index type from result set. *\/\n        index.setType(indexes.getString(\"INDEX_TYPE\"));\n    }\n\n    \/** \n    * This method is overridden to build a query to fetch information from MySQL \n    * INFORMATION_SCHEMA.STATISTICS and INFORMATION_SCHEMA.COLUMNS tables including \n    * all index types\n    *\/\n    @Override\n    protected Query createQuery(InspectionContext inspectionContext, TableInspectionScope tableInspectionScope) {\n        SelectQuery statisticsIndex = new SelectQuery();\n        Collection<String> parameters = newArrayList();\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\" ,\" C.ORDINAL_POSITION\" , \"S.COLUMN_NAME\" ,\"S.COLLATION AS ASC_OR_DESC\",\n                \"S.CARDINALITY\", \"S.SUB_PART\",\"NULL AS FILTER_CONDITION\");\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\n        String schema = tableInspectionScope.getCatalog();\n        if (!isEmpty(schema)) {\n            statisticsIndex.where(\"S.TABLE_SCHEMA=?\");\n            parameters.add(schema);\n        }\n        String table = tableInspectionScope.getTable();\n        if (!isEmpty(table)) {\n            statisticsIndex.where(\"S.TABLE_NAME=?\");\n            parameters.add(table);\n        }\n         return new ParameterizedQuery(union(statisticsIndex, null), parameters);\n    }\n}\n\n","new_contents":"\/**\n * Copyright (c) 2014, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.jdbc.metadata.inspector;\n\nimport static com.google.common.collect.Lists.newArrayList;\nimport static com.nuodb.migrator.jdbc.query.QueryUtils.union;\nimport static com.nuodb.migrator.utils.StringUtils.isEmpty;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.slf4j.Logger;\n\nimport com.nuodb.migrator.jdbc.metadata.Index;\nimport com.nuodb.migrator.jdbc.query.ParameterizedQuery;\nimport com.nuodb.migrator.jdbc.query.Query;\nimport com.nuodb.migrator.jdbc.query.SelectQuery;\nimport com.nuodb.migrator.utils.StringUtils;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class MySQLIndexInspector extends SimpleIndexInspector {\n\n    private static final String PRIMARY = \"PRIMARY\";\n    \n    @Override\n    protected void processIndex(InspectionContext inspectionContext, ResultSet indexes,\n                                Index index) throws SQLException {\n        super.processIndex(inspectionContext, indexes, index);\n        if (StringUtils.equals(index.getName(), PRIMARY)) {\n            index.setPrimary(true);\n        }\n        \/* Extract the Index type from result set. *\/\n        index.setType(indexes.getString(\"INDEX_TYPE\"));\n    }\n\n    \/** \n    * This method is overridden to build a query to fetch information from MySQL \n    * INFORMATION_SCHEMA.STATISTICS and INFORMATION_SCHEMA.COLUMNS tables including \n    * all index types\n    *\/\n    @Override\n    protected Query createQuery(InspectionContext inspectionContext, TableInspectionScope tableInspectionScope) {\n        SelectQuery statisticsIndex = new SelectQuery();\n        Collection<String> parameters = newArrayList();\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\", \"S.SEQ_IN_INDEX AS ORDINAL_POSITION\", \"S.COLUMN_NAME\", \"S.COLLATION AS ASC_OR_DESC\",\n                \"S.CARDINALITY\", \"S.SUB_PART\", \"NULL AS FILTER_CONDITION\");\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\n        String schema = tableInspectionScope.getCatalog();\n        if (!isEmpty(schema)) {\n            statisticsIndex.where(\"S.TABLE_SCHEMA=?\");\n            parameters.add(schema);\n        }\n        String table = tableInspectionScope.getTable();\n        if (!isEmpty(table)) {\n            statisticsIndex.where(\"S.TABLE_NAME=?\");\n            parameters.add(table);\n        }\n        statisticsIndex.orderBy(\"INDEX_NAME\", \"SEQ_IN_INDEX\");\n        return new ParameterizedQuery(union(statisticsIndex, null), parameters);\n    }\n}\n\n","code_block_diff":"{'diff_0': ['        SelectQuery statisticsIndex = new SelectQuery();\\n        Collection<String> parameters = newArrayList();\\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\" ,\" C.ORDINAL_POSITION\" , \"S.COLUMN_NAME\" ,\"S.COLLATION AS ASC_OR_DESC\",\\n                \"S.CARDINALITY\", \"S.SUB_PART\",\"NULL AS FILTER_CONDITION\");\\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\\n', '        SelectQuery statisticsIndex = new SelectQuery();\\n        Collection<String> parameters = newArrayList();\\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\", \"S.SEQ_IN_INDEX AS ORDINAL_POSITION\", \"S.COLUMN_NAME\", \"S.COLLATION AS ASC_OR_DESC\",\\n                \"S.CARDINALITY\", \"S.SUB_PART\", \"NULL AS FILTER_CONDITION\");\\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\\n'], 'diff_1': ['            statisticsIndex.where(\"S.TABLE_NAME=?\");\\n            parameters.add(table);\\n        }\\n         return new ParameterizedQuery(union(statisticsIndex, null), parameters);\\n    }\\n}\\n\\n', '            statisticsIndex.where(\"S.TABLE_NAME=?\");\\n            parameters.add(table);\\n        }\\n        statisticsIndex.orderBy(\"INDEX_NAME\", \"SEQ_IN_INDEX\");\\n        return new ParameterizedQuery(union(statisticsIndex, null), parameters);\\n    }\\n}\\n\\n']}","subject":"","message":"MIG-138 : migrator created an index from mysql migration with columns that are not in the same order sequence\n\n","lang":"Java","license":"","repos":""}
{"commit":"1f99e9832d7b89dea467e8bd0de13190769d5402","old_file":"core\/src\/test\/java\/com\/nuodb\/migrator\/dump\/DumpJobTest.java","new_file":"core\/src\/test\/java\/com\/nuodb\/migrator\/dump\/DumpJobTest.java","old_contents":"\/**\n * Copyright (c) 2015, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.dump;\n\nimport com.nuodb.migrator.backup.writer.BackupWriter;\nimport com.nuodb.migrator.backup.format.FormatFactory;\nimport com.nuodb.migrator.backup.format.value.ValueFormatRegistryResolver;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProvider;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProviderFactory;\nimport com.nuodb.migrator.jdbc.dialect.Dialect;\nimport com.nuodb.migrator.jdbc.dialect.DialectResolver;\nimport com.nuodb.migrator.jdbc.dialect.NuoDBDialect;\nimport com.nuodb.migrator.jdbc.metadata.Column;\nimport com.nuodb.migrator.jdbc.metadata.Database;\nimport com.nuodb.migrator.jdbc.metadata.DatabaseInfo;\nimport com.nuodb.migrator.jdbc.metadata.Table;\nimport com.nuodb.migrator.jdbc.metadata.inspector.InspectionManager;\nimport com.nuodb.migrator.job.JobExecution;\nimport com.nuodb.migrator.job.JobExecutor;\nimport com.nuodb.migrator.spec.DumpJobSpec;\nimport org.mockito.*;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Types;\nimport java.util.Map;\n\nimport static com.google.common.collect.Maps.newHashMap;\nimport static com.nuodb.migrator.jdbc.metadata.Identifier.EMPTY;\nimport static com.nuodb.migrator.job.JobExecutors.createJobExecutor;\nimport static org.mockito.BDDMockito.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNull;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class DumpJobTest {\n\n    @Mock\n    private InspectionManager inspectionManager;\n    @Mock\n    private ConnectionProvider connectionProvider;\n    @Mock\n    private ConnectionProviderFactory connectionProviderFactory;\n    @Mock\n    private DialectResolver dialectResolver;\n    @Mock\n    private FormatFactory formatFactory;\n    @Mock\n    private ValueFormatRegistryResolver valueFormatRegistryResolver;\n    @Mock\n    private Dialect dialect;\n    @Mock\n    private Connection connection;\n\n\n    private JobExecutor jobExecutor;\n    private Map<Object, Object> jobContext;\n\n    @Spy\n    @InjectMocks\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\n\/\/    @Spy\n\/\/    @InjectMocks\n\/\/    private BackupWriter backupWriter = new BackupWriter();\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        DatabaseMetaData databaseMetaData = mock(DatabaseMetaData.class);\n        given(databaseMetaData.getDatabaseProductName()).willReturn(\"NuoDB\");\n        given(connection.getMetaData()).willReturn(databaseMetaData);\n\n        willDoNothing().given(dumpJob).init();\n        willDoNothing().given(dumpJob).execute();\n\n        jobContext = newHashMap();\n        jobExecutor = createJobExecutor(dumpJob);\n    }\n\n    @Test\n    public void validateConnectionProvider() throws Exception {\n        dumpJob.setConnectionProviderFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateDialectResolver() throws Exception {\n        dumpJob.setDialectResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateValueFormatRegistryResolver() throws Exception {\n        dumpJob.setValueFormatRegistryResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateFormatFactory() throws Exception {\n        dumpJob.setFormatFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    private void verifyInit() throws Exception {\n        assertNull(jobExecutor.getJobStatus().getFailure());\n        verify(dumpJob).init(any(JobExecution.class));\n        verify(dumpJob, times(1)).execute();\n    }\n\n    @Test\n    public void testExecuteInSession() throws Throwable {\n        Database database = new Database();\n        database.setDialect(new NuoDBDialect(new DatabaseInfo(\"NuoDB\")));\n\n        Table table = database.addCatalog(EMPTY).addSchema(\"schema\").addTable(\"table\");\n        Column column1 = table.addColumn(\"column1\");\n        column1.setTypeCode(Types.BIGINT);\n        Column column2 = table.addColumn(\"column2\");\n        column2.setTypeCode(Types.LONGVARCHAR);\n\n        BackupWriter backupWriter = Mockito.mock(BackupWriter.class);\n        willReturn(backupWriter).given(dumpJob).getBackupWriter();\n\n        jobExecutor.execute(jobContext);\n\n        Throwable failure = jobExecutor.getJobStatus().getFailure();\n        if (failure != null) {\n            throw failure;\n        }\n    }\n}\n","new_contents":"\/**\n * Copyright (c) 2015, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.dump;\n\nimport com.nuodb.migrator.backup.writer.BackupWriter;\nimport com.nuodb.migrator.backup.format.FormatFactory;\nimport com.nuodb.migrator.backup.format.value.ValueFormatRegistryResolver;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProvider;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProviderFactory;\nimport com.nuodb.migrator.jdbc.dialect.Dialect;\nimport com.nuodb.migrator.jdbc.dialect.DialectResolver;\nimport com.nuodb.migrator.jdbc.dialect.NuoDBDialect;\nimport com.nuodb.migrator.jdbc.metadata.Column;\nimport com.nuodb.migrator.jdbc.metadata.Database;\nimport com.nuodb.migrator.jdbc.metadata.DatabaseInfo;\nimport com.nuodb.migrator.jdbc.metadata.Table;\nimport com.nuodb.migrator.jdbc.metadata.inspector.InspectionManager;\nimport com.nuodb.migrator.job.JobExecution;\nimport com.nuodb.migrator.job.JobExecutor;\nimport com.nuodb.migrator.spec.DumpJobSpec;\nimport org.mockito.*;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Types;\nimport java.util.Map;\n\nimport static com.google.common.collect.Maps.newHashMap;\nimport static com.nuodb.migrator.jdbc.metadata.Identifier.EMPTY;\nimport static com.nuodb.migrator.job.JobExecutors.createJobExecutor;\nimport static org.mockito.BDDMockito.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNull;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class DumpJobTest {\n\n    @Mock\n    private InspectionManager inspectionManager;\n    @Mock\n    private ConnectionProvider connectionProvider;\n    @Mock\n    private ConnectionProviderFactory connectionProviderFactory;\n    @Mock\n    private DialectResolver dialectResolver;\n    @Mock\n    private FormatFactory formatFactory;\n    @Mock\n    private ValueFormatRegistryResolver valueFormatRegistryResolver;\n    @Mock\n    private Dialect dialect;\n    @Mock\n    private Connection connection;\n    @Spy\n    @InjectMocks\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\n\n\n    private JobExecutor jobExecutor;\n    private Map<Object, Object> jobContext;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        DatabaseMetaData databaseMetaData = mock(DatabaseMetaData.class);\n        given(databaseMetaData.getDatabaseProductName()).willReturn(\"NuoDB\");\n        given(connection.getMetaData()).willReturn(databaseMetaData);\n\n        willDoNothing().given(dumpJob).init();\n        willDoNothing().given(dumpJob).execute();\n\n        jobContext = newHashMap();\n        jobExecutor = createJobExecutor(dumpJob);\n    }\n\n    @Test\n    public void validateConnectionProvider() throws Exception {\n        dumpJob.setConnectionProviderFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateDialectResolver() throws Exception {\n        dumpJob.setDialectResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateValueFormatRegistryResolver() throws Exception {\n        dumpJob.setValueFormatRegistryResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateFormatFactory() throws Exception {\n        dumpJob.setFormatFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    private void verifyInit() throws Exception {\n        assertNull(jobExecutor.getJobStatus().getFailure());\n        verify(dumpJob).init(any(JobExecution.class));\n        verify(dumpJob, times(1)).execute();\n    }\n\n    @Test\n    public void testExecuteInSession() throws Throwable {\n        Database database = new Database();\n        database.setDialect(new NuoDBDialect(new DatabaseInfo(\"NuoDB\")));\n\n        Table table = database.addCatalog(EMPTY).addSchema(\"schema\").addTable(\"table\");\n        Column column1 = table.addColumn(\"column1\");\n        column1.setTypeCode(Types.BIGINT);\n        Column column2 = table.addColumn(\"column2\");\n        column2.setTypeCode(Types.LONGVARCHAR);\n\n        BackupWriter backupWriter = Mockito.mock(BackupWriter.class);\n        willReturn(backupWriter).given(dumpJob).getBackupWriter();\n\n        jobExecutor.execute(jobContext);\n\n        Throwable failure = jobExecutor.getJobStatus().getFailure();\n        if (failure != null) {\n            throw failure;\n        }\n    }\n}\n","code_block_diff":"{'diff_0': ['    private Dialect dialect;\\n    @Mock\\n    private Connection connection;\\n\\n\\n    private JobExecutor jobExecutor;\\n    private Map<Object, Object> jobContext;\\n\\n    @Spy\\n    @InjectMocks\\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\\n\/\/    @Spy\\n\/\/    @InjectMocks\\n\/\/    private BackupWriter backupWriter = new BackupWriter();\\n\\n    @BeforeMethod\\n    public void setUp() throws Exception {\\n        MockitoAnnotations.initMocks(this);\\n', '    private Dialect dialect;\\n    @Mock\\n    private Connection connection;\\n    @Spy\\n    @InjectMocks\\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\\n\\n\\n    private JobExecutor jobExecutor;\\n    private Map<Object, Object> jobContext;\\n\\n    @BeforeMethod\\n    public void setUp() throws Exception {\\n        MockitoAnnotations.initMocks(this);\\n']}","subject":"","message":"Removing dead code\n\n","lang":"Java","license":"","repos":""}
{"commit":"f44c64291e9705a867e7869dd0f1b71e9f896360","old_file":"anno4j-core\/src\/test\/java\/com\/github\/anno4j\/example\/ExampleTest.java","new_file":"anno4j-core\/src\/test\/java\/com\/github\/anno4j\/example\/ExampleTest.java","old_contents":"package com.github.anno4j.example;\n\nimport com.github.anno4j.Anno4j;\nimport com.github.anno4j.model.Annotation;\nimport com.github.anno4j.model.MotivationFactory;\nimport com.github.anno4j.model.impl.ResourceObject;\nimport com.github.anno4j.model.impl.agent.Person;\nimport com.github.anno4j.model.impl.agent.Software;\nimport com.github.anno4j.model.impl.selector.TextPositionSelector;\nimport com.github.anno4j.model.impl.targets.SpecificResource;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openrdf.repository.object.ObjectConnection;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Test case to implement the example annotation at {@link }http:\/\/www.w3.org\/TR\/2014\/WD-annotation-model-20141211\/#complete-example}.\n *\/\npublic class ExampleTest {\n\n    private Anno4j anno4j;\n\n    @Before\n    public void setUp() throws Exception {\n        this.anno4j = new Anno4j();\n    }\n    \n\n    @Test\n    public void exampleTest() throws Exception {\n\n        \/\/ Create the base annotation\n        Annotation annotation = anno4j.createObject(Annotation.class);\n        annotation.setAnnotatedAt(\"2014-09-28T12:00:00Z\");\n        annotation.setSerializedAt(\"2013-02-04T12:00:00Z\");\n        annotation.setMotivatedBy(MotivationFactory.getCommenting(anno4j));\n\n\n        \/\/ Create the person agent for the annotation\n        Person person = anno4j.createObject(Person.class);\n        person.setName(\"A. Person\");\n        person.setOpenID(\"http:\/\/example.org\/agent1\/openID1\");\n\n        annotation.setAnnotatedBy(person);\n\n        \/\/ Create the software agent for the annotation\n        Software software = anno4j.createObject(Software.class);\n        software.setName(\"Code v2.1\");\n        software.setHomepage(\"http:\/\/example.org\/agent2\/homepage1\");\n\n        annotation.setSerializedBy(software);\n        \/\/ Create the body\n        TextAnnotationBody body = anno4j.createObject(TextAnnotationBody.class);\n        body.setFormat(\"text\/plain\");\n        body.setValue(\"One of my favourite cities\");\n        body.setLanguage(\"en\");\n        annotation.setBody(body);\n\n        \/\/ Create the selector\n        SpecificResource specificResource = anno4j.createObject(SpecificResource.class);\n\n        TextPositionSelector textPositionSelector = anno4j.createObject(TextPositionSelector.class);\n        textPositionSelector.setStart(4096);\n        textPositionSelector.setEnd(4104);\n\n        specificResource.setSelector(textPositionSelector);\n\n        \/\/ Create the actual target\n        ResourceObject source = anno4j.createObject(ResourceObject.class);\n        source.setResourceAsString(\"http:\/\/example.org\/source1\");\n        specificResource.setSource(source);\n\n        annotation.addTarget(specificResource);\n\n        \/\/ Query persisted object\n        List<Annotation> result = anno4j.findAll(Annotation.class);\n\n        assertEquals(1, result.size());\n\n        Annotation resultObject = result.get(0);\n\n        assertEquals(annotation.getResource(), resultObject.getResource());\n    }\n}\n","new_contents":"package com.github.anno4j.example;\n\nimport com.github.anno4j.Anno4j;\nimport com.github.anno4j.model.Annotation;\nimport com.github.anno4j.model.MotivationFactory;\nimport com.github.anno4j.model.impl.ResourceObject;\nimport com.github.anno4j.model.impl.agent.Person;\nimport com.github.anno4j.model.impl.agent.Software;\nimport com.github.anno4j.model.impl.selector.TextPositionSelector;\nimport com.github.anno4j.model.impl.targets.SpecificResource;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openrdf.repository.object.ObjectConnection;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Test case to implement the example annotation at {@link }http:\/\/www.w3.org\/TR\/2014\/WD-annotation-model-20141211\/#complete-example}.\n *\/\npublic class ExampleTest {\n\n    private Anno4j anno4j;\n\n    @Before\n    public void setUp() throws Exception {\n        this.anno4j = new Anno4j();\n    }\n\n    @Test\n    public void exampleTest() throws Exception {\n\n        \/\/ Create the base annotation\n        Annotation annotation = anno4j.createObject(Annotation.class);\n        annotation.setAnnotatedAt(\"2014-09-28T12:00:00Z\");\n        annotation.setSerializedAt(\"2013-02-04T12:00:00Z\");\n        annotation.setMotivatedBy(MotivationFactory.getCommenting(anno4j));\n\n\n        \/\/ Create the person agent for the annotation\n        Person person = anno4j.createObject(Person.class);\n        person.setName(\"A. Person\");\n        person.setOpenID(\"http:\/\/example.org\/agent1\/openID1\");\n\n        annotation.setAnnotatedBy(person);\n\n        \/\/ Create the software agent for the annotation\n        Software software = anno4j.createObject(Software.class);\n        software.setName(\"Code v2.1\");\n        software.setHomepage(\"http:\/\/example.org\/agent2\/homepage1\");\n\n        annotation.setSerializedBy(software);\n        \/\/ Create the body\n        TextAnnotationBody body = anno4j.createObject(TextAnnotationBody.class);\n        body.setFormat(\"text\/plain\");\n        body.setValue(\"One of my favourite cities\");\n        body.setLanguage(\"en\");\n        annotation.setBody(body);\n\n        \/\/ Create the selector\n        SpecificResource specificResource = anno4j.createObject(SpecificResource.class);\n\n        TextPositionSelector textPositionSelector = anno4j.createObject(TextPositionSelector.class);\n        textPositionSelector.setStart(4096);\n        textPositionSelector.setEnd(4104);\n\n        specificResource.setSelector(textPositionSelector);\n\n        \/\/ Create the actual target\n        ResourceObject source = anno4j.createObject(ResourceObject.class);\n        source.setResourceAsString(\"http:\/\/example.org\/source1\");\n        specificResource.setSource(source);\n\n        annotation.addTarget(specificResource);\n\n        \/\/ Query persisted object\n        List<Annotation> result = anno4j.findAll(Annotation.class);\n\n        assertEquals(1, result.size());\n\n        Annotation resultObject = result.get(0);\n\n        assertEquals(annotation.getResource(), resultObject.getResource());\n    }\n}\n","code_block_diff":"{'diff_0': ['    public void setUp() throws Exception {\\n        this.anno4j = new Anno4j();\\n    }\\n    \\n\\n    @Test\\n    public void exampleTest() throws Exception {\\n', '    public void setUp() throws Exception {\\n        this.anno4j = new Anno4j();\\n    }\\n\\n    @Test\\n    public void exampleTest() throws Exception {\\n']}","subject":"","message":"Revert \"banane\"\n\nThis reverts commit 211901c4374192d810be0c09c6da9cd5de81fb04.\n\n","lang":"Java","license":"","repos":""}
{"commit":"0bd96520c7db5f77f3ff0d6690e50a6c8ddbf9e4","old_file":"jobqueue\/src\/main\/java\/com\/birbit\/android\/jobqueue\/scheduling\/FrameworkScheduler.java","new_file":"jobqueue\/src\/main\/java\/com\/birbit\/android\/jobqueue\/scheduling\/FrameworkScheduler.java","old_contents":"package com.birbit.android.jobqueue.scheduling;\n\nimport android.annotation.TargetApi;\nimport android.app.job.JobInfo;\nimport android.app.job.JobParameters;\nimport android.app.job.JobScheduler;\nimport android.app.job.JobService;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PersistableBundle;\nimport android.support.annotation.Nullable;\n\nimport com.birbit.android.jobqueue.log.JqLog;\nimport com.birbit.android.jobqueue.network.NetworkUtil;\n\nimport java.util.UUID;\n\n\/**\n * Scheduler implementation that uses the frameworks' scheduler API.\n *\/\n@TargetApi(21)\nclass FrameworkScheduler extends Scheduler {\n    private static final String KEY_UUID = \"uuid\";\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_DELAY = \"delay\";\n    private static final String KEY_NETWORK_STATUS = \"networkStatus\";\n\n    private JobScheduler jobScheduler;\n    private static SharedPreferences preferences;\n    private ComponentName componentName;\n    \/\/ set when service invokes, cleared when service dies\n    @Nullable private JobService jobService;\n    private final Class<? extends FrameworkJobSchedulerService> serviceImpl;\n\n    FrameworkScheduler(Class<? extends FrameworkJobSchedulerService> serviceImpl) {\n        this.serviceImpl = serviceImpl;\n    }\n\n    void setJobService(@Nullable JobService jobService) {\n        this.jobService = jobService;\n    }\n\n    private static SharedPreferences getPreferences(Context context) {\n        synchronized (FrameworkScheduler.class) {\n            if (preferences == null) {\n                preferences = context.getSharedPreferences(\"jobqueue_fw_scheduler\",\n                        Context.MODE_PRIVATE);\n            }\n            return preferences;\n        }\n    }\n\n    private ComponentName getComponentName() {\n        if (componentName == null) {\n            componentName = new ComponentName(getApplicationContext().getPackageName(),\n                    serviceImpl.getCanonicalName());\n        }\n        return componentName;\n    }\n\n    \/**\n     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not\n     * to conflict with the rest of your application.\n     *\n     * @return A unique integer id for the next Job request to be sent to system scheduler\n     *\/\n    private int createId() {\n        synchronized (FrameworkScheduler.class) {\n            final SharedPreferences preferences = getPreferences(getApplicationContext());\n            final int id = preferences.getInt(KEY_ID, 0) + 1;\n            preferences.edit().putInt(KEY_ID, id).commit();\n            return id;\n        }\n    }\n\n    private JobScheduler getJobScheduler() {\n        if (jobScheduler == null) {\n            jobScheduler = (JobScheduler) getApplicationContext()\n                    .getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        }\n        return jobScheduler;\n    }\n\n    @Override\n    public void request(SchedulerConstraint constraint) {\n        JobScheduler jobScheduler = getJobScheduler();\n\n        final int id = createId();\n        JobInfo.Builder builder = new JobInfo.Builder(id, getComponentName())\n                .setExtras(toPersistentBundle(constraint))\n                .setPersisted(true);\n        switch (constraint.getNetworkStatus()) {\n            case NetworkUtil.UNMETERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n                break;\n            case NetworkUtil.METERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);\n                break;\n            default:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE);\n                builder.setRequiresDeviceIdle(true);\n                break;\n        }\n        if (constraint.getOverrideDeadlineInMs() != null) {\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\n        }\n        int scheduled = jobScheduler.schedule(builder.build());\n        JqLog.d(\"[FW Scheduler] scheduled a framework job. Success? %s id: %d\" +\n                \" created id: %d\", scheduled > 0, scheduled, id);\n    }\n\n    @Override\n    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] on finished job %s. reschedule:%s\", constraint, reschedule);\n        }\n        JobService service = this.jobService;\n        if (service == null) {\n            JqLog.e(\"[FW Scheduler] scheduler onfinished is called but i don't have a job service\");\n            return;\n        }\n\n        Object data = constraint.getData();\n        if (data instanceof JobParameters) {\n            JobParameters params = (JobParameters) data;\n            service.jobFinished(params, reschedule);\n        } else {\n            JqLog.e(\"[FW Scheduler] cannot obtain the job parameters\");\n        }\n\n    }\n\n    @Override\n    public void cancelAll() {\n        JqLog.d(\"[FW Scheduler] cancel all\");\n        getJobScheduler().cancelAll();\n    }\n\n    private static PersistableBundle toPersistentBundle(SchedulerConstraint constraint) {\n        PersistableBundle bundle = new PersistableBundle();\n        \/\/ put boolean is api 22\n        bundle.putString(KEY_UUID, constraint.getUuid());\n        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());\n        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());\n        return bundle;\n    }\n\n    private static SchedulerConstraint fromBundle(PersistableBundle bundle) {\n        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));\n        if (constraint.getUuid() == null) {\n            \/\/ backward compatibility\n            constraint.setUuid(UUID.randomUUID().toString());\n        }\n        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));\n        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));\n        return constraint;\n    }\n\n    boolean onStartJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] start job %s %d\", constraint, params.getJobId());\n        }\n        constraint.setData(params);\n        return start(constraint);\n    }\n\n    boolean onStopJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        return stop(constraint);\n    }\n}\n","new_contents":"package com.birbit.android.jobqueue.scheduling;\n\nimport android.annotation.TargetApi;\nimport android.app.job.JobInfo;\nimport android.app.job.JobParameters;\nimport android.app.job.JobScheduler;\nimport android.app.job.JobService;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PersistableBundle;\nimport android.support.annotation.Nullable;\n\nimport com.birbit.android.jobqueue.log.JqLog;\nimport com.birbit.android.jobqueue.network.NetworkUtil;\n\nimport java.util.UUID;\n\n\/**\n * Scheduler implementation that uses the frameworks' scheduler API.\n *\/\n@TargetApi(21)\nclass FrameworkScheduler extends Scheduler {\n    private static final String KEY_UUID = \"uuid\";\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_DELAY = \"delay\";\n    private static final String KEY_NETWORK_STATUS = \"networkStatus\";\n\n    private JobScheduler jobScheduler;\n    private static SharedPreferences preferences;\n    private ComponentName componentName;\n    \/\/ set when service invokes, cleared when service dies\n    @Nullable private JobService jobService;\n    private final Class<? extends FrameworkJobSchedulerService> serviceImpl;\n\n    FrameworkScheduler(Class<? extends FrameworkJobSchedulerService> serviceImpl) {\n        this.serviceImpl = serviceImpl;\n    }\n\n    void setJobService(@Nullable JobService jobService) {\n        this.jobService = jobService;\n    }\n\n    private static SharedPreferences getPreferences(Context context) {\n        synchronized (FrameworkScheduler.class) {\n            if (preferences == null) {\n                preferences = context.getSharedPreferences(\"jobqueue_fw_scheduler\",\n                        Context.MODE_PRIVATE);\n            }\n            return preferences;\n        }\n    }\n\n    private ComponentName getComponentName() {\n        if (componentName == null) {\n            componentName = new ComponentName(getApplicationContext().getPackageName(),\n                    serviceImpl.getCanonicalName());\n        }\n        return componentName;\n    }\n\n    \/**\n     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not\n     * to conflict with the rest of your application.\n     *\n     * @return A unique integer id for the next Job request to be sent to system scheduler\n     *\/\n    private int createId() {\n        synchronized (FrameworkScheduler.class) {\n            final SharedPreferences preferences = getPreferences(getApplicationContext());\n            final int id = preferences.getInt(KEY_ID, 0) + 1;\n            preferences.edit().putInt(KEY_ID, id).commit();\n            return id;\n        }\n    }\n\n    private JobScheduler getJobScheduler() {\n        if (jobScheduler == null) {\n            jobScheduler = (JobScheduler) getApplicationContext()\n                    .getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        }\n        return jobScheduler;\n    }\n\n    @Override\n    public void request(SchedulerConstraint constraint) {\n        JobScheduler jobScheduler = getJobScheduler();\n\n        final int id = createId();\n        JobInfo.Builder builder = new JobInfo.Builder(id, getComponentName())\n                .setExtras(toPersistentBundle(constraint))\n                .setPersisted(true);\n        switch (constraint.getNetworkStatus()) {\n            case NetworkUtil.UNMETERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n                break;\n            case NetworkUtil.METERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);\n                break;\n            default:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE);\n                builder.setRequiresDeviceIdle(true);\n                break;\n        }\n        if (constraint.getDelayInMs() > 0) {\n            builder.setMinimumLatency(constraint.getDelayInMs());\n        }\n        if (constraint.getOverrideDeadlineInMs() != null) {\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\n        }\n        int scheduled = jobScheduler.schedule(builder.build());\n        JqLog.d(\"[FW Scheduler] scheduled a framework job. Success? %s id: %d\" +\n                \" created id: %d\", scheduled > 0, scheduled, id);\n    }\n\n    @Override\n    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] on finished job %s. reschedule:%s\", constraint, reschedule);\n        }\n        JobService service = this.jobService;\n        if (service == null) {\n            JqLog.e(\"[FW Scheduler] scheduler onfinished is called but i don't have a job service\");\n            return;\n        }\n\n        Object data = constraint.getData();\n        if (data instanceof JobParameters) {\n            JobParameters params = (JobParameters) data;\n            service.jobFinished(params, reschedule);\n        } else {\n            JqLog.e(\"[FW Scheduler] cannot obtain the job parameters\");\n        }\n\n    }\n\n    @Override\n    public void cancelAll() {\n        JqLog.d(\"[FW Scheduler] cancel all\");\n        getJobScheduler().cancelAll();\n    }\n\n    private static PersistableBundle toPersistentBundle(SchedulerConstraint constraint) {\n        PersistableBundle bundle = new PersistableBundle();\n        \/\/ put boolean is api 22\n        bundle.putString(KEY_UUID, constraint.getUuid());\n        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());\n        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());\n        return bundle;\n    }\n\n    private static SchedulerConstraint fromBundle(PersistableBundle bundle) {\n        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));\n        if (constraint.getUuid() == null) {\n            \/\/ backward compatibility\n            constraint.setUuid(UUID.randomUUID().toString());\n        }\n        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));\n        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));\n        return constraint;\n    }\n\n    boolean onStartJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] start job %s %d\", constraint, params.getJobId());\n        }\n        constraint.setData(params);\n        return start(constraint);\n    }\n\n    boolean onStopJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        return stop(constraint);\n    }\n}\n","code_block_diff":"{'diff_0': ['                builder.setRequiresDeviceIdle(true);\\n                break;\\n        }\\n        if (constraint.getOverrideDeadlineInMs() != null) {\\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\\n        }\\n', '                builder.setRequiresDeviceIdle(true);\\n                break;\\n        }\\n        if (constraint.getDelayInMs() > 0) {\\n            builder.setMinimumLatency(constraint.getDelayInMs());\\n        }\\n        if (constraint.getOverrideDeadlineInMs() != null) {\\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\\n        }\\n']}","subject":"","message":"pass correct delay to the scheduler #187\n\n","lang":"Java","license":"","repos":""}
{"commit":"0b747b4d1c4194a25a0f89957f582b3fef0c8651","old_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","new_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","old_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","new_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  public ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","code_block_diff":"{'diff_0': ['    super(builder);\\n  }\\n\\n  ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n', '    super(builder);\\n  }\\n\\n  public ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n']}","subject":"","message":"Add public visibility to ProviderList.entries()\n\n","lang":"Java","license":"","repos":""}
{"commit":"0b747b4d1c4194a25a0f89957f582b3fef0c8651","old_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","new_file":"reactive_cache\/src\/main\/java\/io\/reactivecache2\/ProviderList.java","old_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","new_contents":"\/*\n * Copyright 2017 Victor Albertos\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage io.reactivecache2;\n\nimport io.rx_cache2.internal.ProcessorProviders;\nimport java.util.List;\n\npublic final class ProviderList<T> extends Provider<List<T>> {\n  ProviderList(ProviderBuilder<List<T>> builder) {\n    super(builder);\n  }\n\n  public ActionsList<T> entries() {\n    return ActionsList.with(elements -> elements.compose(replace()),\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\n  }\n\n  public static class ProviderBuilderList<T> extends ProviderBuilder<List<T>> {\n    ProviderBuilderList(ProcessorProviders processorProviders) {\n      super(processorProviders);\n    }\n\n    @Override public <R extends Provider<List<T>>> R withKey(Object key) {\n      this.key = key.toString();\n      return (R) new ProviderList<>(this);\n    }\n  }\n}\n","code_block_diff":"{'diff_0': ['    super(builder);\\n  }\\n\\n  ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n', '    super(builder);\\n  }\\n\\n  public ActionsList<T> entries() {\\n    return ActionsList.with(elements -> elements.compose(replace()),\\n        read().onErrorResumeNext(exceptionAdapter::emptyListIfRxCacheException));\\n  }\\n']}","subject":"","message":"Add public visibility to ProviderList.entries()\n\n","lang":"Java","license":"","repos":""}
{"commit":"fd7ebab7f293fe63aef55565969187a02a56d799","old_file":"src\/modules\/rest\/impl\/src\/test\/java\/it\/geosolutions\/geostore\/rest\/security\/GeoStoreLdapAuthoritiesPopulatorTest.java","new_file":"src\/modules\/rest\/impl\/src\/test\/java\/it\/geosolutions\/geostore\/rest\/security\/GeoStoreLdapAuthoritiesPopulatorTest.java","old_contents":"package it.geosolutions.geostore.rest.security;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.junit.Test;\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.security.core.GrantedAuthority;\nimport it.geosolutions.geostore.core.ldap.IterableNamingEnumeration;\nimport it.geosolutions.geostore.core.ldap.MockContextSource;\nimport it.geosolutions.geostore.services.rest.security.GeoStoreLdapAuthoritiesPopulator;\n\npublic class GeoStoreLdapAuthoritiesPopulatorTest {\n    \n    DirContext ctx = new DirContextAdapter() {\n        @Override\n        public NamingEnumeration<SearchResult> search(String name, String filter, SearchControls cons)\n                throws NamingException {\n            if (\"ou=groups\".equals(name)) {\n                if(\"(member=uid=bill,ou=people)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=group1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=parentgroup1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"parentgroup1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                }\n            }\n            return new IterableNamingEnumeration(Collections.EMPTY_LIST);\n        }\n        \n    };\n    \n    @Test\n    public void testNestedGroupsEnabled() {\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(2, authorities.size());\n    }\n    \n    @Test\n    public void testNestedGroupsDisabled() {\n        \n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(1, authorities.size());\n    }\n}\n","new_contents":"package it.geosolutions.geostore.rest.security;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport javax.naming.Name;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport it.geosolutions.geostore.core.security.SimpleGrantedAuthoritiesMapper;\nimport org.junit.Test;\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.security.core.GrantedAuthority;\nimport it.geosolutions.geostore.core.ldap.IterableNamingEnumeration;\nimport it.geosolutions.geostore.core.ldap.MockContextSource;\nimport it.geosolutions.geostore.services.rest.security.GeoStoreLdapAuthoritiesPopulator;\n\npublic class GeoStoreLdapAuthoritiesPopulatorTest {\n    \n    DirContext ctx = new DirContextAdapter() {\n        @Override\n        public NamingEnumeration<SearchResult> search(String name, String filter, SearchControls cons)\n                throws NamingException {\n            if (\"ou=groups\".equals(name)) {\n                if(\"(member=uid=bill,ou=people)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=group1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n\n                    SearchResult sr2 = new SearchResult(\"cn=group2\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=group2,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"group2\";\n                            }\n                            return \"\";\n                        }\n\n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Arrays.asList(sr, sr2));\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\n\n                        @Override\n                        public String getNameInNamespace() {\n                            return \"cn=parentgroup1,ou=groups\";\n                        }\n\n                        @Override\n                        public String getStringAttribute(String name) {\n                            if (\"cn\".equals(name)) {\n                                return \"parentgroup1\";\n                            }\n                            return \"\";\n                        }\n                        \n                    }, new BasicAttributes());\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\n                }\n            }\n            return new IterableNamingEnumeration(Collections.EMPTY_LIST);\n        }\n        \n    };\n    \n    @Test\n    public void testNestedGroupsEnabled() {\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(3, authorities.size());\n    }\n    \n    @Test\n    public void testNestedGroupsDisabled() {\n        \n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator = \n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(2, authorities.size());\n    }\n\n    @Test\n    public void testDropUnmappedRoles() {\n\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=groups\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Map<String,String>  mappings=new HashMap<>();\n        mappings.put(\"ROLE_GROUP2\",\"ROLE_ADMIN\");\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\n        mapper.setDropUnmapped(true);\n        authoritiesPopulator.setRoleMapper(mapper);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        List<String> expected=Arrays.asList(\"ROLE_ADMIN\",\"GROUP1\",\"GROUP2\");\n        List<String> stringAuthorities=authorities.stream().map(a->a.getAuthority()).collect(Collectors.toList());\n        assertEquals(expected.size(), stringAuthorities.size());\n        assertTrue(stringAuthorities.containsAll(expected));\n    }\n\n\n    @Test\n    public void testDropUnmappedGroups() {\n\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\n        Map<String,String>  mappings=new HashMap<>();\n        mappings.put(\"GROUP2\",\"MAPPED_GROUP\");\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\n        mapper.setDropUnmapped(true);\n        authoritiesPopulator.setGroupMapper(mapper);\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\n        assertEquals(1, authorities.size());\n        assertEquals(\"MAPPED_GROUP\",authorities.iterator().next().getAuthority());\n    }\n}\n","code_block_diff":"{'diff_0': ['package it.geosolutions.geostore.rest.security;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nimport javax.naming.Name;\\nimport javax.naming.NamingEnumeration;\\n', 'package it.geosolutions.geostore.rest.security;\\n\\nimport static org.junit.Assert.assertEquals;\\nimport static org.junit.Assert.assertTrue;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.stream.Collectors;\\n\\nimport javax.naming.Name;\\nimport javax.naming.NamingEnumeration;\\n'], 'diff_1': ['import javax.naming.directory.SearchControls;\\nimport javax.naming.directory.SearchResult;\\n\\nimport org.junit.Test;\\nimport org.springframework.ldap.core.DirContextAdapter;\\nimport org.springframework.security.core.GrantedAuthority;\\n', 'import javax.naming.directory.SearchControls;\\nimport javax.naming.directory.SearchResult;\\n\\nimport it.geosolutions.geostore.core.security.SimpleGrantedAuthoritiesMapper;\\nimport org.junit.Test;\\nimport org.springframework.ldap.core.DirContextAdapter;\\nimport org.springframework.security.core.GrantedAuthority;\\n'], 'diff_2': ['                        }\\n                        \\n                    }, new BasicAttributes());\\n                    return new IterableNamingEnumeration(Collections.singletonList(sr));\\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\\n', '                        }\\n                        \\n                    }, new BasicAttributes());\\n\\n                    SearchResult sr2 = new SearchResult(\"cn=group2\", null, new MockDirContextOperations() {\\n\\n                        @Override\\n                        public String getNameInNamespace() {\\n                            return \"cn=group2,ou=groups\";\\n                        }\\n\\n                        @Override\\n                        public String getStringAttribute(String name) {\\n                            if (\"cn\".equals(name)) {\\n                                return \"group2\";\\n                            }\\n                            return \"\";\\n                        }\\n\\n                    }, new BasicAttributes());\\n                    return new IterableNamingEnumeration(Arrays.asList(sr, sr2));\\n                } else if (\"(member=cn=group1,ou=groups)\".equals(filter)) {\\n                    List<SearchResult> groups = new ArrayList<SearchResult>();\\n                    SearchResult sr = new SearchResult(\"cn=parentgroup1\", null, new MockDirContextOperations() {\\n'], 'diff_3': ['                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(2, authorities.size());\\n    }\\n    \\n    @Test\\n', '                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(true);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(3, authorities.size());\\n    }\\n    \\n    @Test\\n'], 'diff_4': ['                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(1, authorities.size());\\n    }\\n}\\n', '                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(2, authorities.size());\\n    }\\n\\n    @Test\\n    public void testDropUnmappedRoles() {\\n\\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=groups\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Map<String,String>  mappings=new HashMap<>();\\n        mappings.put(\"ROLE_GROUP2\",\"ROLE_ADMIN\");\\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\\n        mapper.setDropUnmapped(true);\\n        authoritiesPopulator.setRoleMapper(mapper);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        List<String> expected=Arrays.asList(\"ROLE_ADMIN\",\"GROUP1\",\"GROUP2\");\\n        List<String> stringAuthorities=authorities.stream().map(a->a.getAuthority()).collect(Collectors.toList());\\n        assertEquals(expected.size(), stringAuthorities.size());\\n        assertTrue(stringAuthorities.containsAll(expected));\\n    }\\n\\n\\n    @Test\\n    public void testDropUnmappedGroups() {\\n\\n        GeoStoreLdapAuthoritiesPopulator authoritiesPopulator =\\n                new GeoStoreLdapAuthoritiesPopulator(new MockContextSource(ctx), \"ou=groups\", \"ou=roles\");\\n        authoritiesPopulator.setEnableHierarchicalGroups(false);\\n        Map<String,String>  mappings=new HashMap<>();\\n        mappings.put(\"GROUP2\",\"MAPPED_GROUP\");\\n        SimpleGrantedAuthoritiesMapper mapper=new SimpleGrantedAuthoritiesMapper(mappings);\\n        mapper.setDropUnmapped(true);\\n        authoritiesPopulator.setGroupMapper(mapper);\\n        Set<GrantedAuthority> authorities = authoritiesPopulator.getGroupMembershipRoles(\"uid=bill,ou=people\", \"bill\");\\n        assertEquals(1, authorities.size());\\n        assertEquals(\"MAPPED_GROUP\",authorities.iterator().next().getAuthority());\\n    }\\n}\\n']}","subject":"","message":"Tests for LDAP groups and roles concepts are mixed (#272)\n\n\n","lang":"Java","license":"","repos":""}
{"commit":"92305c4113ea3b2f419a712ba399eaf3ed59c382","old_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/core\/internal\/provider\/SliceBindingsProvider.java","new_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/core\/internal\/provider\/SliceBindingsProvider.java","old_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\npackage com.cognifide.slice.core.internal.provider;\n\nimport javax.script.Bindings;\n\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceUtil;\nimport org.apache.sling.scripting.api.BindingsValuesProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.cognifide.slice.api.model.ModelClassResolver;\n\n@Component\n@Service\npublic class SliceBindingsProvider implements BindingsValuesProvider {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(SliceBindingsProvider.class);\n\n\t@Reference\n\tprivate ModelClassResolver modelClassNameResolver;\n\n\t@Override\n\tpublic void addBindings(Bindings bindings) {\n\t\tfinal Resource resource = (Resource) bindings.get(\"resource\");\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tfinal Class<?> modelClass = getModel(resource);\n\t\t\tif (modelClass != null) {\n\t\t\t\tbindings.put(\"model\", resource.adaptTo(modelClass));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tLOG.error(\"Can't resolver Slice model class\", e);\n\t\t}\n\t}\n\n\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\n\t\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\n\t\tif (modelClass == null) {\n\t\t\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\n\t\t\tif (resourceSuperType != null) {\n\t\t\t\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\n\t\t\t}\n\t\t}\n\t\treturn modelClass;\n\t}\n\n}\n","new_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\npackage com.cognifide.slice.core.internal.provider;\n\nimport javax.script.Bindings;\n\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceUtil;\nimport org.apache.sling.scripting.api.BindingsValuesProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.cognifide.slice.api.model.ModelClassResolver;\n\n@Component\n@Service\npublic class SliceBindingsProvider implements BindingsValuesProvider {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(SliceBindingsProvider.class);\n\n\t@Reference\n\tprivate ModelClassResolver modelClassNameResolver;\n\n\t@Override\n\tpublic void addBindings(Bindings bindings) {\n\t\tfinal Resource resource = (Resource) bindings.get(\"resource\");\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tfinal Class<?> modelClass = getModel(resource);\n\t\t\tif (modelClass != null) {\n\t\t\t\tbindings.put(\"model\", resource.adaptTo(modelClass));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tLOG.error(\"Can't resolver Slice model class\", e);\n\t\t}\n\t}\n\n\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\n\t\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\n\t\twhile (modelClass == null) {\n\t\t\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\n\t\t\tif (resourceSuperType == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\n\t\t\tresource = resource.getResourceResolver().getResource(resourceSuperType);\n\t\t}\n\t\treturn modelClass;\n\t}\n\n}\n","code_block_diff":"{'diff_0': ['\\n\\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\\n\\t\\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\\n\\t\\tif (modelClass == null) {\\n\\t\\t\\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\\n\\t\\t\\tif (resourceSuperType != null) {\\n\\t\\t\\t\\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn modelClass;\\n\\t}\\n', '\\n\\tprivate Class<?> getModel(Resource resource) throws ClassNotFoundException {\\n\\t\\tClass<?> modelClass = modelClassNameResolver.getModelClass(resource.getResourceType());\\n\\t\\twhile (modelClass == null) {\\n\\t\\t\\tString resourceSuperType = ResourceUtil.findResourceSuperType(resource);\\n\\t\\t\\tif (resourceSuperType == null) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmodelClass = modelClassNameResolver.getModelClass(resourceSuperType);\\n\\t\\t\\tresource = resource.getResourceResolver().getResource(resourceSuperType);\\n\\t\\t}\\n\\t\\treturn modelClass;\\n\\t}\\n']}","subject":"","message":"SLICE-135: Added inheritance support for resourceSuperType\n\n","lang":"Java","license":"","repos":""}
{"commit":"38f7b2b6e2a3aee52598bcea9407fe4298705299","old_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/commons\/SliceModulesFactory.java","new_file":"slice-core\/src\/main\/java\/com\/cognifide\/slice\/commons\/SliceModulesFactory.java","old_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\n\npackage com.cognifide.slice.commons;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ops4j.peaberry.Peaberry;\nimport org.osgi.framework.BundleContext;\n\nimport com.cognifide.slice.api.context.ContextScope;\nimport com.cognifide.slice.core.internal.context.SliceContextScope;\nimport com.cognifide.slice.core.internal.module.JcrModule;\nimport com.cognifide.slice.core.internal.module.SliceMonitoringModule;\nimport com.cognifide.slice.core.internal.module.SliceModule;\nimport com.cognifide.slice.core.internal.module.SliceResourceModule;\nimport com.cognifide.slice.core.internal.module.SlingModule;\nimport com.cognifide.slice.persistence.impl.module.PersistenceModule;\nimport com.google.inject.Module;\n\n\/**\n * Factory for all Slice-related modules. It should be used in application's activator to register\n * Slice-related modules\n * \n * @author maciej.majchrzak\n * \n *\/\npublic class SliceModulesFactory {\n\n\tprivate SliceModulesFactory() {\n\t}\n\n\t\/**\n\t * Creates and returns a list of all Slice-related modules, including framework's internal modules as well\n\t * as Sling's and JCR's ones. The list includes:<br>\n\t * <ul>\n\t * <li>Peaberry module<\/li>\n\t * <li>{@link SliceModule}<\/li>\n\t * <li>{@link SlingModule}<\/li>\n\t * <li>{@link JcrModule}<\/li>\n\t * <li>{@link SliceResourceModule}<\/li>\n\t * <\/ul>\n\t * @param bundleContext bundle Context\n\t * @return list of Slice-related modules\n\t *\/\n\tpublic static List<Module> createModules(final BundleContext bundleContext) {\n\t\tfinal ContextScope contextScope = new SliceContextScope();\n\t\tList<Module> modules = new ArrayList<Module>();\n\t\tmodules.add(Peaberry.osgiModule(bundleContext));\n\t\tmodules.add(new SliceModule(contextScope, bundleContext.getBundle()));\n\t\tmodules.add(new SlingModule(contextScope));\n\t\tmodules.add(new JcrModule());\n\t\tmodules.add(new SliceResourceModule());\n\t\tmodules.add(new PersistenceModule());\n\t\tmodules.add(new SliceMonitoringModule());\n\t\treturn modules;\n\t}\n}\n","new_contents":"\/*-\n * #%L\n * Slice - Core\n * %%\n * Copyright (C) 2012 Cognifide Limited\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n *\/\n\npackage com.cognifide.slice.commons;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ops4j.peaberry.Peaberry;\nimport org.osgi.framework.BundleContext;\n\nimport com.cognifide.slice.api.context.ContextScope;\nimport com.cognifide.slice.core.internal.context.SliceContextScope;\nimport com.cognifide.slice.core.internal.module.JcrModule;\nimport com.cognifide.slice.core.internal.module.SliceMonitoringModule;\nimport com.cognifide.slice.core.internal.module.SliceModule;\nimport com.cognifide.slice.core.internal.module.SliceResourceModule;\nimport com.cognifide.slice.core.internal.module.SlingModule;\nimport com.cognifide.slice.persistence.impl.module.PersistenceModule;\nimport com.google.inject.Module;\n\n\/**\n * Factory for all Slice-related modules. It should be used in application's activator to register\n * Slice-related modules\n * \n * @author maciej.majchrzak\n * \n *\/\npublic class SliceModulesFactory {\n\n\tprivate SliceModulesFactory() {\n\t}\n\n\t\/**\n\t * Creates and returns a list of all Slice-related modules, including framework's internal modules as well\n\t * as Sling's and JCR's ones. The list includes:<br>\n\t * <ul>\n\t * <li>Peaberry module<\/li>\n\t * <li>{@link SliceModule}<\/li>\n\t * <li>{@link SlingModule}<\/li>\n\t * <li>{@link JcrModule}<\/li>\n\t * <li>{@link SliceResourceModule}<\/li>\n\t * <li>{@link SliceMonitoringModule}<\/li>\n\t * <\/ul>\n\t * @param bundleContext bundle Context\n\t * @return list of Slice-related modules\n\t *\/\n\tpublic static List<Module> createModules(final BundleContext bundleContext) {\n\t\tfinal ContextScope contextScope = new SliceContextScope();\n\t\tList<Module> modules = new ArrayList<Module>();\n\t\tmodules.add(Peaberry.osgiModule(bundleContext));\n\t\tmodules.add(new SliceModule(contextScope, bundleContext.getBundle()));\n\t\tmodules.add(new SlingModule(contextScope));\n\t\tmodules.add(new JcrModule());\n\t\tmodules.add(new SliceResourceModule());\n\t\tmodules.add(new PersistenceModule());\n\t\tmodules.add(new SliceMonitoringModule());\n\t\treturn modules;\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t * <li>{@link SlingModule}<\/li>\\n\\t * <li>{@link JcrModule}<\/li>\\n\\t * <li>{@link SliceResourceModule}<\/li>\\n\\t * <\/ul>\\n\\t * @param bundleContext bundle Context\\n\\t * @return list of Slice-related modules\\n', '\\t * <li>{@link SlingModule}<\/li>\\n\\t * <li>{@link JcrModule}<\/li>\\n\\t * <li>{@link SliceResourceModule}<\/li>\\n\\t * <li>{@link SliceMonitoringModule}<\/li>\\n\\t * <\/ul>\\n\\t * @param bundleContext bundle Context\\n\\t * @return list of Slice-related modules\\n']}","subject":"","message":"Revert \"SLICE-139 Replacing AOP based implementation with strict coupling\"\n\nThis reverts commit 4ee6ffe2a469079ecdbdfa00a703984e31e5c947.\n\n","lang":"Java","license":"","repos":""}
{"commit":"947de263721911fe939f80a64126c0c7b287b3d0","old_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","new_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","old_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","new_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t}\\n\\n\\t@Override\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n', '\\t}\\n\\n\\t@Override\\n\\t@SuppressWarnings(\"unchecked\")\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n'], 'diff_1': ['\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n', '\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n']}","subject":"","message":"Minor code cleanup\n\n","lang":"Java","license":"","repos":""}
{"commit":"eebdcbf007299a2d765e6e2861a7d915fbc6fe96","old_file":"Code\/src\/main\/java\/otld\/otld\/intermediate\/Program.java","new_file":"Code\/src\/main\/java\/otld\/otld\/intermediate\/Program.java","old_contents":"package otld.otld.intermediate;\n\nimport otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\/**\n * Represents a program.\n *\n * A program has a unique identifier.\n *\n * A Program instance is responsible for keeping administration on all variables, functions, etc.\n *\/\npublic class Program {\n    \/** The identifier of the program. *\/\n    private String id;\n\n    \/** The variables in this program indexed by identifier. *\/\n    private Map<String, Variable> variables;\n\n    \/** The functions in this program indexed by identifier. *\/\n    private Map<String, Function> functions;\n\n    \/** The operations that form the program. *\/\n    private OperationSequence body;\n\n    \/**\n     * @param id The unique identifier of the program.\n     *\/\n    public Program(final String id) {\n        this.id = id;\n        this.variables = new HashMap<String, Variable>();\n        this.functions = new HashMap<String, Function>();\n    }\n\n    \/**\n     * @return The unique identifier of the program.\n     *\/\n    public final String getId() {\n        return this.id;\n    }\n\n    \/**\n     * @param id The identifier of the variable.\n     * @return The variable or {@code null} if there is no variable with the given identifier.\n     *\/\n    public final Variable getVariable(final String id) {\n        return this.variables.get(id);\n    }\n\n    \/**\n     * @param var The variable to add.\n     * @throws VariableAlreadyDeclared There already exists a variable with the given name.\n     *\/\n    public final void addVariable(final Variable var) throws VariableAlreadyDeclared {\n        if (this.variables.containsKey(var.getId())) {\n            throw new VariableAlreadyDeclared();\n        }\n        this.variables.put(var.getId(), var);\n    }\n\n    \/**\n     * @param id The identifier of the function.\n     * @return The function or {@code null} if there is no function with the given identifier.\n     *\/\n    public final Function getFunction(final String id) {\n        return this.functions.get(id);\n    }\n\n    \/**\n     * @param function The function to add.\n     * @throws FunctionAlreadyDeclared There already exists a function with the given name.\n     *\/\n    public final void addFunction(final Function function) throws FunctionAlreadyDeclared {\n        if (this.functions.containsKey(function.getId())) {\n            throw new FunctionAlreadyDeclared();\n        }\n        this.functions.put(function.getId(), function);\n    }\n\n    \/**\n     * @return The body of the program.\n     *\/\n    public final OperationSequence getBody() {\n        return this.body;\n    }\n\n    @Override\n    public final String toString() {\n        return String.format(\"Program %s\", this.getId());\n    }\n}\n","new_contents":"package otld.otld.intermediate;\n\nimport otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\n\nimport java.util.*;\n\n\/**\n * Represents a program.\n *\n * A program has a unique identifier.\n *\n * A Program instance is responsible for keeping administration on all variables, functions, etc.\n *\/\npublic class Program {\n    \/** The identifier of the program. *\/\n    private String id;\n\n    \/** The variables in this program indexed by identifier. *\/\n    private Map<String, Variable> variables;\n\n    \/** The functions in this program indexed by identifier. *\/\n    private Map<String, Function> functions;\n\n    \/** The operations that form the program. *\/\n    private OperationSequence body;\n\n    \/**\n     * @param id The unique identifier of the program.\n     *\/\n    public Program(final String id) {\n        this.id = id;\n        this.variables = new HashMap<String, Variable>();\n        this.functions = new HashMap<String, Function>();\n\n        for (Function function : getDefaultFunctions()) {\n            this.functions.put(function.getId(), function);\n        }\n    }\n\n    \/**\n     * Returns the default functions for a program based on the available operators.\n     * @return The default functions for a program.\n     *\/\n    private static Set<Function> getDefaultFunctions() {\n        final Set<Function> functions = new HashSet<>();\n\n        for (Operator op : Operator.values()) {\n            final Type[] opArgs = op.getArgs();\n            final Type[] types = Arrays.copyOf(opArgs, opArgs.length + 1);\n            types[opArgs.length] = op.getType();\n\n            functions.add(new Function(op.name(), types));\n        }\n\n        return functions;\n    }\n\n    \/**\n     * @return The unique identifier of the program.\n     *\/\n    public final String getId() {\n        return this.id;\n    }\n\n    \/**\n     * @param id The identifier of the variable.\n     * @return The variable or {@code null} if there is no variable with the given identifier.\n     *\/\n    public final Variable getVariable(final String id) {\n        return this.variables.get(id);\n    }\n\n    \/**\n     * @param var The variable to add.\n     * @throws VariableAlreadyDeclared There already exists a variable with the given name.\n     *\/\n    public final void addVariable(final Variable var) throws VariableAlreadyDeclared {\n        if (this.variables.containsKey(var.getId())) {\n            throw new VariableAlreadyDeclared();\n        }\n        this.variables.put(var.getId(), var);\n    }\n\n    \/**\n     * @param id The identifier of the function.\n     * @return The function or {@code null} if there is no function with the given identifier.\n     *\/\n    public final Function getFunction(final String id) {\n        return this.functions.get(id);\n    }\n\n    \/**\n     * @param function The function to add.\n     * @throws FunctionAlreadyDeclared There already exists a function with the given name.\n     *\/\n    public final void addFunction(final Function function) throws FunctionAlreadyDeclared {\n        if (this.functions.containsKey(function.getId())) {\n            throw new FunctionAlreadyDeclared();\n        }\n        this.functions.put(function.getId(), function);\n    }\n\n    \/**\n     * @return The body of the program.\n     *\/\n    public final OperationSequence getBody() {\n        return this.body;\n    }\n\n    @Override\n    public final String toString() {\n        return String.format(\"Program %s\", this.getId());\n    }\n}\n","code_block_diff":"{'diff_0': ['import otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n\/**\\n * Represents a program.\\n', 'import otld.otld.intermediate.exceptions.FunctionAlreadyDeclared;\\nimport otld.otld.intermediate.exceptions.VariableAlreadyDeclared;\\n\\nimport java.util.*;\\n\\n\/**\\n * Represents a program.\\n'], 'diff_1': ['        this.id = id;\\n        this.variables = new HashMap<String, Variable>();\\n        this.functions = new HashMap<String, Function>();\\n    }\\n\\n    \/**\\n', '        this.id = id;\\n        this.variables = new HashMap<String, Variable>();\\n        this.functions = new HashMap<String, Function>();\\n\\n        for (Function function : getDefaultFunctions()) {\\n            this.functions.put(function.getId(), function);\\n        }\\n    }\\n\\n    \/**\\n     * Returns the default functions for a program based on the available operators.\\n     * @return The default functions for a program.\\n     *\/\\n    private static Set<Function> getDefaultFunctions() {\\n        final Set<Function> functions = new HashSet<>();\\n\\n        for (Operator op : Operator.values()) {\\n            final Type[] opArgs = op.getArgs();\\n            final Type[] types = Arrays.copyOf(opArgs, opArgs.length + 1);\\n            types[opArgs.length] = op.getType();\\n\\n            functions.add(new Function(op.name(), types));\\n        }\\n\\n        return functions;\\n    }\\n\\n    \/**\\n']}","subject":"","message":"Add default functions\n\n","lang":"Java","license":"","repos":""}
{"commit":"07c9fe87aae60ecb1b18f8d6df3ad82777c64307","old_file":"mapserver-protocols\/src\/main\/java\/org\/geolatte\/mapserver\/protocols\/wms_1_3_0\/WmsBbox.java","new_file":"mapserver-protocols\/src\/main\/java\/org\/geolatte\/mapserver\/protocols\/wms_1_3_0\/WmsBbox.java","old_contents":"package org.geolatte.mapserver.protocols.wms_1_3_0;\n\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CoordinateReferenceSystem;\nimport org.geolatte.geom.crs.CoordinateReferenceSystems;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.geom.crs.CrsRegistry;\n\nimport java.util.Objects;\n\nimport static java.lang.String.format;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 10\/05\/2018.\n *\/\npublic class WmsBbox {\n\n    private final double minX;\n    private final double minY;\n    private final double maxX;\n    private final double maxY;\n\n    public WmsBbox(double minX, double minY, double maxX, double maxY) {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    public double getMinX() {\n        return minX;\n    }\n\n    public double getMinY() {\n        return minY;\n    }\n\n    public double getMaxX() {\n        return maxX;\n    }\n\n    public double getMaxY() {\n        return maxY;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WmsBbox wmsBbox = (WmsBbox) o;\n        return Double.compare(wmsBbox.minX, minX) == 0 &&\n                Double.compare(wmsBbox.minY, minY) == 0 &&\n                Double.compare(wmsBbox.maxX, maxX) == 0 &&\n                Double.compare(wmsBbox.maxY, maxY) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(minX, minY, maxX, maxY);\n    }\n\n    Envelope<C2D> toEnvelope(String srs) {\n        CrsId crsId = CrsId.parse(srs);\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\n            throw new RuntimeException(format(\"Only EPSG CRS strings are supported (%s)\", srs));\n        }\n        CoordinateReferenceSystem<?> crs = CrsRegistry.getCoordinateReferenceSystemForEPSG(crsId.getCode(), CoordinateReferenceSystems.PROJECTED_2D_METER);\n        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\n        }  else {\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.WEB_MERCATOR);\n        }\n\n    }\n}\n","new_contents":"package org.geolatte.mapserver.protocols.wms_1_3_0;\n\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CoordinateReferenceSystem;\nimport org.geolatte.geom.crs.CoordinateReferenceSystems;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.geom.crs.CrsRegistry;\nimport org.geolatte.geom.crs.GeographicCoordinateReferenceSystem;\n\nimport java.util.Objects;\n\nimport static java.lang.String.format;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 10\/05\/2018.\n *\/\npublic class WmsBbox {\n\n    private final double minX;\n    private final double minY;\n    private final double maxX;\n    private final double maxY;\n\n    public WmsBbox(double minX, double minY, double maxX, double maxY) {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    public double getMinX() {\n        return minX;\n    }\n\n    public double getMinY() {\n        return minY;\n    }\n\n    public double getMaxX() {\n        return maxX;\n    }\n\n    public double getMaxY() {\n        return maxY;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WmsBbox wmsBbox = (WmsBbox) o;\n        return Double.compare(wmsBbox.minX, minX) == 0 &&\n                Double.compare(wmsBbox.minY, minY) == 0 &&\n                Double.compare(wmsBbox.maxX, maxX) == 0 &&\n                Double.compare(wmsBbox.maxY, maxY) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(minX, minY, maxX, maxY);\n    }\n\n    @SuppressWarnings( \"unchecked\" )\n    Envelope<C2D> toEnvelope(String srs) {\n        CrsId crsId = CrsId.parse(srs);\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\n            throw new RuntimeException(format(\"Only EPSG CRS strings are supported (%s)\", srs));\n        }\n        CoordinateReferenceSystem<?> crs = CrsRegistry.getCoordinateReferenceSystemForEPSG(crsId.getCode(), CoordinateReferenceSystems.PROJECTED_2D_METER);\n        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\n        }  else {\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.asProjected(crs));\n        }\n    }\n}\n","code_block_diff":"{'diff_0': ['import org.geolatte.geom.crs.CoordinateReferenceSystems;\\nimport org.geolatte.geom.crs.CrsId;\\nimport org.geolatte.geom.crs.CrsRegistry;\\n\\nimport java.util.Objects;\\n\\n', 'import org.geolatte.geom.crs.CoordinateReferenceSystems;\\nimport org.geolatte.geom.crs.CrsId;\\nimport org.geolatte.geom.crs.CrsRegistry;\\nimport org.geolatte.geom.crs.GeographicCoordinateReferenceSystem;\\n\\nimport java.util.Objects;\\n\\n'], 'diff_1': ['        return Objects.hash(minX, minY, maxX, maxY);\\n    }\\n\\n    Envelope<C2D> toEnvelope(String srs) {\\n        CrsId crsId = CrsId.parse(srs);\\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\\n', '        return Objects.hash(minX, minY, maxX, maxY);\\n    }\\n\\n    @SuppressWarnings( \"unchecked\" )\\n    Envelope<C2D> toEnvelope(String srs) {\\n        CrsId crsId = CrsId.parse(srs);\\n        if(! crsId.getAuthority().equalsIgnoreCase(\"EPSG\") ) {\\n'], 'diff_2': ['        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\\n        }  else {\\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.WEB_MERCATOR);\\n        }\\n\\n    }\\n}\\n', '        if (C2D.class.isAssignableFrom(crs.getPositionClass())) {\\n            return new Envelope<>(minX, minY, maxX, maxY, (CoordinateReferenceSystem<C2D>)crs);\\n        }  else {\\n            return new Envelope<>(minX, minY, maxX, maxY, CoordinateReferenceSystems.asProjected(crs));\\n        }\\n    }\\n}\\n']}","subject":"","message":"Support non-projected SRS in maprequest\n\n","lang":"Java","license":"","repos":""}
{"commit":"947de263721911fe939f80a64126c0c7b287b3d0","old_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","new_file":"mapserver-rxhttpfeaturesource\/src\/main\/java\/org\/geolatte\/mapserver\/rxhttp\/RxHttpFeatureSource.java","old_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","new_contents":"package org.geolatte.mapserver.rxhttp;\n\nimport java.nio.charset.Charset;\nimport java.util.Locale;\n\nimport be.wegenenverkeer.rxhttp.ClientRequest;\nimport be.wegenenverkeer.rxhttp.ClientRequestBuilder;\nimport be.wegenenverkeer.rxhttp.RxHttpClient;\nimport org.geolatte.geom.C2D;\nimport org.geolatte.geom.Envelope;\nimport org.geolatte.geom.Feature;\nimport org.geolatte.geom.Position;\nimport org.geolatte.geom.crs.CrsId;\nimport org.geolatte.maprenderer.map.PlanarFeature;\nimport org.geolatte.mapserver.features.FeatureDeserializer;\nimport org.geolatte.mapserver.features.FeatureSource;\nimport org.geolatte.mapserver.transform.Transform;\nimport org.geolatte.mapserver.transform.TransformFactory;\nimport org.stringtemplate.v4.ST;\nimport rx.Observable;\n\nimport static org.geolatte.mapserver.util.EnvelopUtils.bufferRounded;\n\n\/**\n * Created by Karel Maesen, Geovise BVBA on 19\/07\/2018.\n *\/\npublic class RxHttpFeatureSource implements FeatureSource {\n\n\n\tfinal private static Charset UTF8 = Charset.forName( \"UTF-8\" );\n\tfinal private String template;\n\tfinal private boolean gzip;\n\tfinal private RxHttpClient client;\n\tfinal private FeatureDeserializerFactory featureDeserializerFactory;\n\tfinal private CrsId sourceCrsId;\n\tfinal private boolean convertFeaturesToRequestedCrs;\n\tfinal private TransformFactory transformFactory;\n\n\tpublic RxHttpFeatureSource(\n\t\t\tRxHttpFeatureSourceConfig config,\n\t\t\tFeatureDeserializerFactory deserFactory,\n\t\t\tTransformFactory transformFactory) {\n\t\tthis.template = config.getTemplate();\n\t\tString host = config.getHost();\n\t\tthis.gzip = config.getGzip() == null ? true : config.getGzip();\n\t\tthis.featureDeserializerFactory = deserFactory;\n\t\tthis.sourceCrsId = CrsId.parse( config.getCrs() );\n\t\tthis.convertFeaturesToRequestedCrs = config.convertFeaturesToRequestedCrs;\n\n\t\tthis.transformFactory = transformFactory;\n\t\tthis.client = new RxHttpClient.Builder()\n\t\t\t\t.setAccept( \"application\/json\" )\n\t\t\t\t.setBaseUrl( host )\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\n\t\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\n\t\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\n\t\tString queryUrl = render( bbox, query );\n\t\tClientRequestBuilder builder = client.requestBuilder().setUrlRelativetoBase( queryUrl );\n\t\tif ( this.gzip ) {\n\t\t\tbuilder = builder.addHeader( \"Accept-Encoding\", \"gzip\" );\n\t\t}\n\n\t\tClientRequest request = builder.build();\n\n\t\tChunkSplitter chunkSplitter = new ChunkSplitter();\n\t\tfinal FeatureDeserializer deserializer = featureDeserializerFactory.featureDeserializer();\n\t\tObservable<Feature> featureObservable = client\n\t\t\t\t.executeObservably( request, bytes -> new String( bytes, UTF8 ) )\n\t\t\t\t.flatMapIterable( chunkSplitter::split )\n\t\t\t\t.flatMapIterable( deserializer::deserialize );\n\n\t\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\n\t\t\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\n\t\t\treturn transformed.map( PlanarFeature::from );\n\t\t}\n\t\telse {\n\t\t\treturn featureObservable.map( PlanarFeature::from );\n\t\t}\n\n\t}\n\n\tprivate Envelope<Position> toQueryBbox(\n\t\t\tEnvelope<C2D> tileBoundingBox,\n\t\t\tdouble bboxScaleFactor,\n\t\t\tTransform<Position, C2D> transform) {\n\t\tif ( transform == null){\n\t\t\treturn bufferRounded(tileBoundingBox.as(Position.class), bboxScaleFactor);\n\t\t} else {\n\t\t\treturn bufferRounded(transform.reverse(tileBoundingBox), bboxScaleFactor );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Transform<Position, C2D> buildTransform(Envelope<C2D> bbox) {\n\t\tCrsId targetCrsId = bbox.getCoordinateReferenceSystem().getCrsId();\n\t\tTransform<Position, C2D> transform = null;\n\t\tif ( !targetCrsId.equals( sourceCrsId ) ) {\n\t\t\ttransform = (Transform<Position, C2D>) this.transformFactory.getTransform( sourceCrsId, targetCrsId );\n\n\t\t}\n\t\treturn transform;\n\t}\n\n\n\t\/\/ for testing\n\tprotected FeatureDeserializerFactory getFeatureDeserializerFactory() {\n\t\treturn this.featureDeserializerFactory;\n\t}\n\n\t\/\/for testing\n\tprotected CrsId getSourceCrsId() {\n\t\treturn this.sourceCrsId;\n\t}\n\n\tprivate <P extends Position> String render(Envelope<P> bbox, String query) {\n\t\tST st = fillInTemplateParams( bbox, query );\n\t\treturn st.render();\n\t}\n\n\tprivate <P extends Position> ST fillInTemplateParams(Envelope<P> bbox, String query) {\n\t\tST st = new ST( template );\n\t\tst.add( \"bbox\", asString( bbox ) );\n\t\tif ( query != null ) {\n\t\t\tst.add( query, query );\n\t\t}\n\t\treturn st;\n\t}\n\n\tprivate <P extends Position> String asString(Envelope<P> bbox) {\n\t\tdouble[] cos = bbox.toArray();\n\t\treturn String.format( Locale.ROOT, \"%f,%f,%f,%f\", cos[0], cos[1], cos[2], cos[3] );\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif ( client != null ) {\n\t\t\tclient.close();\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t}\\n\\n\\t@Override\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n', '\\t}\\n\\n\\t@Override\\n\\t@SuppressWarnings(\"unchecked\")\\n\\tpublic Observable<PlanarFeature> query(Envelope<C2D> tileBoundingBox, String query, double bboxScaleFactor) {\\n\\t\\tTransform<Position, C2D> transform = buildTransform( tileBoundingBox );\\n\\t\\tEnvelope<Position> bbox = toQueryBbox( tileBoundingBox, bboxScaleFactor, transform );\\n'], 'diff_1': ['\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( f -> (Feature) (transform.forwardFeature( f )) );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n', '\\t\\t\\t\\t.flatMapIterable( deserializer::deserialize );\\n\\n\\t\\tif ( convertFeaturesToRequestedCrs && (transform != null) ) {\\n\\t\\t\\tObservable<Feature> transformed = featureObservable.map( transform::forwardFeature );\\n\\t\\t\\treturn transformed.map( PlanarFeature::from );\\n\\t\\t}\\n\\t\\telse {\\n']}","subject":"","message":"Minor code cleanup\n\n","lang":"Java","license":"","repos":""}
{"commit":"85fff46b5c6c5ecef67d1a2bbbd57dd7e99ea58c","old_file":"src\/cryptography\/ciphers\/elgamal\/ElgamalTest.java","new_file":"src\/cryptography\/ciphers\/elgamal\/ElgamalTest.java","old_contents":"\/**\n * This class is part of running automated tests\n *\/\npackage cryptography.ciphers.elgamal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\nimport cryptography.Logging;\nimport cryptography.Mode;\n\npublic class ElgamalTest {\n\n\t@Test\n\tpublic void runTest() {\n\t\t\n\t\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\n\n\t\tElgamal elgamal = new Elgamal(Logging.DISABLED);\n\t\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\n\n\t\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\n\t\tassertEquals(128, elgamal.getKeyBlockLength());\n\n\t}\n\n}\n","new_contents":"\/**\n * This class is part of running automated tests\n *\/\npackage cryptography.ciphers.elgamal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\nimport cryptography.Logging;\nimport cryptography.Mode;\n\npublic class ElgamalTest {\n\n\t@Test\n\tpublic void runTest() {\n\t\t\n\t\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\n\n\t\t\/*\n\t\tElgamal elgamal = new Elgamal(Logging.DISABLED);\n\t\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\n\n\t\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\n\t\tassertEquals(128, elgamal.getKeyBlockLength());\n\t\t*\/\n\t\t\n\t\t\/\/ TODO: Jenkins will throw JCE cannot authenticate the provider BC because of JDK version. Fix this later.\n\t\t\n\t\tassertEquals(1, 1);\n\n\t}\n\n}\n","code_block_diff":"{'diff_0': ['\\t\\t\\n\\t\\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\\n\\n\\t\\tElgamal elgamal = new Elgamal(Logging.DISABLED);\\n\\t\\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\\n\\n\\t\\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\\n\\t\\tassertEquals(128, elgamal.getKeyBlockLength());\\n\\n\\t}\\n\\n', '\\t\\t\\n\\t\\t\/\/ TODO: this test is currently very poor, only things which is tested is that encrypted string becomes original string again\\n\\n\\t\\t\/*\\n\\t\\tElgamal elgamal = new Elgamal(Logging.DISABLED);\\n\\t\\tfinal String elgamalCipherText = elgamal.elgamal(Mode.ENCRYPT, \"TESTING\");\\n\\n\\t\\tassertEquals(\"TESTING\", elgamal.elgamal(Mode.DECRYPT, elgamalCipherText));\\n\\t\\tassertEquals(128, elgamal.getKeyBlockLength());\\n\\t\\t*\/\\n\\t\\t\\n\\t\\t\/\/ TODO: Jenkins will throw JCE cannot authenticate the provider BC because of JDK version. Fix this later.\\n\\t\\t\\n\\t\\tassertEquals(1, 1);\\n\\n\\t}\\n\\n']}","subject":"","message":"Update ElgamalTest.java\n\n","lang":"Java","license":"","repos":""}
{"commit":"09016a53aa37f23ff54e8a1dd4df81fd73c064e9","old_file":"sampleapp\/src\/main\/java\/com\/mindscapehq\/raygun4java\/sampleapp\/SampleApp.java","new_file":"sampleapp\/src\/main\/java\/com\/mindscapehq\/raygun4java\/sampleapp\/SampleApp.java","old_contents":"package com.mindscapehq.raygun4java.sampleapp;\n\nimport com.mindscapehq.raygun4java.core.IRaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.IRaygunOnAfterSend;\nimport com.mindscapehq.raygun4java.core.IRaygunOnBeforeSend;\nimport com.mindscapehq.raygun4java.core.IRaygunSendEventFactory;\nimport com.mindscapehq.raygun4java.core.RaygunClient;\nimport com.mindscapehq.raygun4java.core.RaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.RaygunSettings;\nimport com.mindscapehq.raygun4java.core.messages.RaygunIdentifier;\nimport com.mindscapehq.raygun4java.core.messages.RaygunMessage;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\n\/**\n * To test with getting the version from the jar\n * mvn clean package install\n * java -jar sampleapp\\target\\sampleapp-3.0.0-SNAPSHOT-jar-with-dependencies.jar\n *\/\npublic class SampleApp {\n\n    public static final String API_KEY = \"YOUR_API_KEY\";\n\n    \/**\n     * An example of how to use Raygun4Java\n     *\/\n    public static void main(String[] args) throws Throwable {\n\n        final Exception exceptionToThrowLater = new Exception(\"Raygun4Java test exception\");\n\n        \/\/ sets the global unhandled exception handler\n        Thread.setDefaultUncaughtExceptionHandler(MyExceptionHandler.instance());\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"App starting up\");\n\n        RaygunIdentifier userIdentity = new RaygunIdentifier(\"a@b.com\")\n                .withEmail(\"a@b.com\")\n                .withFirstName(\"Foo\")\n                .withFullName(\"Foo Bar\")\n                .withAnonymous(false)\n                .withUuid(UUID.randomUUID().toString());\n        MyExceptionHandler.getClient().setUser(userIdentity);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                MyExceptionHandler.getClient().recordBreadcrumb(\"different thread starting\");\n\n                \/\/ note that use info not set on this thread\n\n                try {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception\");\n                    throw exceptionToThrowLater;\n                } catch (Exception e) {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception\");\n\n                    Map<String, String> customData = new HashMap<String, String>();\n                    customData.put(\"thread id\", \"\" + Thread.currentThread().getId());\n                    MyExceptionHandler.getClient()\n                            .withTag(\"thrown from thread\")\n                            .withTag(\"no user withData\")\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\n                            .send(exceptionToThrowLater);\n\n                    \/\/ this should appear in the raygun console as its already been sed\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This should not appear because we're sending the same exception on the same thread\");\n                    Set<String> tags = new HashSet<String>();\n                    tags.add(\"should not appear in console\");\n                    MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\n                }\n\n                \/\/ test offline storage by breaking the proxy\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\n\n                System.out.println(\"No Send below this line\");\n                MyExceptionHandler.getClient().send(new Exception(\"occurred while offline offline\"));\n                System.out.println(\"No Send above this lines ^\");\n\n                \/\/ fix the proxy and send offline data\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\n                MyExceptionHandler.getClient().send(new Exception(\"This should trigger offline\"));\n\n            }\n        }).start();\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\n        throw exceptionToThrowLater;\n    }\n}\n\nclass BeforeSendImplementation implements IRaygunOnBeforeSend, IRaygunSendEventFactory<IRaygunOnBeforeSend> {\n    @Override\n    public RaygunMessage onBeforeSend(RaygunClient client, RaygunMessage message) {\n        String errorMessage = message.getDetails().getError().getMessage();\n        message.getDetails().getError().setMessage(errorMessage + \" - I have been mutated by onBeforeSend\");\n\n        message.getDetails().setGroupingKey(\"baz2\");\n\n        return message;\n    }\n\n    @Override\n    public IRaygunOnBeforeSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}\n\nclass MyExceptionHandler implements Thread.UncaughtExceptionHandler {\n\n    private static MyExceptionHandler instance;\n\n    static {\n        instance = new MyExceptionHandler();\n    }\n\n    public static Thread.UncaughtExceptionHandler instance() {\n        return instance;\n    }\n\n    private IRaygunClientFactory factory;\n    private ThreadLocal<RaygunClient> clients = new ThreadLocal<RaygunClient>();\n\n    public MyExceptionHandler() {\n        factory = new RaygunClientFactory(SampleApp.API_KEY)\n                .withBreadcrumbLocations() \/\/ don't do this in production\n                .withBeforeSend(new BeforeSendImplementation())\n                .withAfterSend(new MyOnAfterHandler())\n                .withOfflineStorage()\n                .withTag(\"from sample app\")\n                .withData(\"how now\", \"brown cow\")\n                .withData(1, Arrays.asList(123));\n    }\n\n    public static RaygunClient getClient() {\n        RaygunClient client = instance.clients.get();\n        if (client == null) {\n            client = instance.factory.newClient();\n            instance.clients.set(client);\n        }\n        return client;\n    }\n\n    public void uncaughtException(Thread t, Throwable e) {\n        getClient().sendUnhandled(e);\n    }\n}\n\nclass MyOnAfterHandler implements IRaygunOnAfterSend, IRaygunSendEventFactory<IRaygunOnAfterSend> {\n\n    @Override\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\n        System.out.println(\"We sent a error to ragun!\");\n        return message;\n    }\n\n    @Override\n    public IRaygunOnAfterSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}","new_contents":"package com.mindscapehq.raygun4java.sampleapp;\n\nimport com.mindscapehq.raygun4java.core.IRaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.IRaygunOnAfterSend;\nimport com.mindscapehq.raygun4java.core.IRaygunOnBeforeSend;\nimport com.mindscapehq.raygun4java.core.IRaygunSendEventFactory;\nimport com.mindscapehq.raygun4java.core.RaygunClient;\nimport com.mindscapehq.raygun4java.core.RaygunClientFactory;\nimport com.mindscapehq.raygun4java.core.RaygunSettings;\nimport com.mindscapehq.raygun4java.core.messages.RaygunIdentifier;\nimport com.mindscapehq.raygun4java.core.messages.RaygunMessage;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\n\/**\n * To test with getting the version from the jar\n * mvn clean package install\n * java -jar sampleapp\\target\\sampleapp-<version>-jar-with-dependencies.jar\n *\/\npublic class SampleApp {\n\n    public static final String API_KEY = \"YOUR_API_KEY\";\n\n    \/**\n     * An example of how to use Raygun4Java\n     *\/\n    public static void main(String[] args) throws Throwable {\n\n        final Exception exceptionToThrowLater = new Exception(\"Raygun4Java test exception\");\n\n        \/\/ sets the global unhandled exception handler\n        Thread.setDefaultUncaughtExceptionHandler(MyExceptionHandler.instance());\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"App starting up\");\n\n        RaygunIdentifier userIdentity = new RaygunIdentifier(\"a@b.com\")\n                .withEmail(\"a@b.com\")\n                .withFirstName(\"Foo\")\n                .withFullName(\"Foo Bar\")\n                .withAnonymous(false)\n                .withUuid(UUID.randomUUID().toString());\n        MyExceptionHandler.getClient().setUser(userIdentity);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                MyExceptionHandler.getClient().recordBreadcrumb(\"first thread starting\");\n\n                \/\/ note that user info is not set on this thread\n                try {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception in a thread\");\n                    throw exceptionToThrowLater;\n                } catch (Exception e) {\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception in a thread\");\n\n                    int result_thread = MyExceptionHandler.getClient()\n                            .withTag(\"thrown from a thread\")\n                            .withTag(\"no user withData\")\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\n                            .send(exceptionToThrowLater);\n\n                    System.out.println(\"[SampleApp-Thread] First sending of the exception from a thread, result: \" + result_thread);\n\n                    \/\/ Breadcrumb will be set on the RaygunClient object\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This will appear in exceptions further down, outside of this catch\");\n\n                    \/\/ This additional send should not appear in the Raygun back end as the exception has already been sent\n                    Set<String> tags = new HashSet<String>();\n                    tags.add(\"should not appear in console\");\n                    int result_notSucessful = MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\n                    System.out.println(\"[SampleApp-Thread] Second sending of the same exception from same thread, result: \" + result_notSucessful);\n                }\n\n                \/\/ test offline storage by breaking the proxy\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\n\n                System.out.println(\"[SampleApp-Thread] No send below this line\");\n                int result_fakeOffline = MyExceptionHandler.getClient().send(new Exception(\"This occurred while offline\"));\n                System.out.println(\"[SampleApp-Thread] Sending an exception while offline, result: \" + result_fakeOffline);\n                System.out.println(\"[SampleApp-Thread] No send above this line ^\");\n\n                \/\/ fix the proxy and send offline data\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\n                int result_backOnline = MyExceptionHandler.getClient().send(new Exception(\"This should trigger sending the previous offline report\"));\n                System.out.println(\"[SampleApp-Thread] Sending an exception when back online, result: \" + result_backOnline);\n            }\n        }).start();\n\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\n        \/\/ This can be thrown *again* from the main thread\n        throw exceptionToThrowLater;\n    }\n}\n\nclass BeforeSendImplementation implements IRaygunOnBeforeSend, IRaygunSendEventFactory<IRaygunOnBeforeSend> {\n    @Override\n    public RaygunMessage onBeforeSend(RaygunClient client, RaygunMessage message) {\n        String errorMessage = message.getDetails().getError().getMessage();\n        message.getDetails().getError().setMessage(errorMessage + \" - I have been mutated by onBeforeSend\");\n\n        message.getDetails().setGroupingKey(\"baz2\");\n\n        return message;\n    }\n\n    @Override\n    public IRaygunOnBeforeSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}\n\nclass MyExceptionHandler implements Thread.UncaughtExceptionHandler {\n\n    private static MyExceptionHandler instance;\n\n    static {\n        instance = new MyExceptionHandler();\n    }\n\n    public static Thread.UncaughtExceptionHandler instance() {\n        return instance;\n    }\n\n    private IRaygunClientFactory factory;\n    private ThreadLocal<RaygunClient> clients = new ThreadLocal<RaygunClient>();\n\n    public MyExceptionHandler() {\n        factory = new RaygunClientFactory(SampleApp.API_KEY)\n                .withBreadcrumbLocations() \/\/ don't do this in production\n                .withBeforeSend(new BeforeSendImplementation())\n                .withAfterSend(new MyOnAfterHandler())\n                .withOfflineStorage()\n                .withTag(\"from sample app\")\n                .withData(\"how now\", \"brown cow\")\n                .withData(1, Arrays.asList(123));\n    }\n\n    public static RaygunClient getClient() {\n        RaygunClient client = instance.clients.get();\n        if (client == null) {\n            client = instance.factory.newClient();\n            instance.clients.set(client);\n        }\n        return client;\n    }\n\n    public void uncaughtException(Thread t, Throwable e) {\n        getClient().sendUnhandled(e);\n    }\n}\n\nclass MyOnAfterHandler implements IRaygunOnAfterSend, IRaygunSendEventFactory<IRaygunOnAfterSend> {\n\n    @Override\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\n        System.out.println(\"[OnAfterSend] We sent a error to Raygun!\");\n        return message;\n    }\n\n    @Override\n    public IRaygunOnAfterSend create() {\n        return this; \/\/ if this implementation held state, this is where you'd create a new one for each RaygunClient instance\n    }\n}","code_block_diff":"{'diff_0': ['\/**\\n * To test with getting the version from the jar\\n * mvn clean package install\\n * java -jar sampleapp\\\\target\\\\sampleapp-3.0.0-SNAPSHOT-jar-with-dependencies.jar\\n *\/\\npublic class SampleApp {\\n\\n', '\/**\\n * To test with getting the version from the jar\\n * mvn clean package install\\n * java -jar sampleapp\\\\target\\\\sampleapp-<version>-jar-with-dependencies.jar\\n *\/\\npublic class SampleApp {\\n\\n'], 'diff_1': ['        new Thread(new Runnable() {\\n            @Override\\n            public void run() {\\n                MyExceptionHandler.getClient().recordBreadcrumb(\"different thread starting\");\\n\\n                \/\/ note that use info not set on this thread\\n\\n                try {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception\");\\n                    throw exceptionToThrowLater;\\n                } catch (Exception e) {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception\");\\n\\n                    Map<String, String> customData = new HashMap<String, String>();\\n                    customData.put(\"thread id\", \"\" + Thread.currentThread().getId());\\n                    MyExceptionHandler.getClient()\\n                            .withTag(\"thrown from thread\")\\n                            .withTag(\"no user withData\")\\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\\n                            .send(exceptionToThrowLater);\\n\\n                    \/\/ this should appear in the raygun console as its already been sed\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This should not appear because we\\'re sending the same exception on the same thread\");\\n                    Set<String> tags = new HashSet<String>();\\n                    tags.add(\"should not appear in console\");\\n                    MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\\n                }\\n\\n                \/\/ test offline storage by breaking the proxy\\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\\n\\n                System.out.println(\"No Send below this line\");\\n                MyExceptionHandler.getClient().send(new Exception(\"occurred while offline offline\"));\\n                System.out.println(\"No Send above this lines ^\");\\n\\n                \/\/ fix the proxy and send offline data\\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\\n                MyExceptionHandler.getClient().send(new Exception(\"This should trigger offline\"));\\n\\n            }\\n        }).start();\\n\\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\\n        throw exceptionToThrowLater;\\n    }\\n}\\n', '        new Thread(new Runnable() {\\n            @Override\\n            public void run() {\\n                MyExceptionHandler.getClient().recordBreadcrumb(\"first thread starting\");\\n\\n                \/\/ note that user info is not set on this thread\\n                try {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"throwing exception in a thread\");\\n                    throw exceptionToThrowLater;\\n                } catch (Exception e) {\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"handling exception in a thread\");\\n\\n                    int result_thread = MyExceptionHandler.getClient()\\n                            .withTag(\"thrown from a thread\")\\n                            .withTag(\"no user withData\")\\n                            .withData(\"thread id\", \"\" + Thread.currentThread().getId())\\n                            .send(exceptionToThrowLater);\\n\\n                    System.out.println(\"[SampleApp-Thread] First sending of the exception from a thread, result: \" + result_thread);\\n\\n                    \/\/ Breadcrumb will be set on the RaygunClient object\\n                    MyExceptionHandler.getClient().recordBreadcrumb(\"This will appear in exceptions further down, outside of this catch\");\\n\\n                    \/\/ This additional send should not appear in the Raygun back end as the exception has already been sent\\n                    Set<String> tags = new HashSet<String>();\\n                    tags.add(\"should not appear in console\");\\n                    int result_notSucessful = MyExceptionHandler.getClient().send(exceptionToThrowLater, tags);\\n                    System.out.println(\"[SampleApp-Thread] Second sending of the same exception from same thread, result: \" + result_notSucessful);\\n                }\\n\\n                \/\/ test offline storage by breaking the proxy\\n                RaygunSettings.getSettings().setHttpProxy(\"nothing here\", 80);\\n\\n                System.out.println(\"[SampleApp-Thread] No send below this line\");\\n                int result_fakeOffline = MyExceptionHandler.getClient().send(new Exception(\"This occurred while offline\"));\\n                System.out.println(\"[SampleApp-Thread] Sending an exception while offline, result: \" + result_fakeOffline);\\n                System.out.println(\"[SampleApp-Thread] No send above this line ^\");\\n\\n                \/\/ fix the proxy and send offline data\\n                RaygunSettings.getSettings().setHttpProxy(null, 80);\\n                int result_backOnline = MyExceptionHandler.getClient().send(new Exception(\"This should trigger sending the previous offline report\"));\\n                System.out.println(\"[SampleApp-Thread] Sending an exception when back online, result: \" + result_backOnline);\\n            }\\n        }).start();\\n\\n        MyExceptionHandler.getClient().recordBreadcrumb(\"Throwing exception on main thread\");\\n        \/\/ This can be thrown *again* from the main thread\\n        throw exceptionToThrowLater;\\n    }\\n}\\n'], 'diff_2': ['\\n    @Override\\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\\n        System.out.println(\"We sent a error to ragun!\");\\n        return message;\\n    }\\n\\n', '\\n    @Override\\n    public RaygunMessage onAfterSend(RaygunClient client, RaygunMessage message) {\\n        System.out.println(\"[OnAfterSend] We sent a error to Raygun!\");\\n        return message;\\n    }\\n\\n']}","subject":"","message":"Cleanup and improvements for sample app\n\n","lang":"Java","license":"","repos":""}
{"commit":"de1fcbd8c4de81f24d0339a66e80190fba3149db","old_file":"junit\/src\/test\/java\/com\/github\/fluentxml4j\/junit\/XmlResultTest.java","new_file":"junit\/src\/test\/java\/com\/github\/fluentxml4j\/junit\/XmlResultTest.java","old_contents":"package com.github.fluentxml4j.junit;\n\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class XmlResultTest\n{\n\tprivate static final Charset UTF8 = Charset.forName(\"UTF-8\");\n\n\t@Rule\n\tpublic XmlResult result = XmlResult.empty();\n\n\t@Test\n\tpublic void stringViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n\n\t@Test\n\tpublic void stringViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n}\n","new_contents":"package com.github.fluentxml4j.junit;\n\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\n\nimport com.github.fluentxml4j.junit.XmlSource;\nimport com.github.fluentxml4j.junit.XmlResult;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class XmlResultTest\n{\n\tprivate static final Charset UTF8 = Charset.forName(\"UTF-8\");\n\n\t@Rule\n\tpublic XmlResult result = XmlResult.empty();\n\n\t@Test\n\tpublic void stringViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaOutputStream() throws IOException\n\t{\n\t\tOutputStream out = this.result.getOutputStream();\n\t\tout.write(\"<test\/>\".getBytes(UTF8));\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n\n\t@Test\n\tpublic void stringViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asString(), is(\"<test\/>\"));\n\t}\n\n\t@Test\n\tpublic void documentViaWriter() throws IOException\n\t{\n\t\tWriter out = this.result.getWriter();\n\t\tout.write(\"<test\/>\");\n\t\tout.close();\n\n\t\tassertThat(result.asDocument().getDocumentElement().getLocalName(), is(\"test\"));\n\t}\n}\n","code_block_diff":"{'diff_0': ['import java.io.Writer;\\nimport java.nio.charset.Charset;\\n\\nimport static org.hamcrest.CoreMatchers.is;\\nimport static org.hamcrest.MatcherAssert.assertThat;\\n\\n', 'import java.io.Writer;\\nimport java.nio.charset.Charset;\\n\\nimport com.github.fluentxml4j.junit.XmlSource;\\nimport com.github.fluentxml4j.junit.XmlResult;\\n\\nimport static org.hamcrest.CoreMatchers.is;\\nimport static org.hamcrest.MatcherAssert.assertThat;\\n\\n']}","subject":"","message":"more\n\nTask: none\n\nReviewed by noone.\n\n","lang":"Java","license":"","repos":""}
{"commit":"a78138cde8583de24cf182261649b100482db16e","old_file":"core\/src\/main\/java\/com\/mindscapehq\/raygun4java\/core\/messages\/RaygunEnvironmentMessage.java","new_file":"core\/src\/main\/java\/com\/mindscapehq\/raygun4java\/core\/messages\/RaygunEnvironmentMessage.java","old_contents":"package com.mindscapehq.raygun4java.core.messages;\n\nimport java.awt.*;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.lang.management.OperatingSystemMXBean;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class RaygunEnvironmentMessage {\n\n\tprivate String cpu;\n\tprivate String architecture;\n\tprivate int processorCount;\n\tprivate String osVersion;\n\tprivate int windowBoundsWidth;\n\tprivate int windowBoundsHeight;\n\tprivate String currentOrientation;\n\tprivate String locale;\n\tprivate long totalPhysicalMemory;\n\tprivate long availablePhysicalMemory;\n\tprivate long totalVirtualMemory;\n\tprivate long availableVirtualMemory;\n\tprivate int diskSpaceFree;\n\tprivate double utcOffset;\n\tprivate static String message = \"Couldn't access all environment data. If you are running in GAE or a restricted environment this is expected\";\n\tprivate static Logger logger = Logger.getLogger(\"Raygun4Java.environment\");\n\n\tpublic RaygunEnvironmentMessage() {\n\t\ttry {\n\t\t\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tlocale = Locale.getDefault().getLanguage() + \"-\"\n\t\t\t\t\t+ Locale.getDefault().getCountry();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\twindowBoundsWidth = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;\n\t\t\twindowBoundsHeight = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tprocessorCount = Runtime.getRuntime().availableProcessors();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tMemoryMXBean memBean = ManagementFactory.getMemoryMXBean();\n\n\t\t\ttotalVirtualMemory = memBean.getHeapMemoryUsage().getMax()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getMax();\n\t\t\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getUsed();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tOperatingSystemMXBean osMXBean = ManagementFactory\n\t\t\t\t\t.getOperatingSystemMXBean();\n\t\t\tarchitecture = osMXBean.getArch();\n\t\t\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\n\t\t}\n\t}\n}\n","new_contents":"package com.mindscapehq.raygun4java.core.messages;\n\nimport java.awt.*;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.lang.management.OperatingSystemMXBean;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class RaygunEnvironmentMessage {\n\n\tprivate String cpu;\n\tprivate String architecture;\n\tprivate int processorCount;\n\tprivate String osVersion;\n\tprivate int windowBoundsWidth;\n\tprivate int windowBoundsHeight;\n\tprivate String currentOrientation;\n\tprivate String locale;\n\tprivate long totalPhysicalMemory;\n\tprivate long availablePhysicalMemory;\n\tprivate long totalVirtualMemory;\n\tprivate long availableVirtualMemory;\n\tprivate int diskSpaceFree;\n\tprivate double utcOffset;\n\tprivate static String message = \"Couldn't access all environment data. If you are running in GAE or a restricted environment this is expected\";\n\tprivate static Logger logger = Logger.getLogger(\"Raygun4Java.environment\");\n\n\tpublic RaygunEnvironmentMessage() {\n\t\ttry {\n\t\t\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tlocale = Locale.getDefault().getLanguage() + \"-\"\n\t\t\t\t\t+ Locale.getDefault().getCountry();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\twindowBoundsWidth = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;\n\t\t\twindowBoundsHeight = GraphicsEnvironment\n\t\t\t\t\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tprocessorCount = Runtime.getRuntime().availableProcessors();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tMemoryMXBean memBean = ManagementFactory.getMemoryMXBean();\n\n\t\t\ttotalVirtualMemory = memBean.getHeapMemoryUsage().getMax()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getMax();\n\t\t\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\n\t\t\t\t\t+ memBean.getNonHeapMemoryUsage().getUsed();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\n\t\ttry {\n\t\t\tOperatingSystemMXBean osMXBean = ManagementFactory\n\t\t\t\t\t.getOperatingSystemMXBean();\n\t\t\tarchitecture = osMXBean.getArch();\n\t\t\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\n\t\t}\n\t}\n}\n","code_block_diff":"{'diff_0': ['\\t\\ttry {\\n\\t\\t\\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tlocale = Locale.getDefault().getLanguage() + \"-\"\\n\\t\\t\\t\\t\\t+ Locale.getDefault().getCountry();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\ttry {\\n\\t\\t\\tutcOffset = TimeZone.getDefault().getRawOffset() \/ 3600000.0;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tlocale = Locale.getDefault().getLanguage() + \"-\"\\n\\t\\t\\t\\t\\t+ Locale.getDefault().getCountry();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_1': ['\\t\\t\\twindowBoundsHeight = GraphicsEnvironment\\n\\t\\t\\t\\t\\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tprocessorCount = Runtime.getRuntime().availableProcessors();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\t\\twindowBoundsHeight = GraphicsEnvironment\\n\\t\\t\\t\\t\\t.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tprocessorCount = Runtime.getRuntime().availableProcessors();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_2': ['\\t\\t\\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\\n\\t\\t\\t\\t\\t+ memBean.getNonHeapMemoryUsage().getUsed();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n', '\\t\\t\\tavailableVirtualMemory = memBean.getHeapMemoryUsage().getUsed()\\n\\t\\t\\t\\t\\t+ memBean.getNonHeapMemoryUsage().getUsed();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\n\\t\\ttry {\\n'], 'diff_3': ['\\t\\t\\tarchitecture = osMXBean.getArch();\\n\\t\\t\\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.INFO, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\t}\\n}\\n', '\\t\\t\\tarchitecture = osMXBean.getArch();\\n\\t\\t\\tosVersion = osMXBean.getName() + \" - \" + osMXBean.getVersion();\\n\\t\\t} catch (Throwable t) {\\n\\t\\t\\tlogger.log(Level.FINEST, RaygunEnvironmentMessage.message, t);\\n\\t\\t}\\n\\t}\\n}\\n']}","subject":"","message":"Lower environment logging error level to Finest\n\nref #26\n\n","lang":"Java","license":"","repos":""}
{"commit":"5b08ffcfac090c4099cb0f1c41f0cc2e337af446","old_file":"nuxeo-core-api\/src\/main\/java\/org\/nuxeo\/ecm\/core\/api\/event\/impl\/CoreEventImpl.java","new_file":"nuxeo-core-api\/src\/main\/java\/org\/nuxeo\/ecm\/core\/api\/event\/impl\/CoreEventImpl.java","old_contents":"\/*\n * (C) Copyright 2006-2007 Nuxeo SAS (http:\/\/nuxeo.com\/) and contributors.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the GNU Lesser General Public License\n * (LGPL) version 2.1 which accompanies this distribution, and is available at\n * http:\/\/www.gnu.org\/licenses\/lgpl.html\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * Contributors:\n *     Nuxeo - initial API and implementation\n *\n * $Id: JOOoConvertPluginImpl.java 18651 2007-05-13 20:28:53Z sfermigier $\n *\/\n\npackage org.nuxeo.ecm.core.api.event.impl;\n\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.nuxeo.ecm.core.api.event.CoreEvent;\n\n\/**\n * Nuxeo core event implementation.\n *\n * @author <a href=\"mailto:ja@nuxeo.com\">Julien Anguenot<\/a>\n * @author <a href=\"mailto:tmartins@nuxeo.com\">Thierry Martins<\/a>\n *\/\npublic class CoreEventImpl implements CoreEvent {\n\n    protected final String eventId;\n\n    protected final Object source;\n\n    protected final Map<String, ?> info;\n\n    protected final Date date;\n\n    protected final Principal principal;\n\n    \/\/ Interesting attributes to make accessible in the eventInfo\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\n\n    public static final String CATEGORY_ATTRIBUTE = \"category\";\n\n    @SuppressWarnings(\"unchecked\")\n    public CoreEventImpl(String eventId, Object source, Map<String, ?> info,\n            Principal principal, String category, String comment) {\n        date = new Date();\n        if (eventId != null) {\n            this.eventId = eventId.intern();\n        } else {\n            this.eventId = null;\n        }\n        this.source = source;\n        if (info == null) {\n            this.info = new HashMap<String, Object>();\n        } else {\n            this.info = new HashMap<String, Object>(info);\n        }\n        this.principal = principal;\n        \/\/ info map contains at least this 2 keys\n        ((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\n        ((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\n    }\n\n    public boolean isComposite() {\n        return false;\n    }\n\n    public List<CoreEvent> getNestedEvents() {\n        return null;\n    }\n\n    public String getEventId() {\n        return eventId;\n    }\n\n    public Map<String, ?> getInfo() {\n        return info;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String getCategory() {\n        return (String) this.info.get(CATEGORY_ATTRIBUTE);\n    }\n\n    public String getComment() {\n        return (String) this.info.get(COMMENT_ATTRIBUTE);\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public Principal getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(CoreEventImpl.class.getSimpleName());\n        buf.append(\" {\");\n        buf.append(\" eventId: \");\n        buf.append(eventId);\n        buf.append(\", source: \");\n        buf.append(source);\n        buf.append(\", info: \");\n        buf.append(info);\n        buf.append(\", date: \");\n        buf.append(date);\n        buf.append(\", principal name: \");\n        if (principal != null) {\n            buf.append(principal.getName());\n        }\n        buf.append(\", comment: \");\n        buf.append(this.info.get(COMMENT_ATTRIBUTE));\n        buf.append(\", category: \");\n        buf.append(this.info.get(CATEGORY_ATTRIBUTE));\n        buf.append('}');\n\n        return buf.toString();\n    }\n\n}\n","new_contents":"\/*\n * (C) Copyright 2006-2007 Nuxeo SAS (http:\/\/nuxeo.com\/) and contributors.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the GNU Lesser General Public License\n * (LGPL) version 2.1 which accompanies this distribution, and is available at\n * http:\/\/www.gnu.org\/licenses\/lgpl.html\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * Contributors:\n *     Nuxeo - initial API and implementation\n *\n * $Id: JOOoConvertPluginImpl.java 18651 2007-05-13 20:28:53Z sfermigier $\n *\/\n\npackage org.nuxeo.ecm.core.api.event.impl;\n\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.nuxeo.ecm.core.api.event.CoreEvent;\n\n\/**\n * Nuxeo core event implementation.\n *\n * @author <a href=\"mailto:ja@nuxeo.com\">Julien Anguenot<\/a>\n * @author <a href=\"mailto:tmartins@nuxeo.com\">Thierry Martins<\/a>\n *\/\npublic class CoreEventImpl implements CoreEvent {\n\n    protected final String eventId;\n\n    protected final Object source;\n\n    protected final Map<String, ?> info;\n\n    protected final Date date;\n\n    protected final Principal principal;\n\n    protected final String category;\n\n    protected final String comment;\n\n    \/\/ Interesting attributes to make accessible in the eventInfo\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\n\n    public static final String CATEGORY_ATTRIBUTE = \"category\";\n\n    @SuppressWarnings(\"unchecked\")\n    public CoreEventImpl(String eventId, Object source, Map<String, ?> info,\n            Principal principal, String category, String comment) {\n        date = new Date();\n        if (eventId != null) {\n            this.eventId = eventId.intern();\n        } else {\n            this.eventId = null;\n        }\n        this.source = source;\n        if (info == null) {\n            this.info = new HashMap<String, Object>();\n        } else {\n            this.info = new HashMap<String, Object>(info);\n        }\n        this.principal = principal;\n\n\t\t\/\/ CB: NXP-2253 - Values passed as parameters will be put into the info\n\t\t\/\/ map only if the map doesn't contain the corresponding keys.\n\t\tif (!((Map) this.info).containsKey(COMMENT_ATTRIBUTE)) {\n\t\t\t((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\n\t\t}\n\t\tif (!((Map) this.info).containsKey(CATEGORY_ATTRIBUTE)) {\n\t\t\t((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\n\t\t}\n\n\t\tthis.comment = comment;\n\t\tthis.category = category;\n    }\n\n    public boolean isComposite() {\n        return false;\n    }\n\n    public List<CoreEvent> getNestedEvents() {\n        return null;\n    }\n\n    public String getEventId() {\n        return eventId;\n    }\n\n    public Map<String, ?> getInfo() {\n        return info;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String getCategory() {\n        if (category != null) {\n            return category;\n        } else {\n            Object categoryObj = this.info.get(CATEGORY_ATTRIBUTE);\n            if (categoryObj instanceof String) {\n                return (String) categoryObj;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public String getComment() {\n        if (comment != null) {\n            return comment;\n        } else {\n            Object commentObj = this.info.get(COMMENT_ATTRIBUTE);\n            if (commentObj instanceof String) {\n                return (String) commentObj;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public Principal getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(CoreEventImpl.class.getSimpleName());\n        buf.append(\" {\");\n        buf.append(\" eventId: \");\n        buf.append(eventId);\n        buf.append(\", source: \");\n        buf.append(source);\n        buf.append(\", info: \");\n        buf.append(info);\n        buf.append(\", date: \");\n        buf.append(date);\n        buf.append(\", principal name: \");\n        if (principal != null) {\n            buf.append(principal.getName());\n        }\n        buf.append(\", comment: \");\n        buf.append(getComment());\n        buf.append(\", category: \");\n        buf.append(getCategory());\n        buf.append('}');\n\n        return buf.toString();\n    }\n\n}\n","code_block_diff":"{'diff_0': ['\\n    protected final Principal principal;\\n\\n    \/\/ Interesting attributes to make accessible in the eventInfo\\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\\n\\n', '\\n    protected final Principal principal;\\n\\n    protected final String category;\\n\\n    protected final String comment;\\n\\n    \/\/ Interesting attributes to make accessible in the eventInfo\\n    public static final String COMMENT_ATTRIBUTE = \"comment\";\\n\\n'], 'diff_1': ['            this.info = new HashMap<String, Object>(info);\\n        }\\n        this.principal = principal;\\n        \/\/ info map contains at least this 2 keys\\n        ((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\\n        ((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\\n    }\\n\\n    public boolean isComposite() {\\n', \"            this.info = new HashMap<String, Object>(info);\\n        }\\n        this.principal = principal;\\n\\n\\t\\t\/\/ CB: NXP-2253 - Values passed as parameters will be put into the info\\n\\t\\t\/\/ map only if the map doesn't contain the corresponding keys.\\n\\t\\tif (!((Map) this.info).containsKey(COMMENT_ATTRIBUTE)) {\\n\\t\\t\\t((Map) this.info).put(COMMENT_ATTRIBUTE, comment);\\n\\t\\t}\\n\\t\\tif (!((Map) this.info).containsKey(CATEGORY_ATTRIBUTE)) {\\n\\t\\t\\t((Map) this.info).put(CATEGORY_ATTRIBUTE, category);\\n\\t\\t}\\n\\n\\t\\tthis.comment = comment;\\n\\t\\tthis.category = category;\\n    }\\n\\n    public boolean isComposite() {\\n\"], 'diff_2': ['    }\\n\\n    public String getCategory() {\\n        return (String) this.info.get(CATEGORY_ATTRIBUTE);\\n    }\\n\\n    public String getComment() {\\n        return (String) this.info.get(COMMENT_ATTRIBUTE);\\n    }\\n\\n    public Date getDate() {\\n', '    }\\n\\n    public String getCategory() {\\n        if (category != null) {\\n            return category;\\n        } else {\\n            Object categoryObj = this.info.get(CATEGORY_ATTRIBUTE);\\n            if (categoryObj instanceof String) {\\n                return (String) categoryObj;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n\\n    public String getComment() {\\n        if (comment != null) {\\n            return comment;\\n        } else {\\n            Object commentObj = this.info.get(COMMENT_ATTRIBUTE);\\n            if (commentObj instanceof String) {\\n                return (String) commentObj;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n\\n    public Date getDate() {\\n'], 'diff_3': ['            buf.append(principal.getName());\\n        }\\n        buf.append(\", comment: \");\\n        buf.append(this.info.get(COMMENT_ATTRIBUTE));\\n        buf.append(\", category: \");\\n        buf.append(this.info.get(CATEGORY_ATTRIBUTE));\\n        buf.append(\\'}\\');\\n\\n        return buf.toString();\\n', '            buf.append(principal.getName());\\n        }\\n        buf.append(\", comment: \");\\n        buf.append(getComment());\\n        buf.append(\", category: \");\\n        buf.append(getCategory());\\n        buf.append(\\'}\\');\\n\\n        return buf.toString();\\n']}","subject":"","message":"NXP-2806: fill log comment with modification comment on edit screen\n\n","lang":"Java","license":"","repos":""}
{"commit":"014da6246ef7f224597e4df8c128d38844b312d2","old_file":"dubbo-admin-server\/src\/main\/java\/org\/apache\/dubbo\/admin\/registry\/nacos\/NacosOpenapiUtil.java","new_file":"dubbo-admin-server\/src\/main\/java\/org\/apache\/dubbo\/admin\/registry\/nacos\/NacosOpenapiUtil.java","old_contents":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.dubbo.admin.registry.nacos;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport com.alibaba.fastjson2.JSON;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NacosOpenapiUtil {\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\n        \/\/ 定义Nacos OpenAPI的URL\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\n        if (StringUtils.isNotEmpty(url.getParameter(\"namespace\"))) {\n            nacosUrl = nacosUrl + \"&namespaceId=\" + url.getParameter(\"namespace\");\n        }\n        if (StringUtils.isNotEmpty(url.getParameter(\"group\"))) {\n            nacosUrl = nacosUrl + \"&groupName=\" + url.getParameter(\"group\");\n        }\n\n        \/\/ 创建URL对象\n        java.net.URL netUrl = null;\n        try {\n            netUrl = new java.net.URL(nacosUrl);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        HttpURLConnection connection = null;\n        try {\n\n            \/\/ 创建HTTP连接\n            connection = (HttpURLConnection) netUrl.openConnection();\n\n            \/\/ 设置请求方法(GET或POST)\n            connection.setRequestMethod(\"GET\");\n\n            \/\/ 发送请求并获取响应状态码\n            int responseCode = connection.getResponseCode();\n\n            \/\/ 读取响应内容\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            \/\/ 打印响应结果\n            System.out.println(\"Response Code: \" + responseCode);\n            System.out.println(\"Response Body: \" + response.toString());\n\n            NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\n            return nacosResponse.getSubscribers();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            \/\/ 关闭连接\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n}\n","new_contents":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.dubbo.admin.registry.nacos;\n\nimport org.apache.dubbo.admin.controller.AccessesController;\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport com.alibaba.fastjson2.JSON;\nimport net.bytebuddy.implementation.bytecode.Throw;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NacosOpenapiUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(NacosOpenapiUtil.class);\n\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\n        \/\/ 定义Nacos OpenAPI的URL\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\n        if (StringUtils.isNotEmpty(url.getParameter(\"namespace\"))) {\n            nacosUrl = nacosUrl + \"&namespaceId=\" + url.getParameter(\"namespace\");\n        }\n        if (StringUtils.isNotEmpty(url.getParameter(\"group\"))) {\n            nacosUrl = nacosUrl + \"&groupName=\" + url.getParameter(\"group\");\n        }\n\n        \/\/ 创建URL对象\n        java.net.URL netUrl = null;\n        try {\n            netUrl = new java.net.URL(nacosUrl);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n\n        HttpURLConnection connection = null;\n        try {\n\n            \/\/ 创建HTTP连接\n            connection = (HttpURLConnection) netUrl.openConnection();\n\n            \/\/ 设置请求方法(GET或POST)\n            connection.setRequestMethod(\"GET\");\n\n            \/\/ 发送请求并获取响应状态码\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == 200) {\n                \/\/ 读取响应内容\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Error requesting nacos openapi, \" + nacosUrl, t);\n                }\n\n                NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\n                return nacosResponse.getSubscribers();\n            } else {\n                logger.error(\"Error requesting nacos openapi, \" + nacosUrl + \", error code is \" + responseCode);\n            }\n        } catch (IOException e) {\n            logger.error(\"Error requesting nacos openapi, \" + nacosUrl, e);\n        } finally {\n            \/\/ 关闭连接\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return Collections.EMPTY_LIST;\n    }\n}\n","code_block_diff":"{'diff_0': [' *\/\\npackage org.apache.dubbo.admin.registry.nacos;\\n\\nimport org.apache.dubbo.common.URL;\\nimport org.apache.dubbo.common.utils.StringUtils;\\n\\nimport com.alibaba.fastjson2.JSON;\\n\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\n', ' *\/\\npackage org.apache.dubbo.admin.registry.nacos;\\n\\nimport org.apache.dubbo.admin.controller.AccessesController;\\nimport org.apache.dubbo.common.URL;\\nimport org.apache.dubbo.common.logger.Logger;\\nimport org.apache.dubbo.common.logger.LoggerFactory;\\nimport org.apache.dubbo.common.utils.StringUtils;\\n\\nimport com.alibaba.fastjson2.JSON;\\nimport net.bytebuddy.implementation.bytecode.Throw;\\n\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\n'], 'diff_1': ['import java.util.List;\\n\\npublic class NacosOpenapiUtil {\\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\\n        \/\/ 定义Nacos OpenAPI的URL\\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\\n', 'import java.util.List;\\n\\npublic class NacosOpenapiUtil {\\n\\n    private static final Logger logger = LoggerFactory.getLogger(NacosOpenapiUtil.class);\\n\\n    public static List<NacosData> getSubscribeAddressesWithHttpEndpoint(URL url, String serviceName) {\\n        \/\/ 定义Nacos OpenAPI的URL\\n        String nacosUrl = \"http:\/\/\" + url.getAddress() + \"\/nacos\/v1\/ns\/service\/subscribers?serviceName=\" + serviceName;\\n'], 'diff_2': ['            \/\/ 发送请求并获取响应状态码\\n            int responseCode = connection.getResponseCode();\\n\\n            \/\/ 读取响应内容\\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\\n            String line;\\n            StringBuilder response = new StringBuilder();\\n            while ((line = reader.readLine()) != null) {\\n                response.append(line);\\n            }\\n            reader.close();\\n\\n            \/\/ 打印响应结果\\n            System.out.println(\"Response Code: \" + responseCode);\\n            System.out.println(\"Response Body: \" + response.toString());\\n\\n            NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\\n            return nacosResponse.getSubscribers();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } finally {\\n            \/\/ 关闭连接\\n            if (connection != null) {\\n', '            \/\/ 发送请求并获取响应状态码\\n            int responseCode = connection.getResponseCode();\\n\\n            if (responseCode == 200) {\\n                \/\/ 读取响应内容\\n                StringBuilder response = new StringBuilder();\\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\\n                    String line;\\n                    while ((line = reader.readLine()) != null) {\\n                        response.append(line);\\n                    }\\n                } catch (Throwable t) {\\n                    logger.error(\"Error requesting nacos openapi, \" + nacosUrl, t);\\n                }\\n\\n                NacosResponse nacosResponse = JSON.parseObject(response.toString(), NacosResponse.class);\\n                return nacosResponse.getSubscribers();\\n            } else {\\n                logger.error(\"Error requesting nacos openapi, \" + nacosUrl + \", error code is \" + responseCode);\\n            }\\n        } catch (IOException e) {\\n            logger.error(\"Error requesting nacos openapi, \" + nacosUrl, e);\\n        } finally {\\n            \/\/ 关闭连接\\n            if (connection != null) {\\n']}","subject":"","message":"enhance nacos openapi logic (#1227)\n\n\n","lang":"Java","license":"","repos":""}
{"commit":"9a15be001a71cfb6476d6a406fb2644da89c9da9","old_file":"relution-publisher\/src\/test\/java\/org\/jenkinsci\/plugins\/relution_publisher\/unittest\/mocks\/MockLog.java","new_file":"relution-publisher\/src\/test\/java\/org\/jenkinsci\/plugins\/relution_publisher\/unittest\/mocks\/MockLog.java","old_contents":"\npackage org.jenkinsci.plugins.relution_publisher.unittest.mocks;\n\nimport org.jenkinsci.plugins.relution_publisher.logging.Log;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n\npublic class MockLog implements Log {\n\n    private static final long serialVersionUID = 1L;\n\n    private static String valueOf(final Throwable t) {\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw);\n\n        t.printStackTrace(pw);\n\n        return sw.toString();\n    }\n\n    @Override\n    public void write() {\n        \/\/ Do nothing\n    }\n\n    @Override\n    public void write(final Class<?> source, final String format, final Object... args) {\n        System.out.format(format, args);\n        System.out.println();\n    }\n\n    @Override\n    public void write(final Object source, final String format, final Object... args) {\n        System.out.format(format, args);\n        System.out.println();\n    }\n\n    @Override\n    public void write(final Object source, final String format, final Throwable t) {\n        System.out.format(format, valueOf(t));\n        System.out.println();\n    }\n}\n","new_contents":"\npackage org.jenkinsci.plugins.relution_publisher.unittest.mocks;\n\nimport org.jenkinsci.plugins.relution_publisher.logging.Log;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n\npublic class MockLog implements Log {\n\n    private static final long serialVersionUID = 1L;\n\n    private static String valueOf(final Throwable t) {\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw);\n\n        t.printStackTrace(pw);\n\n        return sw.toString();\n    }\n\n    @Override\n    public void write() {\n        System.out.println();\n    }\n\n    @Override\n    public void write(final Class<?> source, final String format, final Object... args) {\n        System.out.format(format, args);\n        System.out.println();\n    }\n\n    @Override\n    public void write(final Object source, final String format, final Object... args) {\n        System.out.format(format, args);\n        System.out.println();\n    }\n\n    @Override\n    public void write(final Object source, final String format, final Throwable t) {\n        System.out.format(format, valueOf(t));\n        System.out.println();\n    }\n}\n","code_block_diff":"{'diff_0': ['\\n    @Override\\n    public void write() {\\n        \/\/ Do nothing\\n    }\\n\\n    @Override\\n', '\\n    @Override\\n    public void write() {\\n        System.out.println();\\n    }\\n\\n    @Override\\n']}","subject":"","message":"Print empty line on mock log write.\n\n","lang":"Java","license":"","repos":""}
{"commit":"11ed656eb1e2349e22aeaeb11ade8fe88a20d0b2","old_file":"relution-publisher\/src\/main\/java\/org\/jenkinsci\/plugins\/relution_publisher\/configuration\/global\/StoreConfiguration.java","new_file":"relution-publisher\/src\/main\/java\/org\/jenkinsci\/plugins\/relution_publisher\/configuration\/global\/StoreConfiguration.java","old_contents":"\/*\n * Copyright (c) 2013-2014 M-Way Solutions GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage org.jenkinsci.plugins.relution_publisher.configuration.global;\n\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport hudson.Extension;\nimport jenkins.model.GlobalConfiguration;\n\n\n\/**\n * Saves and restores the global configuration used by the plugin.\n *\/\n@Extension\npublic class StoreConfiguration extends GlobalConfiguration {\n\n    public final static String KEY_STORES        = \"stores\";\n    public final static String KEY_DEBUG_ENABLED = \"debugEnabled\";\n\n    private final List<Store>  stores            = new ArrayList<Store>();\n\n    private boolean            isDebugEnabled;\n\n    \/**\n     * Initializes a new instance of the {@link StoreConfiguration} class.\n     *\/\n    @DataBoundConstructor\n    public StoreConfiguration() {\n        this.load();\n    }\n\n    private void addStores(final JSONArray storesJsonArray) {\n        for (int n = 0; n < storesJsonArray.size(); n++) {\n            final JSONObject store = storesJsonArray.getJSONObject(n);\n            this.addStore(store);\n        }\n    }\n\n    private void addStore(final JSONObject storeJsonObject) {\n        final Store store = new Store(storeJsonObject);\n        this.stores.add(store);\n    }\n\n    \/**\n     * This human readable name is used in the configuration screen.\n     *\/\n    @Override\n    public String getDisplayName() {\n        return \"\";\n    }\n\n    @Override\n    public boolean configure(final StaplerRequest req, final JSONObject json) throws FormException {\n        System.out.println(json.toString());\n\n        this.stores.clear();\n        final Object jsonEntity = json.get(KEY_STORES);\n\n        if (jsonEntity instanceof JSONArray) {\n            final JSONArray stores = (JSONArray) jsonEntity;\n            this.addStores(stores);\n\n        } else if (jsonEntity instanceof JSONObject) {\n            final JSONObject store = (JSONObject) jsonEntity;\n            this.addStore(store);\n        }\n\n        this.isDebugEnabled = json.getBoolean(KEY_DEBUG_ENABLED);\n\n        this.save();\n        return false;\n    }\n\n    \/**\n     * @return The list of {@link Store}s configured for this publisher.\n     *\/\n    public List<Store> getStores() {\n        return this.stores;\n    }\n\n    \/**\n     * Gets the store with the specified identifier.\n     * @param storeId A store's {@link Store#getId() identifier}.\n     * @return The {@link Store} with the specified id, or {@code null} if no such store\n     * exists.\n     *\/\n    @SuppressWarnings(\"deprecation\")\n    public Store getStore(final String storeId) {\n        if (this.stores == null) {\n            return null;\n        }\n\n        for (final Store store : this.stores) {\n            if (StringUtils.equals(storeId, store.getId())) {\n                return store;\n            } else if (store.getIdentifier().equals(storeId)) {\n                return store;\n            }\n        }\n        return null;\n    }\n\n    \/**\n     * Gets a value indicating whether debug output should be enabled.\n     * @return {@code true} if debug output should be enabled; otherwise, {@code false}.\n     *\/\n    public boolean isDebugEnabled() {\n        return this.isDebugEnabled;\n    }\n\n    \/**\n     * Sets a value indicating whether debug output should be enabled.\n     * @param enabled {@code true} to enable debug output; {@code false} to disable debug output.\n     *\/\n    public void setDebugEnabled(final boolean enabled) {\n        this.isDebugEnabled = enabled;\n    }\n}\n","new_contents":"\/*\n * Copyright (c) 2013-2014 M-Way Solutions GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage org.jenkinsci.plugins.relution_publisher.configuration.global;\n\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport hudson.Extension;\nimport jenkins.model.GlobalConfiguration;\n\n\n\/**\n * Saves and restores the global configuration used by the plugin.\n *\/\n@Extension\npublic class StoreConfiguration extends GlobalConfiguration {\n\n    public final static String KEY_STORES        = \"stores\";\n    public final static String KEY_DEBUG_ENABLED = \"debugEnabled\";\n\n    private final List<Store>  stores            = new ArrayList<Store>();\n\n    private Boolean            isDebugEnabled;\n\n    \/**\n     * Initializes a new instance of the {@link StoreConfiguration} class.\n     *\/\n    @DataBoundConstructor\n    public StoreConfiguration() {\n        this.load();\n    }\n\n    private void addStores(final JSONArray storesJsonArray) {\n        for (int n = 0; n < storesJsonArray.size(); n++) {\n            final JSONObject store = storesJsonArray.getJSONObject(n);\n            this.addStore(store);\n        }\n    }\n\n    private void addStore(final JSONObject storeJsonObject) {\n        final Store store = new Store(storeJsonObject);\n        this.stores.add(store);\n    }\n\n    \/**\n     * This human readable name is used in the configuration screen.\n     *\/\n    @Override\n    public String getDisplayName() {\n        return \"\";\n    }\n\n    @Override\n    public boolean configure(final StaplerRequest req, final JSONObject json) throws FormException {\n        System.out.println(json.toString());\n\n        this.stores.clear();\n        final Object jsonEntity = json.get(KEY_STORES);\n\n        if (jsonEntity instanceof JSONArray) {\n            final JSONArray stores = (JSONArray) jsonEntity;\n            this.addStores(stores);\n\n        } else if (jsonEntity instanceof JSONObject) {\n            final JSONObject store = (JSONObject) jsonEntity;\n            this.addStore(store);\n        }\n\n        this.isDebugEnabled = json.getBoolean(KEY_DEBUG_ENABLED);\n\n        this.save();\n        return false;\n    }\n\n    \/**\n     * @return The list of {@link Store}s configured for this publisher.\n     *\/\n    public List<Store> getStores() {\n        return this.stores;\n    }\n\n    \/**\n     * Gets the store with the specified identifier.\n     * @param storeId A store's {@link Store#getId() identifier}.\n     * @return The {@link Store} with the specified id, or {@code null} if no such store\n     * exists.\n     *\/\n    @SuppressWarnings(\"deprecation\")\n    public Store getStore(final String storeId) {\n        if (this.stores == null) {\n            return null;\n        }\n\n        for (final Store store : this.stores) {\n            if (StringUtils.equals(storeId, store.getId())) {\n                return store;\n            } else if (store.getIdentifier().equals(storeId)) {\n                return store;\n            }\n        }\n        return null;\n    }\n\n    \/**\n     * Gets a value indicating whether debug output should be enabled.\n     * @return {@code true} if debug output should be enabled; otherwise, {@code false}.\n     *\/\n    public Boolean isDebugEnabled() {\n        return this.isDebugEnabled;\n    }\n\n    \/**\n     * Sets a value indicating whether debug output should be enabled.\n     * @param enabled {@code true} to enable debug output; {@code false} to disable debug output.\n     *\/\n    public void setDebugEnabled(final boolean enabled) {\n        this.isDebugEnabled = enabled;\n    }\n}\n","code_block_diff":"{'diff_0': ['\\n    private final List<Store>  stores            = new ArrayList<Store>();\\n\\n    private boolean            isDebugEnabled;\\n\\n    \/**\\n     * Initializes a new instance of the {@link StoreConfiguration} class.\\n', '\\n    private final List<Store>  stores            = new ArrayList<Store>();\\n\\n    private Boolean            isDebugEnabled;\\n\\n    \/**\\n     * Initializes a new instance of the {@link StoreConfiguration} class.\\n'], 'diff_1': ['     * Gets a value indicating whether debug output should be enabled.\\n     * @return {@code true} if debug output should be enabled; otherwise, {@code false}.\\n     *\/\\n    public boolean isDebugEnabled() {\\n        return this.isDebugEnabled;\\n    }\\n\\n', '     * Gets a value indicating whether debug output should be enabled.\\n     * @return {@code true} if debug output should be enabled; otherwise, {@code false}.\\n     *\/\\n    public Boolean isDebugEnabled() {\\n        return this.isDebugEnabled;\\n    }\\n\\n']}","subject":"","message":"Change boolean to Boolean for Jenkins 2\n\nThe plugin’s configuration page is not visible in Jenkins 2 without this.\n","lang":"Java","license":"","repos":""}
{"commit":"5cf6d26645672d488bcc558fd1a86188e6d96e97","old_file":"karamel-core\/src\/main\/java\/se\/kth\/karamel\/common\/TextTable.java","new_file":"karamel-core\/src\/main\/java\/se\/kth\/karamel\/common\/TextTable.java","old_contents":"\/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n *\/\npackage se.kth.karamel.common;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang.StringUtils;\n\n\/**\n *\n * @author kamal\n *\/\npublic class TextTable {\n\n  public static String makeTable(String[] columnNames, int sortIndex, Object[][] data, boolean rowNumbering) {\n    StringBuilder builder = new StringBuilder();\n    int[] colLengths = calcColLengths(columnNames, data);\n    int allColsLen = 0;\n    for (int i : colLengths) {\n      allColsLen += i;\n    }\n    int totalLegth = columnNames.length * 1 \/\/column marginal space\n            + (columnNames.length + 1) \/\/pipe lines \n            + allColsLen;  \/\/real data size\n\n    int paddingLen = 0;\n    if (rowNumbering && data.length > 0) {\n      int len = data.length;\n      while (len > 0) {\n        paddingLen++;\n        len \/= 10;\n      }\n    }\n\n    if (rowNumbering) {\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n    }\n\n    \/\/top line _______\n    builder.append(StringUtils.repeat(\"_\", totalLegth));\n\n    builder.append(\"\\n\");\n\n    if (rowNumbering) {\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n    }\n\n    \/\/title row\n    for (int i = 0; i < columnNames.length; i++) {\n      builder.append(String.format(\"| %-\" + colLengths[i] + \"s\", columnNames[i]));\n    }\n\n    builder.append(\"|\"); \/\/closing pipe of the title line\n\n    builder.append(\"\\n\");\n    \/\/botton line =====\n    if (rowNumbering) {\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n    }\n    builder.append(StringUtils.repeat(\"=\", totalLegth));\n    \/\/data rows\n    for (int x = 0; x < data.length; x++) {\n      Object[] row = data[x];\n      builder.append(\"\\n\");\n      if (rowNumbering) {\n        builder.append(String.format(\"%\" + paddingLen + \"d. \", x + 1));\n      }\n      for (int i = 0; i < row.length; i++) {\n        builder.append(String.format(\"| %-\" + colLengths[i] + \"s\", row[i]));\n      }\n\n      builder.append(\"|\"); \/\/closing pipe of the row line\n    }\n    return builder.toString();\n  }\n\n  private static int[] calcColLengths(String[] columnNames, Object[][] data) {\n    int[] columnLengths = new int[columnNames.length];\n\n    for (int i = 0; i < columnNames.length; i++) {\n      String title = columnNames[i];\n      int maxLength = 0;\n      maxLength = maxLength(maxLength, title);\n      for (Object[] data1 : data) {\n        Object cell = data1[i];\n        maxLength = maxLength(maxLength, cell);\n      }\n      columnLengths[i] = maxLength;\n    }\n    return columnLengths;\n  }\n\n  private static int maxLength(int length, Object data) {\n    int l = (data == null) ? 0 : realDataLen(data);\n    return Math.max(l, length);\n  }\n\n  private static Pattern METADATA_PATTERN = Pattern.compile(\"(<a[^>]*>([^<>]*)<\\\\\/a>)\");\n\n  public static int realDataLen(Object data) {\n    if (data == null) {\n      return 0;\n    }\n    String dataString = data.toString();\n    int totalLength = dataString.length();\n    Matcher matcher = METADATA_PATTERN.matcher(dataString);\n    while (matcher.find()) {\n      String withMeta = matcher.group(1);\n      String justData = matcher.group(2);\n      int metaLegth = withMeta.length() - justData.length();\n      totalLength -= metaLegth;\n    }\n    return totalLength;\n  }\n\n}\n","new_contents":"\/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n *\/\npackage se.kth.karamel.common;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\/\/#import org.apache.commons.lang.StringUtils;\n\n\/**\n *\n * @author kamal\n *\/\npublic class TextTable {\n\n  public static String makeTable(String[] columnNames, int sortIndex, Object[][] data, boolean rowNumbering) {\n    StringBuilder builder = new StringBuilder();\n    int[] colLengths = calcColLengths(columnNames, data);\n    int allColsLen = 0;\n    for (int i : colLengths) {\n      allColsLen += i;\n    }\n    int totalLegth = columnNames.length * 1 \/\/column marginal space\n            + (columnNames.length + 1) \/\/pipe lines \n            + allColsLen;  \/\/real data size\n\n    int paddingLen = 0;\n    if (rowNumbering && data.length > 0) {\n      int len = data.length;\n      while (len > 0) {\n        paddingLen++;\n        len \/= 10;\n      }\n    }\n\n    if (rowNumbering) {\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n    }\n\n    \/\/top line _______\n\/\/builder.append(StringUtils.repeat(\"_\", totalLegth));\n\n    builder.append(\"\\n\");\n\n\/\/if (rowNumbering) {\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n\/\/    }\n\n    \/\/title row\n    for (int i = 0; i < columnNames.length; i++) {\n      builder.append(String.format(\"| %-\" + colLengths[i] + \"s\", columnNames[i]));\n    }\n\n    builder.append(\"|\"); \/\/closing pipe of the title line\n\n    builder.append(\"\\n\");\n    \/\/botton line =====\n\/\/    if (rowNumbering) {\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\n\/\/    }\n\/\/    builder.append(StringUtils.repeat(\"=\", totalLegth));\n    \/\/data rows\n    for (int x = 0; x < data.length; x++) {\n      Object[] row = data[x];\n      builder.append(\"\\n\");\n      if (rowNumbering) {\n        builder.append(String.format(\"%\" + paddingLen + \"d. \", x + 1));\n      }\n      for (int i = 0; i < row.length; i++) {\n        builder.append(String.format(\"| %-\" + colLengths[i] + \"s\", row[i]));\n      }\n\n      builder.append(\"|\"); \/\/closing pipe of the row line\n    }\n    return builder.toString();\n  }\n\n  private static int[] calcColLengths(String[] columnNames, Object[][] data) {\n    int[] columnLengths = new int[columnNames.length];\n\n    for (int i = 0; i < columnNames.length; i++) {\n      String title = columnNames[i];\n      int maxLength = 0;\n      maxLength = maxLength(maxLength, title);\n      for (Object[] data1 : data) {\n        Object cell = data1[i];\n        maxLength = maxLength(maxLength, cell);\n      }\n      columnLengths[i] = maxLength;\n    }\n    return columnLengths;\n  }\n\n  private static int maxLength(int length, Object data) {\n    int l = (data == null) ? 0 : realDataLen(data);\n    return Math.max(l, length);\n  }\n\n  private static Pattern METADATA_PATTERN = Pattern.compile(\"(<a[^>]*>([^<>]*)<\\\\\/a>)\");\n\n  public static int realDataLen(Object data) {\n    if (data == null) {\n      return 0;\n    }\n    String dataString = data.toString();\n    int totalLength = dataString.length();\n    Matcher matcher = METADATA_PATTERN.matcher(dataString);\n    while (matcher.find()) {\n      String withMeta = matcher.group(1);\n      String justData = matcher.group(2);\n      int metaLegth = withMeta.length() - justData.length();\n      totalLength -= metaLegth;\n    }\n    return totalLength;\n  }\n\n}\n","code_block_diff":"{'diff_0': ['\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport org.apache.commons.lang.StringUtils;\\n\\n\/**\\n *\\n', '\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\/\/#import org.apache.commons.lang.StringUtils;\\n\\n\/**\\n *\\n'], 'diff_1': ['    }\\n\\n    if (rowNumbering) {\\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n    }\\n\\n    \/\/top line _______\\n    builder.append(StringUtils.repeat(\"_\", totalLegth));\\n\\n    builder.append(\"\\\\n\");\\n\\n    if (rowNumbering) {\\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n    }\\n\\n    \/\/title row\\n    for (int i = 0; i < columnNames.length; i++) {\\n', '    }\\n\\n    if (rowNumbering) {\\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n    }\\n\\n    \/\/top line _______\\n\/\/builder.append(StringUtils.repeat(\"_\", totalLegth));\\n\\n    builder.append(\"\\\\n\");\\n\\n\/\/if (rowNumbering) {\\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n\/\/    }\\n\\n    \/\/title row\\n    for (int i = 0; i < columnNames.length; i++) {\\n'], 'diff_2': ['\\n    builder.append(\"\\\\n\");\\n    \/\/botton line =====\\n    if (rowNumbering) {\\n      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n    }\\n    builder.append(StringUtils.repeat(\"=\", totalLegth));\\n    \/\/data rows\\n    for (int x = 0; x < data.length; x++) {\\n      Object[] row = data[x];\\n', '\\n    builder.append(\"\\\\n\");\\n    \/\/botton line =====\\n\/\/    if (rowNumbering) {\\n\/\/      builder.append(StringUtils.repeat(\" \", paddingLen + 2));\\n\/\/    }\\n\/\/    builder.append(StringUtils.repeat(\"=\", totalLegth));\\n    \/\/data rows\\n    for (int x = 0; x < data.length; x++) {\\n      Object[] row = data[x];\\n']}","subject":"","message":"hotfix to get karamel to build\n\n","lang":"Java","license":"","repos":""}
{"commit":"427f4144ef8ba8564ba49825f4812b923bd6aed1","old_file":"bundle\/src\/main\/java\/com\/shinesolutions\/healthcheck\/hc\/impl\/ActiveBundleHealthCheck.java","new_file":"bundle\/src\/main\/java\/com\/shinesolutions\/healthcheck\/hc\/impl\/ActiveBundleHealthCheck.java","old_contents":"\npackage com.shinesolutions.healthcheck.hc.impl;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.sling.commons.osgi.PropertiesUtil;\nimport org.apache.sling.hc.annotations.SlingHealthCheck;\nimport org.apache.sling.hc.api.HealthCheck;\nimport org.apache.sling.hc.api.Result;\nimport org.apache.sling.hc.util.FormattingResultLog;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.service.component.ComponentContext;\n\nimport java.util.Arrays;\n\n\/**\n * Health Check to test if all Bundles are active.\n *\/\n@SlingHealthCheck(\n        name = \"Bundle Health Check\",\n        mbeanName = \"bundleHC\",\n        description = \"This health check scans the current OSGi bundles and reports if there is any inactive bundles.\",\n        tags = {\"deep\"}\n)\npublic class ActiveBundleHealthCheck implements HealthCheck {\n\n    private BundleContext bundleContext;\n\n    private static final String BUNDLE_FRAGMENT_HOST     = \"Fragment-Host\";\n    private static final String BUNDLE_ACTIVATION_POLICY = \"Bundle-ActivationPolicy\";\n    private static final String LAZY_ACTIVATION_POLICY   = \"lazy\";\n\n    @Property(label = \"Ignored Bundles\", description = \"The bundles that will be ignored in the Active Bundle Health-Check\")\n    protected static final String IGNORED_BUNDLES = \"bundles.ignored\";\n    protected static String[] ignoredBundles;\n\n    @Activate\n    protected void activate(ComponentContext context) {\n        bundleContext = context.getBundleContext();\n        ignoredBundles = PropertiesUtil.toStringArray(context.getProperties().get(IGNORED_BUNDLES));\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        bundleContext = null;\n    }\n\n    @Override\n    public Result execute() {\n        FormattingResultLog resultLog = new FormattingResultLog();\n        int inactiveBundles = 0;\n        Bundle[] bundles = bundleContext.getBundles();\n\n        for (Bundle bundle : bundles) {\n            if ((!isActiveBundle(bundle)) && !isIgnoredBundle(bundle)) {\n                inactiveBundles++;\n                resultLog.warn(\"Bundle {} is not active. It is in state {}.\", bundle.getSymbolicName(), bundle.getState());\n            }\n        }\n\n        if (ignoredBundles != null) {\n            resultLog.debug(\"The following bundles will be ignored: {}\", Arrays.toString(ignoredBundles));\n        }\n\n        if (inactiveBundles > 0) {\n            resultLog.warn(\"There are {} inactive Bundles\", inactiveBundles);\n        } else {\n            resultLog.info(\"All bundles are considered active\");\n        }\n\n        return new Result(resultLog);\n    }\n\n    \/**\n     * Checks whether the provided bundle is in a string Array of ignored bundles.\n     *\n     * @param bundle\n     * @return\n     *\/\n    private static boolean isIgnoredBundle(Bundle bundle) {\n        return (ignoredBundles != null &&\n                Arrays.asList(ignoredBundles).contains(bundle.getSymbolicName()));\n    }\n\n    \/**\n     * Checks whether the provided bundle is active. A bundle is considered active if it meets the following criteria:\n     * - the bundle is active, or\n     * - it is a fragment bundle, or\n     * - it has a lazy activation policy\n     *\n     * @param bundle\n     * @return\n     *\/\n    private static boolean isActiveBundle(Bundle bundle) {\n        return (bundle.getState() == Bundle.ACTIVE ||\n                bundle.getHeaders().get(BUNDLE_FRAGMENT_HOST) != null) ||\n                (bundle.getHeaders().get(BUNDLE_ACTIVATION_POLICY) != null &&\n                        bundle.getHeaders().get(BUNDLE_ACTIVATION_POLICY).equals(LAZY_ACTIVATION_POLICY));\n    }\n}\n","new_contents":"\npackage com.shinesolutions.healthcheck.hc.impl;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.sling.commons.osgi.PropertiesUtil;\nimport org.apache.sling.hc.annotations.SlingHealthCheck;\nimport org.apache.sling.hc.api.HealthCheck;\nimport org.apache.sling.hc.api.Result;\nimport org.apache.sling.hc.util.FormattingResultLog;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.service.component.ComponentContext;\n\nimport java.util.Arrays;\nimport java.util.Dictionary;\n\n\/**\n * Health Check to test if all Bundles are active.\n *\/\n@SlingHealthCheck(\n        name = \"Bundle Health Check\",\n        mbeanName = \"bundleHC\",\n        description = \"This health check scans the current OSGi bundles and reports if there is any inactive bundles.\",\n        tags = {\"deep\"}\n)\npublic class ActiveBundleHealthCheck implements HealthCheck {\n\n    private BundleContext bundleContext;\n\n    private static final String BUNDLE_FRAGMENT_HOST     = \"Fragment-Host\";\n    private static final String BUNDLE_ACTIVATION_POLICY = \"Bundle-ActivationPolicy\";\n    private static final String LAZY_ACTIVATION_POLICY   = \"lazy\";\n\n    @Property(label = \"Ignored Bundles\", description = \"The bundles that will be ignored in the Active Bundle Health-Check\")\n    protected static final String IGNORED_BUNDLES = \"bundles.ignored\";\n    protected String[] ignoredBundles;\n\n    @Activate\n    protected void activate(ComponentContext context) {\n        bundleContext = context.getBundleContext();\n        Dictionary<String, Object> properties = context.getProperties();\n\n        if(properties != null) {\n            ignoredBundles = PropertiesUtil.toStringArray(properties.get(IGNORED_BUNDLES));\n        } else {\n            ignoredBundles = new String[]{};\n        }\n\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        bundleContext = null;\n    }\n\n    @Override\n    public Result execute() {\n        FormattingResultLog resultLog = new FormattingResultLog();\n        int inactiveBundles = 0;\n        Bundle[] bundles = bundleContext.getBundles();\n\n        for (Bundle bundle : bundles) {\n            if ((!isActiveBundle(bundle)) && !isIgnoredBundle(bundle)) {\n                inactiveBundles++;\n                resultLog.warn(\"Bundle {} is not active. It is in state {}.\", bundle.getSymbolicName(), bundle.getState());\n            }\n        }\n\n        if (ignoredBundles != null) {\n            resultLog.debug(\"The following bundles will be ignored: {}\", Arrays.toString(ignoredBundles));\n        }\n\n        if (inactiveBundles > 0) {\n            resultLog.warn(\"There are {} inactive Bundles\", inactiveBundles);\n        } else {\n            resultLog.info(\"All bundles are considered active\");\n        }\n\n        return new Result(resultLog);\n    }\n\n    \/**\n     * Checks whether the provided bundle is in a string Array of ignored bundles.\n     *\n     * @param bundle\n     * @return\n     *\/\n    private boolean isIgnoredBundle(Bundle bundle) {\n        return (ignoredBundles != null &&\n                Arrays.asList(ignoredBundles).contains(bundle.getSymbolicName()));\n    }\n\n    \/**\n     * Checks whether the provided bundle is active. A bundle is considered active if it meets the following criteria:\n     * - the bundle is active, or\n     * - it is a fragment bundle, or\n     * - it has a lazy activation policy\n     *\n     * @param bundle\n     * @return\n     *\/\n    private static boolean isActiveBundle(Bundle bundle) {\n        return (bundle.getState() == Bundle.ACTIVE ||\n                bundle.getHeaders().get(BUNDLE_FRAGMENT_HOST) != null) ||\n                (bundle.getHeaders().get(BUNDLE_ACTIVATION_POLICY) != null &&\n                        bundle.getHeaders().get(BUNDLE_ACTIVATION_POLICY).equals(LAZY_ACTIVATION_POLICY));\n    }\n}\n","code_block_diff":"{'diff_0': ['import org.osgi.service.component.ComponentContext;\\n\\nimport java.util.Arrays;\\n\\n\/**\\n * Health Check to test if all Bundles are active.\\n', 'import org.osgi.service.component.ComponentContext;\\n\\nimport java.util.Arrays;\\nimport java.util.Dictionary;\\n\\n\/**\\n * Health Check to test if all Bundles are active.\\n'], 'diff_1': ['\\n    @Property(label = \"Ignored Bundles\", description = \"The bundles that will be ignored in the Active Bundle Health-Check\")\\n    protected static final String IGNORED_BUNDLES = \"bundles.ignored\";\\n    protected static String[] ignoredBundles;\\n\\n    @Activate\\n    protected void activate(ComponentContext context) {\\n        bundleContext = context.getBundleContext();\\n        ignoredBundles = PropertiesUtil.toStringArray(context.getProperties().get(IGNORED_BUNDLES));\\n    }\\n\\n    @Deactivate\\n', '\\n    @Property(label = \"Ignored Bundles\", description = \"The bundles that will be ignored in the Active Bundle Health-Check\")\\n    protected static final String IGNORED_BUNDLES = \"bundles.ignored\";\\n    protected String[] ignoredBundles;\\n\\n    @Activate\\n    protected void activate(ComponentContext context) {\\n        bundleContext = context.getBundleContext();\\n        Dictionary<String, Object> properties = context.getProperties();\\n\\n        if(properties != null) {\\n            ignoredBundles = PropertiesUtil.toStringArray(properties.get(IGNORED_BUNDLES));\\n        } else {\\n            ignoredBundles = new String[]{};\\n        }\\n\\n    }\\n\\n    @Deactivate\\n'], 'diff_2': ['     * @param bundle\\n     * @return\\n     *\/\\n    private static boolean isIgnoredBundle(Bundle bundle) {\\n        return (ignoredBundles != null &&\\n                Arrays.asList(ignoredBundles).contains(bundle.getSymbolicName()));\\n    }\\n', '     * @param bundle\\n     * @return\\n     *\/\\n    private boolean isIgnoredBundle(Bundle bundle) {\\n        return (ignoredBundles != null &&\\n                Arrays.asList(ignoredBundles).contains(bundle.getSymbolicName()));\\n    }\\n']}","subject":"","message":"* Removed static from ignoredBundles * Added check for when config file is not available\n\n","lang":"Java","license":"","repos":""}
{"commit":"91d7c80ef182948f84703b625805265ef9fd09a2","old_file":"applications\/client\/src\/main\/java\/com\/paritytrading\/parity\/client\/TerminalClient.java","new_file":"applications\/client\/src\/main\/java\/com\/paritytrading\/parity\/client\/TerminalClient.java","old_contents":"package com.paritytrading.parity.client;\n\nimport static org.jvirtanen.util.Applications.*;\n\nimport com.paritytrading.foundation.ASCII;\nimport com.paritytrading.nassau.soupbintcp.SoupBinTCP;\nimport com.paritytrading.parity.client.command.Command;\nimport com.paritytrading.parity.client.command.CommandException;\nimport com.paritytrading.parity.client.command.Commands;\nimport com.paritytrading.parity.client.event.Events;\nimport com.paritytrading.parity.util.Instruments;\nimport com.paritytrading.parity.util.OrderIDGenerator;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigException;\nimport java.io.Closeable;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ClosedChannelException;\nimport java.util.Locale;\nimport java.util.Scanner;\nimport jline.console.ConsoleReader;\nimport jline.console.completer.StringsCompleter;\nimport org.jvirtanen.config.Configs;\n\npublic class TerminalClient implements Closeable {\n\n    public static final Locale LOCALE = Locale.US;\n\n    public static final long NANOS_PER_MILLI = 1_000_000;\n\n    private Events events;\n\n    private OrderEntry orderEntry;\n\n    private Instruments instruments;\n\n    private OrderIDGenerator orderIdGenerator;\n\n    private boolean closed;\n\n    private TerminalClient(Events events, OrderEntry orderEntry, Instruments instruments) {\n        this.events      = events;\n        this.orderEntry  = orderEntry;\n        this.instruments = instruments;\n\n        this.orderIdGenerator = new OrderIDGenerator();\n    }\n\n    public static TerminalClient open(InetSocketAddress address, String username,\n            String password, Instruments instruments) throws IOException {\n        Events events = new Events();\n\n        OrderEntry orderEntry = OrderEntry.open(address, events);\n\n        SoupBinTCP.LoginRequest loginRequest = new SoupBinTCP.LoginRequest();\n\n        ASCII.putLeft(loginRequest.username, username);\n        ASCII.putLeft(loginRequest.password, password);\n        ASCII.putRight(loginRequest.requestedSession, \"\");\n        ASCII.putLongRight(loginRequest.requestedSequenceNumber, 0);\n\n        orderEntry.getTransport().login(loginRequest);\n\n        return new TerminalClient(events, orderEntry, instruments);\n    }\n\n    public OrderEntry getOrderEntry() {\n        return orderEntry;\n    }\n\n    public Instruments getInstruments() {\n        return instruments;\n    }\n\n    public OrderIDGenerator getOrderIdGenerator() {\n        return orderIdGenerator;\n    }\n\n    public Events getEvents() {\n        return events;\n    }\n\n    public void run() throws IOException {\n        ConsoleReader reader = new ConsoleReader();\n\n        reader.addCompleter(new StringsCompleter(Commands.names().castToList()));\n\n        printf(\"Type 'help' for help.\\n\");\n\n        while (!closed) {\n            String line = reader.readLine(\"> \");\n            if (line == null)\n                break;\n\n            Scanner scanner = scan(line);\n\n            if (!scanner.hasNext())\n                continue;\n\n            Command command = Commands.find(scanner.next());\n            if (command == null) {\n                printf(\"error: Unknown command\\n\");\n                continue;\n            }\n\n            try {\n                command.execute(this, scanner);\n            } catch (CommandException e) {\n                printf(\"Usage: %s\\n\", command.getUsage());\n            } catch (ClosedChannelException e) {\n                printf(\"error: Connection closed\\n\");\n            }\n        }\n\n        close();\n    }\n\n    @Override\n    public void close() {\n        orderEntry.close();\n\n        closed = true;\n    }\n\n    public void printf(String format, Object... args) {\n        System.out.printf(LOCALE, format, args);\n    }\n\n    private Scanner scan(String text) {\n        Scanner scanner = new Scanner(text);\n        scanner.useLocale(LOCALE);\n\n        return scanner;\n    }\n\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1)\n            usage(\"parity-client <configuration-file>\");\n\n        try {\n            main(config(args[0]));\n        } catch (ConfigException | FileNotFoundException e) {\n            error(e);\n        }\n    }\n\n    private static void main(Config config) throws IOException {\n        InetAddress orderEntryAddress  = Configs.getInetAddress(config, \"order-entry.address\");\n        int         orderEntryPort     = Configs.getPort(config, \"order-entry.port\");\n        String      orderEntryUsername = config.getString(\"order-entry.username\");\n        String      orderEntryPassword = config.getString(\"order-entry.password\");\n\n        Instruments instruments = Instruments.fromConfig(config, \"instruments\");\n\n        TerminalClient.open(new InetSocketAddress(orderEntryAddress, orderEntryPort),\n                orderEntryUsername, orderEntryPassword, instruments).run();\n    }\n\n}\n","new_contents":"package com.paritytrading.parity.client;\n\nimport static org.jvirtanen.util.Applications.*;\n\nimport com.paritytrading.foundation.ASCII;\nimport com.paritytrading.nassau.soupbintcp.SoupBinTCP;\nimport com.paritytrading.parity.client.command.Command;\nimport com.paritytrading.parity.client.command.CommandException;\nimport com.paritytrading.parity.client.command.Commands;\nimport com.paritytrading.parity.client.event.Events;\nimport com.paritytrading.parity.util.Instruments;\nimport com.paritytrading.parity.util.OrderIDGenerator;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigException;\nimport java.io.Closeable;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ClosedChannelException;\nimport java.util.Locale;\nimport java.util.Scanner;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.completer.StringsCompleter;\nimport org.jvirtanen.config.Configs;\n\npublic class TerminalClient implements Closeable {\n\n    public static final Locale LOCALE = Locale.US;\n\n    public static final long NANOS_PER_MILLI = 1_000_000;\n\n    private Events events;\n\n    private OrderEntry orderEntry;\n\n    private Instruments instruments;\n\n    private OrderIDGenerator orderIdGenerator;\n\n    private boolean closed;\n\n    private TerminalClient(Events events, OrderEntry orderEntry, Instruments instruments) {\n        this.events      = events;\n        this.orderEntry  = orderEntry;\n        this.instruments = instruments;\n\n        this.orderIdGenerator = new OrderIDGenerator();\n    }\n\n    public static TerminalClient open(InetSocketAddress address, String username,\n            String password, Instruments instruments) throws IOException {\n        Events events = new Events();\n\n        OrderEntry orderEntry = OrderEntry.open(address, events);\n\n        SoupBinTCP.LoginRequest loginRequest = new SoupBinTCP.LoginRequest();\n\n        ASCII.putLeft(loginRequest.username, username);\n        ASCII.putLeft(loginRequest.password, password);\n        ASCII.putRight(loginRequest.requestedSession, \"\");\n        ASCII.putLongRight(loginRequest.requestedSequenceNumber, 0);\n\n        orderEntry.getTransport().login(loginRequest);\n\n        return new TerminalClient(events, orderEntry, instruments);\n    }\n\n    public OrderEntry getOrderEntry() {\n        return orderEntry;\n    }\n\n    public Instruments getInstruments() {\n        return instruments;\n    }\n\n    public OrderIDGenerator getOrderIdGenerator() {\n        return orderIdGenerator;\n    }\n\n    public Events getEvents() {\n        return events;\n    }\n\n    public void run() throws IOException {\n        LineReader reader = LineReaderBuilder.builder()\n            .completer(new StringsCompleter(Commands.names().castToList()))\n            .build();\n\n        printf(\"Type 'help' for help.\\n\");\n\n        while (!closed) {\n            String line = reader.readLine(\"> \");\n            if (line == null)\n                break;\n\n            Scanner scanner = scan(line);\n\n            if (!scanner.hasNext())\n                continue;\n\n            Command command = Commands.find(scanner.next());\n            if (command == null) {\n                printf(\"error: Unknown command\\n\");\n                continue;\n            }\n\n            try {\n                command.execute(this, scanner);\n            } catch (CommandException e) {\n                printf(\"Usage: %s\\n\", command.getUsage());\n            } catch (ClosedChannelException e) {\n                printf(\"error: Connection closed\\n\");\n            }\n        }\n\n        close();\n    }\n\n    @Override\n    public void close() {\n        orderEntry.close();\n\n        closed = true;\n    }\n\n    public void printf(String format, Object... args) {\n        System.out.printf(LOCALE, format, args);\n    }\n\n    private Scanner scan(String text) {\n        Scanner scanner = new Scanner(text);\n        scanner.useLocale(LOCALE);\n\n        return scanner;\n    }\n\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1)\n            usage(\"parity-client <configuration-file>\");\n\n        try {\n            main(config(args[0]));\n        } catch (ConfigException | FileNotFoundException e) {\n            error(e);\n        }\n    }\n\n    private static void main(Config config) throws IOException {\n        InetAddress orderEntryAddress  = Configs.getInetAddress(config, \"order-entry.address\");\n        int         orderEntryPort     = Configs.getPort(config, \"order-entry.port\");\n        String      orderEntryUsername = config.getString(\"order-entry.username\");\n        String      orderEntryPassword = config.getString(\"order-entry.password\");\n\n        Instruments instruments = Instruments.fromConfig(config, \"instruments\");\n\n        TerminalClient.open(new InetSocketAddress(orderEntryAddress, orderEntryPort),\n                orderEntryUsername, orderEntryPassword, instruments).run();\n    }\n\n}\n","code_block_diff":"{'diff_0': ['import java.nio.channels.ClosedChannelException;\\nimport java.util.Locale;\\nimport java.util.Scanner;\\nimport jline.console.ConsoleReader;\\nimport jline.console.completer.StringsCompleter;\\nimport org.jvirtanen.config.Configs;\\n\\npublic class TerminalClient implements Closeable {\\n', 'import java.nio.channels.ClosedChannelException;\\nimport java.util.Locale;\\nimport java.util.Scanner;\\nimport org.jline.reader.LineReader;\\nimport org.jline.reader.LineReaderBuilder;\\nimport org.jline.reader.impl.completer.StringsCompleter;\\nimport org.jvirtanen.config.Configs;\\n\\npublic class TerminalClient implements Closeable {\\n'], 'diff_1': ['    }\\n\\n    public void run() throws IOException {\\n        ConsoleReader reader = new ConsoleReader();\\n\\n        reader.addCompleter(new StringsCompleter(Commands.names().castToList()));\\n\\n        printf(\"Type \\'help\\' for help.\\\\n\");\\n\\n', '    }\\n\\n    public void run() throws IOException {\\n        LineReader reader = LineReaderBuilder.builder()\\n            .completer(new StringsCompleter(Commands.names().castToList()))\\n            .build();\\n\\n        printf(\"Type \\'help\\' for help.\\\\n\");\\n\\n']}","subject":"","message":"JLine 3 migration.\n\n","lang":"Java","license":"","repos":""}
{"commit":"23ad57d8ff1e6f95c9f80a297d47f00a662eff30","old_file":"reark\/src\/main\/java\/io\/reark\/reark\/data\/stores\/cores\/MemoryStoreCore.java","new_file":"reark\/src\/main\/java\/io\/reark\/reark\/data\/stores\/cores\/MemoryStoreCore.java","old_contents":"\/*\n * The MIT License\n *\n * Copyright (c) 2013-2016 reark project contributors\n *\n * https:\/\/github.com\/reark\/reark\/graphs\/contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage io.reark.reark.data.stores.cores;\n\nimport android.support.annotation.NonNull;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport io.reactivex.Maybe;\nimport io.reactivex.Observable;\nimport io.reactivex.Single;\nimport io.reactivex.functions.BiFunction;\nimport io.reactivex.subjects.PublishSubject;\nimport io.reactivex.subjects.Subject;\nimport io.reark.reark.data.stores.StoreItem;\nimport io.reark.reark.data.stores.interfaces.StoreCoreInterface;\nimport io.reark.reark.utils.Log;\n\nimport static io.reark.reark.utils.Preconditions.checkNotNull;\nimport static io.reark.reark.utils.Preconditions.get;\n\n\/**\n * A simple StoreCore that only uses an in-memory ConcurrentHashMap to persist the data. This means\n * that the MemoryStoreCore cannot be shared across Android processes and it will be destroyed with\n * the app.\n *\n * @param <T> Type of the id used in this store core.\n * @param <U> Type of the data this store core contains.\n *\/\npublic class MemoryStoreCore<T, U> implements StoreCoreInterface<T, U> {\n    private static final String TAG = MemoryStoreCore.class.getSimpleName();\n\n    @NonNull\n    private final BiFunction<U, U, U> putMergeFunction;\n\n    @NonNull\n    private final Map<Integer, U> cache = new ConcurrentHashMap<>(10);\n\n    @NonNull\n    private final PublishSubject<StoreItem<T, U>> subject = PublishSubject.create();\n\n    @NonNull\n    private final ConcurrentMap<Integer, Subject<U>> subjectCache = new ConcurrentHashMap<>(20, 0.75f, 4);\n\n    public MemoryStoreCore() {\n        this((v1, v2) -> v2);\n    }\n\n    public MemoryStoreCore(@NonNull final BiFunction<U, U, U> putMergeFunction) {\n        this.putMergeFunction = get(putMergeFunction);\n    }\n\n    @NonNull\n    @Override\n    public Maybe<U> getCached(@NonNull final T id) {\n        checkNotNull(id);\n\n        final U value = cache.get(getHashCodeForId(id));\n\n        return value == null\n                ? Maybe.empty()\n                : Maybe.just(value);\n    }\n\n    @NonNull\n    @Override\n    public Single<List<U>> getCached() {\n        return Observable.fromIterable(() -> cache.keySet().iterator())\n                .map(cache::get)\n                .toList();\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream(@NonNull final T id) {\n        checkNotNull(id);\n\n        int hash = getHashCodeForId(id);\n        subjectCache.putIfAbsent(hash, PublishSubject.create());\n\n        return subjectCache.get(hash);\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream() {\n        return subject.map(StoreItem::item);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> put(@NonNull final T id, @NonNull final U item) {\n        checkNotNull(id);\n        checkNotNull(item);\n\n        final int hash = getHashCodeForId(id);\n        U newItem = item;\n        boolean valuesEqual = false;\n\n        if (cache.containsKey(hash)) {\n            final U currentItem = cache.get(hash);\n\n            valuesEqual = newItem.equals(currentItem);\n\n            if (!valuesEqual) {\n                Log.v(TAG, \"Merging values at \" + id);\n                try {\n                    newItem = putMergeFunction.apply(currentItem, newItem);\n                } catch (Exception e) {\n                    return Single.error(e);\n                }\n                valuesEqual = newItem.equals(currentItem);\n            }\n        }\n\n        if (valuesEqual) {\n            Log.v(TAG, \"Data already up to date at \" + id);\n            return Single.just(false);\n        }\n\n        cache.put(hash, newItem);\n        subject.onNext(new StoreItem<>(id, newItem));\n\n        if (subjectCache.containsKey(hash)) {\n            subjectCache.get(hash).onNext(newItem);\n        }\n\n        return Single.just(true);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> delete(@NonNull final T id) {\n        return Single.fromCallable(() -> cache.remove(getHashCodeForId(id)) != null);\n    }\n\n    protected int getHashCodeForId(@NonNull final T id) {\n        checkNotNull(id);\n\n        return id.hashCode();\n    }\n}\n","new_contents":"\/*\n * The MIT License\n *\n * Copyright (c) 2013-2016 reark project contributors\n *\n * https:\/\/github.com\/reark\/reark\/graphs\/contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage io.reark.reark.data.stores.cores;\n\nimport android.support.annotation.NonNull;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport io.reactivex.Maybe;\nimport io.reactivex.Observable;\nimport io.reactivex.Single;\nimport io.reactivex.functions.BiFunction;\nimport io.reactivex.subjects.PublishSubject;\nimport io.reactivex.subjects.Subject;\nimport io.reark.reark.data.stores.StoreItem;\nimport io.reark.reark.data.stores.interfaces.StoreCoreInterface;\nimport io.reark.reark.utils.Log;\n\nimport static io.reark.reark.utils.Preconditions.checkNotNull;\nimport static io.reark.reark.utils.Preconditions.get;\n\n\/**\n * A simple StoreCore that only uses an in-memory ConcurrentHashMap to persist the data. This means\n * that the MemoryStoreCore cannot be shared across Android processes and it will be destroyed with\n * the app.\n *\n * @param <T> Type of the id used in this store core.\n * @param <U> Type of the data this store core contains.\n *\/\npublic class MemoryStoreCore<T, U> implements StoreCoreInterface<T, U> {\n    private static final String TAG = MemoryStoreCore.class.getSimpleName();\n\n    @NonNull\n    private final BiFunction<U, U, U> putMergeFunction;\n\n    @NonNull\n    private final Map<Integer, U> cache = new ConcurrentHashMap<>(10);\n\n    @NonNull\n    private final PublishSubject<StoreItem<T, U>> subject = PublishSubject.create();\n\n    @NonNull\n    private final ConcurrentMap<Integer, Subject<U>> subjectCache = new ConcurrentHashMap<>(20, 0.75f, 4);\n\n    public MemoryStoreCore() {\n        this((v1, v2) -> v2);\n    }\n\n    public MemoryStoreCore(@NonNull final BiFunction<U, U, U> putMergeFunction) {\n        this.putMergeFunction = get(putMergeFunction);\n    }\n\n    @NonNull\n    @Override\n    public Maybe<U> getCached(@NonNull final T id) {\n        checkNotNull(id);\n\n        final U value = cache.get(getHashCodeForId(id));\n\n        return value == null\n                ? Maybe.empty()\n                : Maybe.just(value);\n    }\n\n    @NonNull\n    @Override\n    public Single<List<U>> getCached() {\n        return Observable.fromIterable(cache.keySet())\n                .map(cache::get)\n                .toList();\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream(@NonNull final T id) {\n        checkNotNull(id);\n\n        int hash = getHashCodeForId(id);\n        subjectCache.putIfAbsent(hash, PublishSubject.create());\n\n        return subjectCache.get(hash);\n    }\n\n    @NonNull\n    @Override\n    public Observable<U> getStream() {\n        return subject.map(StoreItem::item);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> put(@NonNull final T id, @NonNull final U item) {\n        checkNotNull(id);\n        checkNotNull(item);\n\n        final int hash = getHashCodeForId(id);\n        U newItem = item;\n        boolean valuesEqual = false;\n\n        if (cache.containsKey(hash)) {\n            final U currentItem = cache.get(hash);\n\n            valuesEqual = newItem.equals(currentItem);\n\n            if (!valuesEqual) {\n                Log.v(TAG, \"Merging values at \" + id);\n                try {\n                    newItem = putMergeFunction.apply(currentItem, newItem);\n                } catch (Exception e) {\n                    return Single.error(e);\n                }\n                valuesEqual = newItem.equals(currentItem);\n            }\n        }\n\n        if (valuesEqual) {\n            Log.v(TAG, \"Data already up to date at \" + id);\n            return Single.just(false);\n        }\n\n        cache.put(hash, newItem);\n        subject.onNext(new StoreItem<>(id, newItem));\n\n        if (subjectCache.containsKey(hash)) {\n            subjectCache.get(hash).onNext(newItem);\n        }\n\n        return Single.just(true);\n    }\n\n    @NonNull\n    @Override\n    public Single<Boolean> delete(@NonNull final T id) {\n        return Single.fromCallable(() -> cache.remove(getHashCodeForId(id)) != null);\n    }\n\n    protected int getHashCodeForId(@NonNull final T id) {\n        checkNotNull(id);\n\n        return id.hashCode();\n    }\n}\n","code_block_diff":"{'diff_0': ['    @NonNull\\n    @Override\\n    public Single<List<U>> getCached() {\\n        return Observable.fromIterable(() -> cache.keySet().iterator())\\n                .map(cache::get)\\n                .toList();\\n    }\\n', '    @NonNull\\n    @Override\\n    public Single<List<U>> getCached() {\\n        return Observable.fromIterable(cache.keySet())\\n                .map(cache::get)\\n                .toList();\\n    }\\n']}","subject":"","message":"No need to explicitly get the iterator\n\n","lang":"Java","license":"","repos":""}
{"commit":"c3ac4797a4b2d34d031ef5fe07761417a876ffb7","old_file":"core\/src\/main\/java\/com\/nuodb\/migrator\/jdbc\/metadata\/inspector\/MySQLIndexInspector.java","new_file":"core\/src\/main\/java\/com\/nuodb\/migrator\/jdbc\/metadata\/inspector\/MySQLIndexInspector.java","old_contents":"\/**\n * Copyright (c) 2014, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.jdbc.metadata.inspector;\n\nimport static com.google.common.collect.Lists.newArrayList;\nimport static com.nuodb.migrator.jdbc.query.QueryUtils.union;\nimport static com.nuodb.migrator.utils.StringUtils.isEmpty;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.slf4j.Logger;\n\nimport com.nuodb.migrator.jdbc.metadata.Index;\nimport com.nuodb.migrator.jdbc.query.ParameterizedQuery;\nimport com.nuodb.migrator.jdbc.query.Query;\nimport com.nuodb.migrator.jdbc.query.SelectQuery;\nimport com.nuodb.migrator.utils.StringUtils;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class MySQLIndexInspector extends SimpleIndexInspector {\n\n    private static final String PRIMARY = \"PRIMARY\";\n    \n    @Override\n    protected void processIndex(InspectionContext inspectionContext, ResultSet indexes,\n                                Index index) throws SQLException {\n        super.processIndex(inspectionContext, indexes, index);\n        if (StringUtils.equals(index.getName(), PRIMARY)) {\n            index.setPrimary(true);\n        }\n        \/* Extract the Index type from result set. *\/\n        index.setType(indexes.getString(\"INDEX_TYPE\"));\n    }\n\n    \/** \n    * This method is overridden to build a query to fetch information from MySQL \n    * INFORMATION_SCHEMA.STATISTICS and INFORMATION_SCHEMA.COLUMNS tables including \n    * all index types\n    *\/\n    @Override\n    protected Query createQuery(InspectionContext inspectionContext, TableInspectionScope tableInspectionScope) {\n        SelectQuery statisticsIndex = new SelectQuery();\n        Collection<String> parameters = newArrayList();\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\" ,\" C.ORDINAL_POSITION\" , \"S.COLUMN_NAME\" ,\"S.COLLATION AS ASC_OR_DESC\",\n                \"S.CARDINALITY\", \"S.SUB_PART\",\"NULL AS FILTER_CONDITION\");\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\n        String schema = tableInspectionScope.getCatalog();\n        if (!isEmpty(schema)) {\n            statisticsIndex.where(\"S.TABLE_SCHEMA=?\");\n            parameters.add(schema);\n        }\n        String table = tableInspectionScope.getTable();\n        if (!isEmpty(table)) {\n            statisticsIndex.where(\"S.TABLE_NAME=?\");\n            parameters.add(table);\n        }\n         return new ParameterizedQuery(union(statisticsIndex, null), parameters);\n    }\n}\n\n","new_contents":"\/**\n * Copyright (c) 2014, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.jdbc.metadata.inspector;\n\nimport static com.google.common.collect.Lists.newArrayList;\nimport static com.nuodb.migrator.jdbc.query.QueryUtils.union;\nimport static com.nuodb.migrator.utils.StringUtils.isEmpty;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.slf4j.Logger;\n\nimport com.nuodb.migrator.jdbc.metadata.Index;\nimport com.nuodb.migrator.jdbc.query.ParameterizedQuery;\nimport com.nuodb.migrator.jdbc.query.Query;\nimport com.nuodb.migrator.jdbc.query.SelectQuery;\nimport com.nuodb.migrator.utils.StringUtils;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class MySQLIndexInspector extends SimpleIndexInspector {\n\n    private static final String PRIMARY = \"PRIMARY\";\n    \n    @Override\n    protected void processIndex(InspectionContext inspectionContext, ResultSet indexes,\n                                Index index) throws SQLException {\n        super.processIndex(inspectionContext, indexes, index);\n        if (StringUtils.equals(index.getName(), PRIMARY)) {\n            index.setPrimary(true);\n        }\n        \/* Extract the Index type from result set. *\/\n        index.setType(indexes.getString(\"INDEX_TYPE\"));\n    }\n\n    \/** \n    * This method is overridden to build a query to fetch information from MySQL \n    * INFORMATION_SCHEMA.STATISTICS and INFORMATION_SCHEMA.COLUMNS tables including \n    * all index types\n    *\/\n    @Override\n    protected Query createQuery(InspectionContext inspectionContext, TableInspectionScope tableInspectionScope) {\n        SelectQuery statisticsIndex = new SelectQuery();\n        Collection<String> parameters = newArrayList();\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\", \"S.SEQ_IN_INDEX AS ORDINAL_POSITION\", \"S.COLUMN_NAME\", \"S.COLLATION AS ASC_OR_DESC\",\n                \"S.CARDINALITY\", \"S.SUB_PART\", \"NULL AS FILTER_CONDITION\");\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\n        String schema = tableInspectionScope.getCatalog();\n        if (!isEmpty(schema)) {\n            statisticsIndex.where(\"S.TABLE_SCHEMA=?\");\n            parameters.add(schema);\n        }\n        String table = tableInspectionScope.getTable();\n        if (!isEmpty(table)) {\n            statisticsIndex.where(\"S.TABLE_NAME=?\");\n            parameters.add(table);\n        }\n        statisticsIndex.orderBy(\"INDEX_NAME\", \"SEQ_IN_INDEX\");\n        return new ParameterizedQuery(union(statisticsIndex, null), parameters);\n    }\n}\n\n","code_block_diff":"{'diff_0': ['        SelectQuery statisticsIndex = new SelectQuery();\\n        Collection<String> parameters = newArrayList();\\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\" ,\" C.ORDINAL_POSITION\" , \"S.COLUMN_NAME\" ,\"S.COLLATION AS ASC_OR_DESC\",\\n                \"S.CARDINALITY\", \"S.SUB_PART\",\"NULL AS FILTER_CONDITION\");\\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\\n', '        SelectQuery statisticsIndex = new SelectQuery();\\n        Collection<String> parameters = newArrayList();\\n        statisticsIndex.columns(\"S.TABLE_CATALOG \", \"S.TABLE_SCHEMA AS TABLE_CAT \",\"NULL AS TABLE_SCHEM \" , \"S.TABLE_NAME\", \"S.NON_UNIQUE\",\\n                \"S.INDEX_SCHEMA\",\"S.INDEX_NAME\",\"S.INDEX_TYPE\",\"1 AS TYPE\", \"S.SEQ_IN_INDEX AS ORDINAL_POSITION\", \"S.COLUMN_NAME\", \"S.COLLATION AS ASC_OR_DESC\",\\n                \"S.CARDINALITY\", \"S.SUB_PART\", \"NULL AS FILTER_CONDITION\");\\n        statisticsIndex.from(\"INFORMATION_SCHEMA.STATISTICS S\");\\n        statisticsIndex.join(\"INFORMATION_SCHEMA.COLUMNS C\",\\n                \"C.COLUMN_NAME = S.COLUMN_NAME AND C.TABLE_NAME = S.TABLE_NAME AND S.TABLE_SCHEMA = C.TABLE_SCHEMA\");\\n'], 'diff_1': ['            statisticsIndex.where(\"S.TABLE_NAME=?\");\\n            parameters.add(table);\\n        }\\n         return new ParameterizedQuery(union(statisticsIndex, null), parameters);\\n    }\\n}\\n\\n', '            statisticsIndex.where(\"S.TABLE_NAME=?\");\\n            parameters.add(table);\\n        }\\n        statisticsIndex.orderBy(\"INDEX_NAME\", \"SEQ_IN_INDEX\");\\n        return new ParameterizedQuery(union(statisticsIndex, null), parameters);\\n    }\\n}\\n\\n']}","subject":"","message":"MIG-138 : migrator created an index from mysql migration with columns that are not in the same order sequence\n\n","lang":"Java","license":"","repos":""}
{"commit":"1f99e9832d7b89dea467e8bd0de13190769d5402","old_file":"core\/src\/test\/java\/com\/nuodb\/migrator\/dump\/DumpJobTest.java","new_file":"core\/src\/test\/java\/com\/nuodb\/migrator\/dump\/DumpJobTest.java","old_contents":"\/**\n * Copyright (c) 2015, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.dump;\n\nimport com.nuodb.migrator.backup.writer.BackupWriter;\nimport com.nuodb.migrator.backup.format.FormatFactory;\nimport com.nuodb.migrator.backup.format.value.ValueFormatRegistryResolver;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProvider;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProviderFactory;\nimport com.nuodb.migrator.jdbc.dialect.Dialect;\nimport com.nuodb.migrator.jdbc.dialect.DialectResolver;\nimport com.nuodb.migrator.jdbc.dialect.NuoDBDialect;\nimport com.nuodb.migrator.jdbc.metadata.Column;\nimport com.nuodb.migrator.jdbc.metadata.Database;\nimport com.nuodb.migrator.jdbc.metadata.DatabaseInfo;\nimport com.nuodb.migrator.jdbc.metadata.Table;\nimport com.nuodb.migrator.jdbc.metadata.inspector.InspectionManager;\nimport com.nuodb.migrator.job.JobExecution;\nimport com.nuodb.migrator.job.JobExecutor;\nimport com.nuodb.migrator.spec.DumpJobSpec;\nimport org.mockito.*;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Types;\nimport java.util.Map;\n\nimport static com.google.common.collect.Maps.newHashMap;\nimport static com.nuodb.migrator.jdbc.metadata.Identifier.EMPTY;\nimport static com.nuodb.migrator.job.JobExecutors.createJobExecutor;\nimport static org.mockito.BDDMockito.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNull;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class DumpJobTest {\n\n    @Mock\n    private InspectionManager inspectionManager;\n    @Mock\n    private ConnectionProvider connectionProvider;\n    @Mock\n    private ConnectionProviderFactory connectionProviderFactory;\n    @Mock\n    private DialectResolver dialectResolver;\n    @Mock\n    private FormatFactory formatFactory;\n    @Mock\n    private ValueFormatRegistryResolver valueFormatRegistryResolver;\n    @Mock\n    private Dialect dialect;\n    @Mock\n    private Connection connection;\n\n\n    private JobExecutor jobExecutor;\n    private Map<Object, Object> jobContext;\n\n    @Spy\n    @InjectMocks\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\n\/\/    @Spy\n\/\/    @InjectMocks\n\/\/    private BackupWriter backupWriter = new BackupWriter();\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        DatabaseMetaData databaseMetaData = mock(DatabaseMetaData.class);\n        given(databaseMetaData.getDatabaseProductName()).willReturn(\"NuoDB\");\n        given(connection.getMetaData()).willReturn(databaseMetaData);\n\n        willDoNothing().given(dumpJob).init();\n        willDoNothing().given(dumpJob).execute();\n\n        jobContext = newHashMap();\n        jobExecutor = createJobExecutor(dumpJob);\n    }\n\n    @Test\n    public void validateConnectionProvider() throws Exception {\n        dumpJob.setConnectionProviderFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateDialectResolver() throws Exception {\n        dumpJob.setDialectResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateValueFormatRegistryResolver() throws Exception {\n        dumpJob.setValueFormatRegistryResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateFormatFactory() throws Exception {\n        dumpJob.setFormatFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    private void verifyInit() throws Exception {\n        assertNull(jobExecutor.getJobStatus().getFailure());\n        verify(dumpJob).init(any(JobExecution.class));\n        verify(dumpJob, times(1)).execute();\n    }\n\n    @Test\n    public void testExecuteInSession() throws Throwable {\n        Database database = new Database();\n        database.setDialect(new NuoDBDialect(new DatabaseInfo(\"NuoDB\")));\n\n        Table table = database.addCatalog(EMPTY).addSchema(\"schema\").addTable(\"table\");\n        Column column1 = table.addColumn(\"column1\");\n        column1.setTypeCode(Types.BIGINT);\n        Column column2 = table.addColumn(\"column2\");\n        column2.setTypeCode(Types.LONGVARCHAR);\n\n        BackupWriter backupWriter = Mockito.mock(BackupWriter.class);\n        willReturn(backupWriter).given(dumpJob).getBackupWriter();\n\n        jobExecutor.execute(jobContext);\n\n        Throwable failure = jobExecutor.getJobStatus().getFailure();\n        if (failure != null) {\n            throw failure;\n        }\n    }\n}\n","new_contents":"\/**\n * Copyright (c) 2015, NuoDB, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and\/or other materials provided with the distribution.\n *     * Neither the name of NuoDB, Inc. nor the names of its contributors may\n *       be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage com.nuodb.migrator.dump;\n\nimport com.nuodb.migrator.backup.writer.BackupWriter;\nimport com.nuodb.migrator.backup.format.FormatFactory;\nimport com.nuodb.migrator.backup.format.value.ValueFormatRegistryResolver;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProvider;\nimport com.nuodb.migrator.jdbc.connection.ConnectionProviderFactory;\nimport com.nuodb.migrator.jdbc.dialect.Dialect;\nimport com.nuodb.migrator.jdbc.dialect.DialectResolver;\nimport com.nuodb.migrator.jdbc.dialect.NuoDBDialect;\nimport com.nuodb.migrator.jdbc.metadata.Column;\nimport com.nuodb.migrator.jdbc.metadata.Database;\nimport com.nuodb.migrator.jdbc.metadata.DatabaseInfo;\nimport com.nuodb.migrator.jdbc.metadata.Table;\nimport com.nuodb.migrator.jdbc.metadata.inspector.InspectionManager;\nimport com.nuodb.migrator.job.JobExecution;\nimport com.nuodb.migrator.job.JobExecutor;\nimport com.nuodb.migrator.spec.DumpJobSpec;\nimport org.mockito.*;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Types;\nimport java.util.Map;\n\nimport static com.google.common.collect.Maps.newHashMap;\nimport static com.nuodb.migrator.jdbc.metadata.Identifier.EMPTY;\nimport static com.nuodb.migrator.job.JobExecutors.createJobExecutor;\nimport static org.mockito.BDDMockito.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport static org.testng.Assert.assertNotNull;\nimport static org.testng.Assert.assertNull;\n\n\/**\n * @author Sergey Bushik\n *\/\npublic class DumpJobTest {\n\n    @Mock\n    private InspectionManager inspectionManager;\n    @Mock\n    private ConnectionProvider connectionProvider;\n    @Mock\n    private ConnectionProviderFactory connectionProviderFactory;\n    @Mock\n    private DialectResolver dialectResolver;\n    @Mock\n    private FormatFactory formatFactory;\n    @Mock\n    private ValueFormatRegistryResolver valueFormatRegistryResolver;\n    @Mock\n    private Dialect dialect;\n    @Mock\n    private Connection connection;\n    @Spy\n    @InjectMocks\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\n\n\n    private JobExecutor jobExecutor;\n    private Map<Object, Object> jobContext;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        DatabaseMetaData databaseMetaData = mock(DatabaseMetaData.class);\n        given(databaseMetaData.getDatabaseProductName()).willReturn(\"NuoDB\");\n        given(connection.getMetaData()).willReturn(databaseMetaData);\n\n        willDoNothing().given(dumpJob).init();\n        willDoNothing().given(dumpJob).execute();\n\n        jobContext = newHashMap();\n        jobExecutor = createJobExecutor(dumpJob);\n    }\n\n    @Test\n    public void validateConnectionProvider() throws Exception {\n        dumpJob.setConnectionProviderFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateDialectResolver() throws Exception {\n        dumpJob.setDialectResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateValueFormatRegistryResolver() throws Exception {\n        dumpJob.setValueFormatRegistryResolver(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    @Test\n    public void validateFormatFactory() throws Exception {\n        dumpJob.setFormatFactory(null);\n        jobExecutor.execute(jobContext);\n        verifyInit();\n    }\n\n    private void verifyInit() throws Exception {\n        assertNull(jobExecutor.getJobStatus().getFailure());\n        verify(dumpJob).init(any(JobExecution.class));\n        verify(dumpJob, times(1)).execute();\n    }\n\n    @Test\n    public void testExecuteInSession() throws Throwable {\n        Database database = new Database();\n        database.setDialect(new NuoDBDialect(new DatabaseInfo(\"NuoDB\")));\n\n        Table table = database.addCatalog(EMPTY).addSchema(\"schema\").addTable(\"table\");\n        Column column1 = table.addColumn(\"column1\");\n        column1.setTypeCode(Types.BIGINT);\n        Column column2 = table.addColumn(\"column2\");\n        column2.setTypeCode(Types.LONGVARCHAR);\n\n        BackupWriter backupWriter = Mockito.mock(BackupWriter.class);\n        willReturn(backupWriter).given(dumpJob).getBackupWriter();\n\n        jobExecutor.execute(jobContext);\n\n        Throwable failure = jobExecutor.getJobStatus().getFailure();\n        if (failure != null) {\n            throw failure;\n        }\n    }\n}\n","code_block_diff":"{'diff_0': ['    private Dialect dialect;\\n    @Mock\\n    private Connection connection;\\n\\n\\n    private JobExecutor jobExecutor;\\n    private Map<Object, Object> jobContext;\\n\\n    @Spy\\n    @InjectMocks\\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\\n\/\/    @Spy\\n\/\/    @InjectMocks\\n\/\/    private BackupWriter backupWriter = new BackupWriter();\\n\\n    @BeforeMethod\\n    public void setUp() throws Exception {\\n        MockitoAnnotations.initMocks(this);\\n', '    private Dialect dialect;\\n    @Mock\\n    private Connection connection;\\n    @Spy\\n    @InjectMocks\\n    private DumpJob dumpJob = new DumpJob(new DumpJobSpec());\\n\\n\\n    private JobExecutor jobExecutor;\\n    private Map<Object, Object> jobContext;\\n\\n    @BeforeMethod\\n    public void setUp() throws Exception {\\n        MockitoAnnotations.initMocks(this);\\n']}","subject":"","message":"Removing dead code\n\n","lang":"Java","license":"","repos":""}
{"commit":"30b35b28def049ccff58a79846af5e9258a7848f","old_file":"space-server\/src\/test\/java\/com\/space\/server\/engine\/impl\/ServerEngineImplTest.java","new_file":"space-server\/src\/test\/java\/com\/space\/server\/engine\/impl\/ServerEngineImplTest.java","old_contents":"package com.space.server.engine.impl;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport com.space.server.domain.api.SpaceWorld;\nimport com.space.server.engine.api.GameEngine;\nimport com.space.server.engine.api.WorldEvent;\nimport com.space.server.engine.api.WorldEventType;\nimport org.eclipse.jetty.websocket.api.RemoteEndpoint;\nimport org.eclipse.jetty.websocket.api.Session;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n\/**\n * Created by superernie77 on 11.02.2017.\n *\/\npublic class ServerEngineImplTest {\n\n    private ServerEngineImpl serverEngine;\n\n    private GameEngine gameEngine;\n\n    private ScheduledExecutorService executorService;\n\n    @Before\n    public void setup(){\n        serverEngine = new ServerEngineImpl();\n\n        gameEngine = mock(GameEngine.class);\n\n        executorService = mock(ScheduledExecutorService.class);\n        when(executorService.scheduleAtFixedRate(any(Runnable.class),anyLong(),anyLong(),any(TimeUnit.class))).thenReturn(mock(ScheduledFuture.class));\n\n        serverEngine.setEngine(gameEngine);\n        serverEngine.setScheduledExecutorService(executorService);\n    }\n\n    @Test\n    public void testDBSchutdown(){\n        serverEngine.shutdownDatabase();\n        verify(gameEngine,times(1)).shutdownDatabase();\n    }\n\n    @Test\n    public void testAddEvent(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        SpaceWorld world = mock(SpaceWorld.class);\n        when(gameEngine.getWorld(anyInt())).thenReturn(world);\n\n        serverEngine.addEvent(event);\n\n        verify(world,times(1)).addEvent(event);\n    }\n\n    @Test\n    public void testStopGame(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        serverEngine.stopGame(event);\n\n        verify(gameEngine,times(1)).stopGame(anyInt(),anyInt());\n    }\n\n    @Test\n    public void testStopBroadcast(){\n\n        WorldEvent event = new WorldEventImpl();\n        event.setWorldId(0);\n        event.setPlayerId(0);\n        event.setType(WorldEventType.STOP);\n\n        \/\/ Init a world started with one player\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        serverEngine.getPlayerWorldMap().put(0, player);\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n\n        serverEngine.stopGame(event);\n\n        \/\/ world with player has been stoped\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 0);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 0);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 0);\n    }\n\n    @Test\n    public void testStartGame(){\n\n        serverEngine.startGame(0,0, mock(Session.class));\n\n        \/\/ world with player has been created and started to run\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n    }\n\n    @Test\n    public void startGameTwice(){\n        serverEngine.startGame(0,0, mock(Session.class));\n        serverEngine.startGame(0,0, mock(Session.class));\n\n        \/\/ game only started once\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n    }\n\n    @Test\n    public void startGameWith2Players(){\n\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,1, session);\n\n        \/\/ one world started\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n\n        \/\/ two player inside world 0\n        assertTrue(serverEngine.getPlayerWorldMap().get(0).size() == 2);\n\n        \/\/ one future\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n\n        \/\/ two player\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 2);\n\n        \/\/ world started for player 1\n        verify(gameEngine,times(1)).startGame(anyInt(),anyInt());\n\n        \/\/ player 2 added to world\n        verify(gameEngine,times(1)).addPlayer2World(anyInt(),anyInt());\n\n        \/\/ start game broadcasted once\n        verify(session, times(2)).getRemote();\n    }\n\n    @Test\n    public void testRunner() throws Exception {\n        ServerEngineImpl.Runner runner = serverEngine.new Runner();\n\n        \/\/ player in world 0\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        player.add(1);\n        serverEngine.getPlayerWorldMap().put(0, player);\n\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n        serverEngine.getPlayerSessionMap().put(1, mock(Session.class));\n\n        \/\/ create broadcaster\n        Broadcaster b = mock(Broadcaster.class);\n        when(b.createWorldEvent(anyInt())).thenReturn(new WorldEventImpl());\n        when(b.getEngine()).thenReturn(gameEngine);\n        runner.setBroadCaster(b);\n\n        \/\/ broadcast\n        runner.run();\n\n        \/\/ world has been broadcast by the runner the players\n        verify(b, times(2)).broadcast(any(Session.class), any(WorldEvent.class));\n    }\n\n}\n","new_contents":"package com.space.server.engine.impl;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport com.space.server.domain.api.SpaceWorld;\nimport com.space.server.engine.api.GameEngine;\nimport com.space.server.engine.api.WorldEvent;\nimport com.space.server.engine.api.WorldEventType;\nimport org.eclipse.jetty.websocket.api.RemoteEndpoint;\nimport org.eclipse.jetty.websocket.api.Session;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n\/**\n * Created by superernie77 on 11.02.2017.\n *\/\npublic class ServerEngineImplTest {\n\n    private ServerEngineImpl serverEngine;\n\n    private GameEngine gameEngine;\n\n    private ScheduledExecutorService executorService;\n\n    @Before\n    public void setup(){\n        serverEngine = new ServerEngineImpl();\n\n        gameEngine = mock(GameEngine.class);\n\n        executorService = mock(ScheduledExecutorService.class);\n        when(executorService.scheduleAtFixedRate(any(Runnable.class),anyLong(),anyLong(),any(TimeUnit.class))).thenReturn(mock(ScheduledFuture.class));\n\n        serverEngine.setEngine(gameEngine);\n        serverEngine.setScheduledExecutorService(executorService);\n    }\n\n    @Test\n    public void testDBSchutdown(){\n        serverEngine.shutdownDatabase();\n        verify(gameEngine,times(1)).shutdownDatabase();\n    }\n\n    @Test\n    public void testAddEvent(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        SpaceWorld world = mock(SpaceWorld.class);\n        when(gameEngine.getWorld(anyInt())).thenReturn(world);\n\n        serverEngine.addEvent(event);\n\n        verify(world,times(1)).addEvent(event);\n    }\n\n    @Test\n    public void testStopGame(){\n        WorldEvent event = mock(WorldEvent.class);\n\n        serverEngine.stopGame(event);\n\n        verify(gameEngine,times(1)).stopGame(anyInt(),anyInt());\n    }\n\n    @Test\n    public void testStopBroadcast(){\n\n        WorldEvent event = new WorldEventImpl();\n        event.setWorldId(0);\n        event.setPlayerId(0);\n        event.setType(WorldEventType.STOP);\n\n        \/\/ Init a world started with one player\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        serverEngine.getPlayerWorldMap().put(0, player);\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n\n        serverEngine.stopGame(event);\n\n        \/\/ world with player has been stoped\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 0);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 0);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 0);\n    }\n\n    @Test\n    public void testStartGame(){\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n\n        \/\/ world with player has been created and started to run\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n\n        \/\/ broadcasted once\n        verify(session, times(1)).getRemote();\n    }\n\n    @Test\n    public void startGameTwice(){\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,0, session);\n\n        \/\/ game only started once\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\n\n        verify(session, times(1)).getRemote();\n    }\n\n    @Test\n    public void startGameWith2Players(){\n\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\n        Session session = mock(Session.class);\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\n\n        serverEngine.startGame(0,0, session);\n        serverEngine.startGame(0,1, session);\n\n        \/\/ one world started\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\n\n        \/\/ two player inside world 0\n        assertTrue(serverEngine.getPlayerWorldMap().get(0).size() == 2);\n\n        \/\/ one future\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\n\n        \/\/ two player\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 2);\n\n        \/\/ world started for player 1\n        verify(gameEngine,times(1)).startGame(anyInt(),anyInt());\n\n        \/\/ player 2 added to world\n        verify(gameEngine,times(1)).addPlayer2World(anyInt(),anyInt());\n\n        \/\/ start game broadcasted once\n        verify(session, times(2)).getRemote();\n    }\n\n    @Test\n    public void testRunner() throws Exception {\n        ServerEngineImpl.Runner runner = serverEngine.new Runner();\n\n        \/\/ player in world 0\n        Set<Integer> player = new HashSet<>();\n        player.add(0);\n        player.add(1);\n        serverEngine.getPlayerWorldMap().put(0, player);\n\n        serverEngine.getWorldFutureMap().put(0, mock(ScheduledFuture.class));\n        serverEngine.getPlayerSessionMap().put(0, mock(Session.class));\n        serverEngine.getPlayerSessionMap().put(1, mock(Session.class));\n\n        \/\/ create broadcaster\n        Broadcaster b = mock(Broadcaster.class);\n        when(b.createWorldEvent(anyInt())).thenReturn(new WorldEventImpl());\n        when(b.getEngine()).thenReturn(gameEngine);\n        runner.setBroadCaster(b);\n\n        \/\/ broadcast\n        runner.run();\n\n        \/\/ world has been broadcast by the runner the players\n        verify(b, times(2)).broadcast(any(Session.class), any(WorldEvent.class));\n    }\n\n}\n","code_block_diff":"{'diff_0': ['\\n    @Test\\n    public void testStartGame(){\\n\\n        serverEngine.startGame(0,0, mock(Session.class));\\n\\n        \/\/ world with player has been created and started to run\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n    }\\n\\n    @Test\\n    public void startGameTwice(){\\n        serverEngine.startGame(0,0, mock(Session.class));\\n        serverEngine.startGame(0,0, mock(Session.class));\\n\\n        \/\/ game only started once\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n    }\\n\\n    @Test\\n', '\\n    @Test\\n    public void testStartGame(){\\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\\n        Session session = mock(Session.class);\\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\\n\\n        serverEngine.startGame(0,0, session);\\n\\n        \/\/ world with player has been created and started to run\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n\\n        \/\/ broadcasted once\\n        verify(session, times(1)).getRemote();\\n    }\\n\\n    @Test\\n    public void startGameTwice(){\\n        when(gameEngine.getWorld(anyInt())).thenReturn(mock(SpaceWorld.class));\\n        Session session = mock(Session.class);\\n        when(session.getRemote()).thenReturn(mock(RemoteEndpoint.class));\\n\\n\\n        serverEngine.startGame(0,0, session);\\n        serverEngine.startGame(0,0, session);\\n\\n        \/\/ game only started once\\n        assertTrue(serverEngine.getPlayerWorldMap().size() == 1);\\n        assertTrue(serverEngine.getWorldFutureMap().size() == 1);\\n        assertTrue(serverEngine.getPlayerSessionMap().size() == 1);\\n\\n        verify(session, times(1)).getRemote();\\n    }\\n\\n    @Test\\n']}","subject":"","message":"fixed unit-tests\n\n","lang":"Java","license":"","repos":""}
{"commit":"1c08f090aeb871d48d0a2b6088d290ee85d1bbf5","old_file":"com.microsoft.java.debug.core\/src\/main\/java\/com\/microsoft\/java\/debug\/core\/adapter\/handler\/ScopesRequestHandler.java","new_file":"com.microsoft.java.debug.core\/src\/main\/java\/com\/microsoft\/java\/debug\/core\/adapter\/handler\/ScopesRequestHandler.java","old_contents":"\/*******************************************************************************\n* Copyright (c) 2017 Microsoft Corporation and others.\n* All rights reserved. This program and the accompanying materials\n* are made available under the terms of the Eclipse Public License v1.0\n* which accompanies this distribution, and is available at\n* http:\/\/www.eclipse.org\/legal\/epl-v10.html\n*\n* Contributors:\n*     Microsoft Corporation - initial API and implementation\n*******************************************************************************\/\n\npackage com.microsoft.java.debug.core.adapter.handler;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nimport com.microsoft.java.debug.core.adapter.IDebugAdapterContext;\nimport com.microsoft.java.debug.core.adapter.IDebugRequestHandler;\nimport com.microsoft.java.debug.core.adapter.variables.StackFrameReference;\nimport com.microsoft.java.debug.core.adapter.variables.VariableProxy;\nimport com.microsoft.java.debug.core.protocol.Messages.Response;\nimport com.microsoft.java.debug.core.protocol.Requests.Arguments;\nimport com.microsoft.java.debug.core.protocol.Requests.Command;\nimport com.microsoft.java.debug.core.protocol.Requests.ScopesArguments;\nimport com.microsoft.java.debug.core.protocol.Responses;\nimport com.microsoft.java.debug.core.protocol.Types;\nimport com.sun.jdi.ThreadReference;\n\npublic class ScopesRequestHandler implements IDebugRequestHandler {\n\n    @Override\n    public List<Command> getTargetCommands() {\n        return Arrays.asList(Command.SCOPES);\n    }\n\n    @Override\n    public CompletableFuture<Response> handle(Command command, Arguments arguments, Response response, IDebugAdapterContext context) {\n        ScopesArguments scopesArgs = (ScopesArguments) arguments;\n        List<Types.Scope> scopes = new ArrayList<>();\n        StackFrameReference stackFrameReference = (StackFrameReference) context.getRecyclableIdPool().getObjectById(scopesArgs.frameId);\n        if (stackFrameReference == null) {\n            response.body = new Responses.ScopesResponseBody(scopes);\n            return CompletableFuture.completedFuture(response);\n        }\n        ThreadReference thread = stackFrameReference.getThread();\n        VariableProxy localScope = new VariableProxy(thread, \"Local\", stackFrameReference);\n        int localScopeId = context.getRecyclableIdPool().addObject(thread.uniqueID(), localScope);\n        scopes.add(new Types.Scope(localScope.getScope(), localScopeId, false));\n\n        response.body = new Responses.ScopesResponseBody(scopes);\n        return CompletableFuture.completedFuture(response);\n    }\n}\n","new_contents":"\/*******************************************************************************\n* Copyright (c) 2017 Microsoft Corporation and others.\n* All rights reserved. This program and the accompanying materials\n* are made available under the terms of the Eclipse Public License v1.0\n* which accompanies this distribution, and is available at\n* http:\/\/www.eclipse.org\/legal\/epl-v10.html\n*\n* Contributors:\n*     Microsoft Corporation - initial API and implementation\n*******************************************************************************\/\n\npackage com.microsoft.java.debug.core.adapter.handler;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nimport com.microsoft.java.debug.core.adapter.IDebugAdapterContext;\nimport com.microsoft.java.debug.core.adapter.IDebugRequestHandler;\nimport com.microsoft.java.debug.core.adapter.variables.StackFrameReference;\nimport com.microsoft.java.debug.core.adapter.variables.VariableProxy;\nimport com.microsoft.java.debug.core.protocol.Messages.Response;\nimport com.microsoft.java.debug.core.protocol.Requests.Arguments;\nimport com.microsoft.java.debug.core.protocol.Requests.Command;\nimport com.microsoft.java.debug.core.protocol.Requests.ScopesArguments;\nimport com.microsoft.java.debug.core.protocol.Responses;\nimport com.microsoft.java.debug.core.protocol.Types;\nimport com.sun.jdi.ThreadReference;\n\npublic class ScopesRequestHandler implements IDebugRequestHandler {\n\n    @Override\n    public List<Command> getTargetCommands() {\n        return Arrays.asList(Command.SCOPES);\n    }\n\n    @Override\n    public CompletableFuture<Response> handle(Command command, Arguments arguments, Response response, IDebugAdapterContext context) {\n        ScopesArguments scopesArgs = (ScopesArguments) arguments;\n        List<Types.Scope> scopes = new ArrayList<>();\n        StackFrameReference stackFrameReference = (StackFrameReference) context.getRecyclableIdPool().getObjectById(scopesArgs.frameId);\n        if (stackFrameReference == null) {\n            response.body = new Responses.ScopesResponseBody(scopes);\n            return CompletableFuture.completedFuture(response);\n        }\n        ThreadReference thread = stackFrameReference.getThread();\n        VariableProxy localScope = new VariableProxy(thread, \"Local\", stackFrameReference);\n        int localScopeId = context.getRecyclableIdPool().addObject(thread.uniqueID(), localScope);\n        scopes.add(new Types.Scope(localScope.getScope(), localScopeId, context.isAttached()));\n\n        response.body = new Responses.ScopesResponseBody(scopes);\n        return CompletableFuture.completedFuture(response);\n    }\n}\n","code_block_diff":"{'diff_0': ['        ThreadReference thread = stackFrameReference.getThread();\\n        VariableProxy localScope = new VariableProxy(thread, \"Local\", stackFrameReference);\\n        int localScopeId = context.getRecyclableIdPool().addObject(thread.uniqueID(), localScope);\\n        scopes.add(new Types.Scope(localScope.getScope(), localScopeId, false));\\n\\n        response.body = new Responses.ScopesResponseBody(scopes);\\n        return CompletableFuture.completedFuture(response);\\n', '        ThreadReference thread = stackFrameReference.getThread();\\n        VariableProxy localScope = new VariableProxy(thread, \"Local\", stackFrameReference);\\n        int localScopeId = context.getRecyclableIdPool().addObject(thread.uniqueID(), localScope);\\n        scopes.add(new Types.Scope(localScope.getScope(), localScopeId, context.isAttached()));\\n\\n        response.body = new Responses.ScopesResponseBody(scopes);\\n        return CompletableFuture.completedFuture(response);\\n']}","subject":"","message":"fix issue 311:lazy load object variables while attach debug\n\n","lang":"Java","license":"","repos":""}
{"commit":"48c35f837b87759aeec81e9af0ccd424113aa1a5","old_file":"jirm-orm\/src\/main\/java\/co\/jirm\/mapper\/SqlObjectConfig.java","new_file":"jirm-orm\/src\/main\/java\/co\/jirm\/mapper\/SqlObjectConfig.java","old_contents":"\/**\n * Copyright (C) 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage co.jirm.mapper;\n\nimport co.jirm.mapper.converter.DefaultParameterConverter;\nimport co.jirm.mapper.converter.JacksonSqlObjectConverter;\nimport co.jirm.mapper.converter.SqlObjectConverter;\nimport co.jirm.mapper.converter.SqlParameterConverter;\nimport co.jirm.mapper.definition.DefaultNamingStrategy;\nimport co.jirm.mapper.definition.NamingStrategy;\nimport co.jirm.mapper.definition.SqlObjectDefinition;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\n\npublic class SqlObjectConfig {\n\t\n\tprivate final NamingStrategy namingStrategy;\n\tprivate final SqlParameterConverter converter;\n\tprivate final SqlObjectConverter objectMapper;\n\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\n\tprivate final int maximumLoadDepth = 4;\n\t\n\tprivate SqlObjectConfig(\n\t\t\tNamingStrategy namingStrategy, \n\t\t\tSqlObjectConverter objectMapper, \n\t\t\tSqlParameterConverter converter, \n\t\t\tCache<Class<?>, SqlObjectDefinition<?>> cache) {\n\t\tsuper();\n\t\tthis.namingStrategy = namingStrategy;\n\t\tthis.converter = converter;\n\t\tthis.objectMapper = objectMapper;\n\t\tthis.cache = cache;\n\t}\n\t\n\t\n\tpublic NamingStrategy getNamingStrategy() {\n\t\treturn namingStrategy;\n\t}\n\t\n\tpublic SqlParameterConverter getConverter() {\n\t\treturn converter;\n\t}\n\t\n\tpublic SqlObjectConverter getObjectMapper() {\n\t\treturn objectMapper;\n\t}\n\t\n\tpublic <T> SqlObjectDefinition<T> resolveObjectDefinition(Class<T> objectType) {\n\t\treturn SqlObjectDefinition.fromClass(objectType, this);\n\t}\n\t\n\t\n\tpublic int getMaximumLoadDepth() {\n\t\treturn maximumLoadDepth;\n\t}\n\t\n\tpublic Cache<Class<?>, SqlObjectDefinition<?>> getCache() {\n\t\treturn cache;\n\t}\n\t\n\tpublic static SqlObjectConfig DEFAULT = \n\t\t\tnew SqlObjectConfig(DefaultNamingStrategy.INSTANCE,\n\t\t\tnew JacksonSqlObjectConverter(), new DefaultParameterConverter(), \n\t\t\tCacheBuilder.newBuilder()\n\t\t\t.weakKeys()\n\t\t\t.maximumSize(1000)\n\t\t\t.<Class<?>, SqlObjectDefinition<?>>build());\n\n}\n","new_contents":"\/**\n * Copyright (C) 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage co.jirm.mapper;\n\nimport co.jirm.mapper.converter.DefaultParameterConverter;\nimport co.jirm.mapper.converter.JacksonSqlObjectConverter;\nimport co.jirm.mapper.converter.SqlObjectConverter;\nimport co.jirm.mapper.converter.SqlParameterConverter;\nimport co.jirm.mapper.definition.DefaultNamingStrategy;\nimport co.jirm.mapper.definition.NamingStrategy;\nimport co.jirm.mapper.definition.SqlObjectDefinition;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\n\npublic class SqlObjectConfig {\n\t\n\tprivate final NamingStrategy namingStrategy;\n\tprivate final SqlParameterConverter converter;\n\tprivate final SqlObjectConverter objectMapper;\n\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\n\tprivate final int maximumLoadDepth = 4;\n\t\n\tprotected SqlObjectConfig(\n\t\t\tNamingStrategy namingStrategy, \n\t\t\tSqlObjectConverter objectMapper, \n\t\t\tSqlParameterConverter converter, \n\t\t\tCache<Class<?>, SqlObjectDefinition<?>> cache) {\n\t\tsuper();\n\t\tthis.namingStrategy = namingStrategy;\n\t\tthis.converter = converter;\n\t\tthis.objectMapper = objectMapper;\n\t\tthis.cache = cache;\n\t}\n\t\n\t\n\tpublic NamingStrategy getNamingStrategy() {\n\t\treturn namingStrategy;\n\t}\n\t\n\tpublic SqlParameterConverter getConverter() {\n\t\treturn converter;\n\t}\n\t\n\tpublic SqlObjectConverter getObjectMapper() {\n\t\treturn objectMapper;\n\t}\n\t\n\tpublic <T> SqlObjectDefinition<T> resolveObjectDefinition(Class<T> objectType) {\n\t\treturn SqlObjectDefinition.fromClass(objectType, this);\n\t}\n\t\n\t\n\tpublic int getMaximumLoadDepth() {\n\t\treturn maximumLoadDepth;\n\t}\n\t\n\tpublic Cache<Class<?>, SqlObjectDefinition<?>> getCache() {\n\t\treturn cache;\n\t}\n\t\n\tpublic static SqlObjectConfig DEFAULT = \n\t\t\tnew SqlObjectConfig(DefaultNamingStrategy.INSTANCE,\n\t\t\tnew JacksonSqlObjectConverter(), new DefaultParameterConverter(), \n\t\t\tCacheBuilder.newBuilder()\n\t\t\t.weakKeys()\n\t\t\t.maximumSize(1000)\n\t\t\t.<Class<?>, SqlObjectDefinition<?>>build());\n\n}\n","code_block_diff":"{'diff_0': ['\\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\\n\\tprivate final int maximumLoadDepth = 4;\\n\\t\\n\\tprivate SqlObjectConfig(\\n\\t\\t\\tNamingStrategy namingStrategy, \\n\\t\\t\\tSqlObjectConverter objectMapper, \\n\\t\\t\\tSqlParameterConverter converter, \\n', '\\tprivate final transient Cache<Class<?>, SqlObjectDefinition<?>> cache;\\n\\tprivate final int maximumLoadDepth = 4;\\n\\t\\n\\tprotected SqlObjectConfig(\\n\\t\\t\\tNamingStrategy namingStrategy, \\n\\t\\t\\tSqlObjectConverter objectMapper, \\n\\t\\t\\tSqlParameterConverter converter, \\n']}","subject":"","message":"The SqlProjectConfig class' constructor was made to be protected instead of private.\n\n","lang":"Java","license":"","repos":""}
{"commit":"154258a9a2e6923c2431bfc31a0072bdb246f661","old_file":"tasks\/git\/src\/main\/java\/com\/walmartlabs\/concord\/plugins\/git\/JGitClient.java","new_file":"tasks\/git\/src\/main\/java\/com\/walmartlabs\/concord\/plugins\/git\/JGitClient.java","old_contents":"package com.walmartlabs.concord.plugins.git;\n\n\/*-\n * *****\n * Concord\n * -----\n * Copyright (C) 2017 - 2020 Walmart Inc.\n * -----\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =====\n *\/\n\nimport com.jcraft.jsch.JSch;\nimport com.jcraft.jsch.JSchException;\nimport com.jcraft.jsch.Session;\nimport com.walmartlabs.concord.common.secret.KeyPair;\nimport com.walmartlabs.concord.common.secret.UsernamePassword;\nimport com.walmartlabs.concord.sdk.Secret;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.TransportConfigCallback;\nimport org.eclipse.jgit.transport.*;\nimport org.eclipse.jgit.transport.ssh.jsch.JschConfigSessionFactory;\nimport org.eclipse.jgit.transport.ssh.jsch.OpenSshConfig;\nimport org.eclipse.jgit.util.FS;\n\nimport java.nio.file.Path;\nimport java.util.Properties;\n\npublic class JGitClient implements GitClient {\n\n    @Override\n    public void cloneRepo(String uri, String branchName, Secret secret, Path dst) throws Exception {\n        try (Git repo = Git.cloneRepository()\n                .setURI(uri)\n                .setBranch(branchName)\n                .setDirectory(dst.toFile())\n                .setTransportConfigCallback(createTransportConfigCallback(secret))\n                .call()) {\n\n            \/\/ check if the branch actually exists\n            if (branchName != null) {\n                repo.checkout()\n                        .setName(branchName)\n                        .call();\n            }\n        }\n    }\n\n    public static TransportConfigCallback createTransportConfigCallback(Secret secret) {\n        if (secret == null) {\n            return null;\n        }\n\n        if (secret instanceof UsernamePassword) {\n            return createHttpTransportConfigCallback((UsernamePassword) secret);\n        } else if (secret instanceof KeyPair) {\n            return createSshTransportConfigCallback((KeyPair) secret);\n        } else if (secret instanceof TokenSecret) {\n            return createHttpTransportConfigCallback(new UsernamePassword(((TokenSecret) secret).getToken(), \"\".toCharArray()));\n        }\n\n        \/\/ empty callback\n        return transport -> {\n        };\n    }\n\n    private static TransportConfigCallback createSshTransportConfigCallback(KeyPair secret) {\n        return transport -> {\n            if (transport instanceof SshTransport) {\n                configureSshTransport((SshTransport) transport, secret);\n            } else {\n                throw new IllegalArgumentException(\"Use SSH GIT URL \");\n            }\n        };\n    }\n\n    private static TransportConfigCallback createHttpTransportConfigCallback(UsernamePassword secret) {\n        return transport -> {\n            if (transport instanceof HttpTransport) {\n                transport.setCredentialsProvider(\n                        new UsernamePasswordCredentialsProvider(secret.getUsername(), secret.getPassword()));\n            } else {\n                throw new IllegalArgumentException(\"Use HTTP(S) GIT URL\");\n            }\n        };\n    }\n\n    private static void configureSshTransport(SshTransport t, KeyPair secret) {\n        SshSessionFactory f = new JschConfigSessionFactory() {\n            @Override\n            protected JSch createDefaultJSch(FS fs) throws JSchException {\n                JSch d = super.createDefaultJSch(fs);\n                d.removeAllIdentity();\n                d.addIdentity(\"key\", secret.getPrivateKey(), null, null);\n                return d;\n            }\n\n            @Override\n            protected void configure(OpenSshConfig.Host hc, Session session) {\n                Properties config = new Properties();\n                config.put(\"StrictHostKeyChecking\", \"no\");\n                session.setConfig(config);\n            }\n        };\n\n        t.setSshSessionFactory(f);\n    }\n}\n","new_contents":"package com.walmartlabs.concord.plugins.git;\n\n\/*-\n * *****\n * Concord\n * -----\n * Copyright (C) 2017 - 2020 Walmart Inc.\n * -----\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =====\n *\/\n\nimport com.jcraft.jsch.JSch;\nimport com.jcraft.jsch.JSchException;\nimport com.jcraft.jsch.Session;\nimport com.walmartlabs.concord.common.secret.KeyPair;\nimport com.walmartlabs.concord.common.secret.UsernamePassword;\nimport com.walmartlabs.concord.sdk.Secret;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.TransportConfigCallback;\nimport org.eclipse.jgit.transport.*;\nimport org.eclipse.jgit.util.FS;\n\nimport java.nio.file.Path;\nimport java.util.Properties;\n\npublic class JGitClient implements GitClient {\n\n    @Override\n    public void cloneRepo(String uri, String branchName, Secret secret, Path dst) throws Exception {\n        try (Git repo = Git.cloneRepository()\n                .setURI(uri)\n                .setBranch(branchName)\n                .setDirectory(dst.toFile())\n                .setTransportConfigCallback(createTransportConfigCallback(secret))\n                .call()) {\n\n            \/\/ check if the branch actually exists\n            if (branchName != null) {\n                repo.checkout()\n                        .setName(branchName)\n                        .call();\n            }\n        }\n    }\n\n    public static TransportConfigCallback createTransportConfigCallback(Secret secret) {\n        if (secret == null) {\n            return null;\n        }\n\n        if (secret instanceof UsernamePassword) {\n            return createHttpTransportConfigCallback((UsernamePassword) secret);\n        } else if (secret instanceof KeyPair) {\n            return createSshTransportConfigCallback((KeyPair) secret);\n        } else if (secret instanceof TokenSecret) {\n            return createHttpTransportConfigCallback(new UsernamePassword(((TokenSecret) secret).getToken(), \"\".toCharArray()));\n        }\n\n        \/\/ empty callback\n        return transport -> {\n        };\n    }\n\n    private static TransportConfigCallback createSshTransportConfigCallback(KeyPair secret) {\n        return transport -> {\n            if (transport instanceof SshTransport) {\n                configureSshTransport((SshTransport) transport, secret);\n            } else {\n                throw new IllegalArgumentException(\"Use SSH GIT URL \");\n            }\n        };\n    }\n\n    private static TransportConfigCallback createHttpTransportConfigCallback(UsernamePassword secret) {\n        return transport -> {\n            if (transport instanceof HttpTransport) {\n                transport.setCredentialsProvider(\n                        new UsernamePasswordCredentialsProvider(secret.getUsername(), secret.getPassword()));\n            } else {\n                throw new IllegalArgumentException(\"Use HTTP(S) GIT URL\");\n            }\n        };\n    }\n\n    private static void configureSshTransport(SshTransport t, KeyPair secret) {\n        SshSessionFactory f = new JschConfigSessionFactory() {\n            @Override\n            protected JSch createDefaultJSch(FS fs) throws JSchException {\n                JSch d = super.createDefaultJSch(fs);\n                d.removeAllIdentity();\n                d.addIdentity(\"key\", secret.getPrivateKey(), null, null);\n                return d;\n            }\n\n            @Override\n            protected void configure(OpenSshConfig.Host hc, Session session) {\n                Properties config = new Properties();\n                config.put(\"StrictHostKeyChecking\", \"no\");\n                session.setConfig(config);\n            }\n        };\n\n        t.setSshSessionFactory(f);\n    }\n}\n","code_block_diff":"{'diff_0': ['import org.eclipse.jgit.api.Git;\\nimport org.eclipse.jgit.api.TransportConfigCallback;\\nimport org.eclipse.jgit.transport.*;\\nimport org.eclipse.jgit.transport.ssh.jsch.JschConfigSessionFactory;\\nimport org.eclipse.jgit.transport.ssh.jsch.OpenSshConfig;\\nimport org.eclipse.jgit.util.FS;\\n\\nimport java.nio.file.Path;\\n', 'import org.eclipse.jgit.api.Git;\\nimport org.eclipse.jgit.api.TransportConfigCallback;\\nimport org.eclipse.jgit.transport.*;\\nimport org.eclipse.jgit.util.FS;\\n\\nimport java.nio.file.Path;\\n']}","subject":"","message":"git: rollback version to 5.x\n\n","lang":"Java","license":"","repos":""}
{"commit":"737a97594fd53547679201badbebaad3449087ac","old_file":"Phosphor\/src\/main\/java\/edu\/columbia\/cs\/psl\/phosphor\/instrumenter\/SourceTaintingMV.java","new_file":"Phosphor\/src\/main\/java\/edu\/columbia\/cs\/psl\/phosphor\/instrumenter\/SourceTaintingMV.java","old_contents":"package edu.columbia.cs.psl.phosphor.instrumenter;\n\nimport edu.columbia.cs.psl.phosphor.BasicSourceSinkManager;\nimport edu.columbia.cs.psl.phosphor.Configuration;\nimport edu.columbia.cs.psl.phosphor.SourceSinkManager;\nimport edu.columbia.cs.psl.phosphor.TaintUtils;\nimport edu.columbia.cs.psl.phosphor.control.OpcodesUtil;\nimport edu.columbia.cs.psl.phosphor.runtime.Taint;\nimport edu.columbia.cs.psl.phosphor.runtime.TaintSourceWrapper;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\n\nimport static edu.columbia.cs.psl.phosphor.instrumenter.TaintMethodRecord.*;\n\npublic class SourceTaintingMV extends MethodVisitor implements Opcodes {\n\n    private static final SourceSinkManager sourceSinkManager = BasicSourceSinkManager.getInstance();\n    private final String desc;\n    private final boolean isStatic;\n    private final Object lbl;\n    \/**\n     * The original (before Phosphor added taint tracking information) descriptor of\n     * the method being visited\n     *\/\n    private final String actualSource;\n\n    public SourceTaintingMV(MethodVisitor mv, int access, String owner, String name, String desc) {\n        super(Configuration.ASM_VERSION, mv);\n        this.desc = desc;\n        this.isStatic = (access & Opcodes.ACC_STATIC) != 0;\n        this.lbl = sourceSinkManager.getLabel(owner, name, desc);\n        this.actualSource = owner + \".\" + name + desc;\n    }\n\n    \/**\n     * Adds code to make a call to autoTaint. Supplies the specified int as the\n     * argument index.\n     *\/\n    private void callAutoTaint(int argIndex, Type expectedType) {\n        super.visitFieldInsn(GETSTATIC, Type.getInternalName(Configuration.class), \"autoTainter\",\n                Type.getDescriptor(TaintSourceWrapper.class));\n        super.visitInsn(SWAP);\n        super.visitLdcInsn(lbl);\n        super.visitLdcInsn(actualSource);\n        super.visitIntInsn(BIPUSH, argIndex);\n        AUTO_TAINT.delegateVisit(this);\n        if (TaintUtils.isWrappedType(expectedType)) {\n            super.visitTypeInsn(CHECKCAST, TaintUtils.getWrapperType(expectedType).getInternalName());\n        } else {\n            super.visitTypeInsn(CHECKCAST, expectedType.getInternalName());\n        }\n    }\n\n    private int[] shadowVarsForArgs;\n    @Override\n    public void visitLdcInsn(Object value) {\n        if(shadowVarsForArgs == null && value instanceof String){\n            String str = (String) value;\n            if(str.startsWith(\"PhosphorArgTaintIndices=\")){\n                String[] parts = str.substring(\"PhosphorArgTaintIndices=\".length()).split(\",\");\n                shadowVarsForArgs = new int[parts.length];\n                for(int i = 0; i< parts.length; i++){\n                    shadowVarsForArgs[i] = Integer.parseInt(parts[i]);\n                }\n                autoTaintArguments();\n            }\n        }\n        super.visitLdcInsn(value);\n    }\n\n    \/**\n     * Adds code to taint the arguments passed to this method.\n     *\/\n    private void autoTaintArguments() {\n        Type[] args = Type.getArgumentTypes(desc);\n        int idx = isStatic ? 0 : 1; \/\/ skip over the \"this\" argument for non-static methods\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].getSort() == Type.OBJECT\n                    || args[i].getSort() == Type.ARRAY) {\n                super.visitVarInsn(ALOAD, idx); \/\/ load the argument onto the stack\n                callAutoTaint(i, args[i]);\n                super.visitVarInsn(ASTORE, idx); \/\/ replace the argument with the return of autoTaint\n            }\n            idx += args[i].getSize();\n            \/\/Also set the reference taint for this.\n            super.visitVarInsn(ALOAD, shadowVarsForArgs[i]);\n            callAutoTaint(i, Type.getType(Taint.class));\n            super.visitVarInsn(ASTORE, shadowVarsForArgs[i]);\n        }\n        \/\/Bad choices... if the method is non-static, there is one more taint than there is variables in the args array\n        if(!isStatic) {\n            super.visitVarInsn(ALOAD, shadowVarsForArgs[shadowVarsForArgs.length - 1]);\n            callAutoTaint(0, Type.getType(Taint.class));\n            super.visitVarInsn(ASTORE, shadowVarsForArgs[shadowVarsForArgs.length - 1]);\n        }\n    }\n\n    @Override\n    public void visitInsn(int opcode) {\n        if (OpcodesUtil.isReturnOpcode(opcode)) {\n            autoTaintArguments();\n            if (opcode != RETURN) {\n                super.visitInsn(ACONST_NULL);\n                STACK_FRAME_FOR_METHOD_DEBUG.delegateVisit(mv);\n                super.visitInsn(DUP);\n\n                GET_RETURN_TAINT.delegateVisit(mv);\n\n                super.visitFieldInsn(GETSTATIC, Type.getInternalName(Configuration.class), \"autoTainter\",\n                        Type.getDescriptor(TaintSourceWrapper.class));\n                super.visitInsn(SWAP);\n                super.visitLdcInsn(lbl);\n                super.visitLdcInsn(actualSource);\n                super.visitInsn(ICONST_M1);\n                AUTO_TAINT.delegateVisit(this);\n                super.visitTypeInsn(CHECKCAST, Configuration.TAINT_TAG_INTERNAL_NAME);\n\n                SET_RETURN_TAINT.delegateVisit(mv);\n            }\n        }\n        super.visitInsn(opcode);\n    }\n}\n","new_contents":"package edu.columbia.cs.psl.phosphor.instrumenter;\n\nimport edu.columbia.cs.psl.phosphor.BasicSourceSinkManager;\nimport edu.columbia.cs.psl.phosphor.Configuration;\nimport edu.columbia.cs.psl.phosphor.SourceSinkManager;\nimport edu.columbia.cs.psl.phosphor.TaintUtils;\nimport edu.columbia.cs.psl.phosphor.control.OpcodesUtil;\nimport edu.columbia.cs.psl.phosphor.runtime.Taint;\nimport edu.columbia.cs.psl.phosphor.runtime.TaintSourceWrapper;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\n\nimport static edu.columbia.cs.psl.phosphor.instrumenter.TaintMethodRecord.*;\n\npublic class SourceTaintingMV extends MethodVisitor implements Opcodes {\n\n    private static final SourceSinkManager sourceSinkManager = BasicSourceSinkManager.getInstance();\n    private final String desc;\n    private final boolean isStatic;\n    private final Object lbl;\n    \/**\n     * The original (before Phosphor added taint tracking information) descriptor of\n     * the method being visited\n     *\/\n    private final String actualSource;\n\n    public SourceTaintingMV(MethodVisitor mv, int access, String owner, String name, String desc) {\n        super(Configuration.ASM_VERSION, mv);\n        this.desc = desc;\n        this.isStatic = (access & Opcodes.ACC_STATIC) != 0;\n        this.lbl = sourceSinkManager.getLabel(owner, name, desc);\n        this.actualSource = owner + \".\" + name + desc;\n    }\n\n    \/**\n     * Adds code to make a call to autoTaint. Supplies the specified int as the\n     * argument index.\n     *\/\n    private void callAutoTaint(int argIndex, Type expectedType) {\n        super.visitFieldInsn(GETSTATIC, Type.getInternalName(Configuration.class), \"autoTainter\",\n                Type.getDescriptor(TaintSourceWrapper.class));\n        super.visitInsn(SWAP);\n        super.visitLdcInsn(lbl);\n        super.visitLdcInsn(actualSource);\n        super.visitIntInsn(BIPUSH, argIndex);\n        AUTO_TAINT.delegateVisit(this);\n        if (TaintUtils.isWrappedType(expectedType)) {\n            super.visitTypeInsn(CHECKCAST, TaintUtils.getWrapperType(expectedType).getInternalName());\n        } else {\n            super.visitTypeInsn(CHECKCAST, expectedType.getInternalName());\n        }\n    }\n\n    private int[] shadowVarsForArgs;\n    @Override\n    public void visitLdcInsn(Object value) {\n        if(shadowVarsForArgs == null && value instanceof String){\n            String str = (String) value;\n            if(str.startsWith(\"PhosphorArgTaintIndices=\")){\n                String[] parts = str.substring(\"PhosphorArgTaintIndices=\".length()).split(\",\");\n                shadowVarsForArgs = new int[parts.length];\n                for(int i = 0; i< parts.length; i++){\n                    shadowVarsForArgs[i] = Integer.parseInt(parts[i]);\n                }\n                autoTaintArguments();\n            }\n        }\n        super.visitLdcInsn(value);\n    }\n\n    \/**\n     * Adds code to taint the arguments passed to this method.\n     *\/\n    private void autoTaintArguments() {\n        Type[] args = Type.getArgumentTypes(TaintUtils.getOriginalDescrptor(desc));\n        int idx = isStatic ? 0 : 1; \/\/ skip over the \"this\" argument for non-static methods\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].getSort() == Type.OBJECT\n                    || args[i].getSort() == Type.ARRAY) {\n                super.visitVarInsn(ALOAD, idx); \/\/ load the argument onto the stack\n                callAutoTaint(i, args[i]);\n                super.visitVarInsn(ASTORE, idx); \/\/ replace the argument with the return of autoTaint\n            }\n            idx += args[i].getSize();\n            \/\/Also set the reference taint for this.\n            super.visitVarInsn(ALOAD, shadowVarsForArgs[i]);\n            callAutoTaint(i, Type.getType(Taint.class));\n            super.visitVarInsn(ASTORE, shadowVarsForArgs[i]);\n        }\n        \/\/Bad choices... if the method is non-static, there is one more taint than there is variables in the args array\n        if(!isStatic) {\n            super.visitVarInsn(ALOAD, shadowVarsForArgs[shadowVarsForArgs.length - 1]);\n            callAutoTaint(0, Type.getType(Taint.class));\n            super.visitVarInsn(ASTORE, shadowVarsForArgs[shadowVarsForArgs.length - 1]);\n        }\n    }\n\n    @Override\n    public void visitInsn(int opcode) {\n        if (OpcodesUtil.isReturnOpcode(opcode)) {\n            autoTaintArguments();\n            if (opcode != RETURN) {\n                super.visitInsn(ACONST_NULL);\n                STACK_FRAME_FOR_METHOD_DEBUG.delegateVisit(mv);\n                super.visitInsn(DUP);\n\n                GET_RETURN_TAINT.delegateVisit(mv);\n\n                super.visitFieldInsn(GETSTATIC, Type.getInternalName(Configuration.class), \"autoTainter\",\n                        Type.getDescriptor(TaintSourceWrapper.class));\n                super.visitInsn(SWAP);\n                super.visitLdcInsn(lbl);\n                super.visitLdcInsn(actualSource);\n                super.visitInsn(ICONST_M1);\n                AUTO_TAINT.delegateVisit(this);\n                super.visitTypeInsn(CHECKCAST, Configuration.TAINT_TAG_INTERNAL_NAME);\n\n                SET_RETURN_TAINT.delegateVisit(mv);\n            }\n        }\n        super.visitInsn(opcode);\n    }\n}\n","code_block_diff":"{'diff_0': ['     * Adds code to taint the arguments passed to this method.\\n     *\/\\n    private void autoTaintArguments() {\\n        Type[] args = Type.getArgumentTypes(desc);\\n        int idx = isStatic ? 0 : 1; \/\/ skip over the \"this\" argument for non-static methods\\n        for (int i = 0; i < args.length; i++) {\\n            if (args[i].getSort() == Type.OBJECT\\n', '     * Adds code to taint the arguments passed to this method.\\n     *\/\\n    private void autoTaintArguments() {\\n        Type[] args = Type.getArgumentTypes(TaintUtils.getOriginalDescrptor(desc));\\n        int idx = isStatic ? 0 : 1; \/\/ skip over the \"this\" argument for non-static methods\\n        for (int i = 0; i < args.length; i++) {\\n            if (args[i].getSort() == Type.OBJECT\\n']}","subject":"","message":"Fix for issue #197: Auto-tainter should not try to taint the PhosphorStackFrame object\n\n","lang":"Java","license":"","repos":""}
{"commit":"f44c64291e9705a867e7869dd0f1b71e9f896360","old_file":"anno4j-core\/src\/test\/java\/com\/github\/anno4j\/example\/ExampleTest.java","new_file":"anno4j-core\/src\/test\/java\/com\/github\/anno4j\/example\/ExampleTest.java","old_contents":"package com.github.anno4j.example;\n\nimport com.github.anno4j.Anno4j;\nimport com.github.anno4j.model.Annotation;\nimport com.github.anno4j.model.MotivationFactory;\nimport com.github.anno4j.model.impl.ResourceObject;\nimport com.github.anno4j.model.impl.agent.Person;\nimport com.github.anno4j.model.impl.agent.Software;\nimport com.github.anno4j.model.impl.selector.TextPositionSelector;\nimport com.github.anno4j.model.impl.targets.SpecificResource;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openrdf.repository.object.ObjectConnection;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Test case to implement the example annotation at {@link }http:\/\/www.w3.org\/TR\/2014\/WD-annotation-model-20141211\/#complete-example}.\n *\/\npublic class ExampleTest {\n\n    private Anno4j anno4j;\n\n    @Before\n    public void setUp() throws Exception {\n        this.anno4j = new Anno4j();\n    }\n    \n\n    @Test\n    public void exampleTest() throws Exception {\n\n        \/\/ Create the base annotation\n        Annotation annotation = anno4j.createObject(Annotation.class);\n        annotation.setAnnotatedAt(\"2014-09-28T12:00:00Z\");\n        annotation.setSerializedAt(\"2013-02-04T12:00:00Z\");\n        annotation.setMotivatedBy(MotivationFactory.getCommenting(anno4j));\n\n\n        \/\/ Create the person agent for the annotation\n        Person person = anno4j.createObject(Person.class);\n        person.setName(\"A. Person\");\n        person.setOpenID(\"http:\/\/example.org\/agent1\/openID1\");\n\n        annotation.setAnnotatedBy(person);\n\n        \/\/ Create the software agent for the annotation\n        Software software = anno4j.createObject(Software.class);\n        software.setName(\"Code v2.1\");\n        software.setHomepage(\"http:\/\/example.org\/agent2\/homepage1\");\n\n        annotation.setSerializedBy(software);\n        \/\/ Create the body\n        TextAnnotationBody body = anno4j.createObject(TextAnnotationBody.class);\n        body.setFormat(\"text\/plain\");\n        body.setValue(\"One of my favourite cities\");\n        body.setLanguage(\"en\");\n        annotation.setBody(body);\n\n        \/\/ Create the selector\n        SpecificResource specificResource = anno4j.createObject(SpecificResource.class);\n\n        TextPositionSelector textPositionSelector = anno4j.createObject(TextPositionSelector.class);\n        textPositionSelector.setStart(4096);\n        textPositionSelector.setEnd(4104);\n\n        specificResource.setSelector(textPositionSelector);\n\n        \/\/ Create the actual target\n        ResourceObject source = anno4j.createObject(ResourceObject.class);\n        source.setResourceAsString(\"http:\/\/example.org\/source1\");\n        specificResource.setSource(source);\n\n        annotation.addTarget(specificResource);\n\n        \/\/ Query persisted object\n        List<Annotation> result = anno4j.findAll(Annotation.class);\n\n        assertEquals(1, result.size());\n\n        Annotation resultObject = result.get(0);\n\n        assertEquals(annotation.getResource(), resultObject.getResource());\n    }\n}\n","new_contents":"package com.github.anno4j.example;\n\nimport com.github.anno4j.Anno4j;\nimport com.github.anno4j.model.Annotation;\nimport com.github.anno4j.model.MotivationFactory;\nimport com.github.anno4j.model.impl.ResourceObject;\nimport com.github.anno4j.model.impl.agent.Person;\nimport com.github.anno4j.model.impl.agent.Software;\nimport com.github.anno4j.model.impl.selector.TextPositionSelector;\nimport com.github.anno4j.model.impl.targets.SpecificResource;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openrdf.repository.object.ObjectConnection;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Test case to implement the example annotation at {@link }http:\/\/www.w3.org\/TR\/2014\/WD-annotation-model-20141211\/#complete-example}.\n *\/\npublic class ExampleTest {\n\n    private Anno4j anno4j;\n\n    @Before\n    public void setUp() throws Exception {\n        this.anno4j = new Anno4j();\n    }\n\n    @Test\n    public void exampleTest() throws Exception {\n\n        \/\/ Create the base annotation\n        Annotation annotation = anno4j.createObject(Annotation.class);\n        annotation.setAnnotatedAt(\"2014-09-28T12:00:00Z\");\n        annotation.setSerializedAt(\"2013-02-04T12:00:00Z\");\n        annotation.setMotivatedBy(MotivationFactory.getCommenting(anno4j));\n\n\n        \/\/ Create the person agent for the annotation\n        Person person = anno4j.createObject(Person.class);\n        person.setName(\"A. Person\");\n        person.setOpenID(\"http:\/\/example.org\/agent1\/openID1\");\n\n        annotation.setAnnotatedBy(person);\n\n        \/\/ Create the software agent for the annotation\n        Software software = anno4j.createObject(Software.class);\n        software.setName(\"Code v2.1\");\n        software.setHomepage(\"http:\/\/example.org\/agent2\/homepage1\");\n\n        annotation.setSerializedBy(software);\n        \/\/ Create the body\n        TextAnnotationBody body = anno4j.createObject(TextAnnotationBody.class);\n        body.setFormat(\"text\/plain\");\n        body.setValue(\"One of my favourite cities\");\n        body.setLanguage(\"en\");\n        annotation.setBody(body);\n\n        \/\/ Create the selector\n        SpecificResource specificResource = anno4j.createObject(SpecificResource.class);\n\n        TextPositionSelector textPositionSelector = anno4j.createObject(TextPositionSelector.class);\n        textPositionSelector.setStart(4096);\n        textPositionSelector.setEnd(4104);\n\n        specificResource.setSelector(textPositionSelector);\n\n        \/\/ Create the actual target\n        ResourceObject source = anno4j.createObject(ResourceObject.class);\n        source.setResourceAsString(\"http:\/\/example.org\/source1\");\n        specificResource.setSource(source);\n\n        annotation.addTarget(specificResource);\n\n        \/\/ Query persisted object\n        List<Annotation> result = anno4j.findAll(Annotation.class);\n\n        assertEquals(1, result.size());\n\n        Annotation resultObject = result.get(0);\n\n        assertEquals(annotation.getResource(), resultObject.getResource());\n    }\n}\n","code_block_diff":"{'diff_0': ['    public void setUp() throws Exception {\\n        this.anno4j = new Anno4j();\\n    }\\n    \\n\\n    @Test\\n    public void exampleTest() throws Exception {\\n', '    public void setUp() throws Exception {\\n        this.anno4j = new Anno4j();\\n    }\\n\\n    @Test\\n    public void exampleTest() throws Exception {\\n']}","subject":"","message":"Revert \"banane\"\n\nThis reverts commit 211901c4374192d810be0c09c6da9cd5de81fb04.\n\n","lang":"Java","license":"","repos":""}
{"commit":"8a695e0d99b441ea8cf5875398c117255e5267f3","old_file":"aws-lambda-java-events\/src\/main\/java\/com\/amazonaws\/services\/lambda\/runtime\/events\/ConnectEvent.java","new_file":"aws-lambda-java-events\/src\/main\/java\/com\/amazonaws\/services\/lambda\/runtime\/events\/ConnectEvent.java","old_contents":"\/*\n * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http:\/\/aws.amazon.com\/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n *\/\n\npackage com.amazonaws.services.lambda.runtime.events;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n\/**\n * Class to represent an Amazon Connect contact flow event.\n *\n * @see <a href=\"https:\/\/docs.aws.amazon.com\/connect\/latest\/adminguide\/connect-lambda-functions.html>Connect Lambda Functions<\/a>\n *\n * @author msailes <msailes@amazon.co.uk>\n *\/\n\n@Data\n@Builder(setterPrefix = \"with\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class ConnectEvent implements Serializable {\n\n    @JsonProperty(\"Details\")\n    private Details details;\n\n    @JsonProperty(\"Name\")\n    private String name;\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Details implements Serializable {\n\n        @JsonProperty(\"ContactData\")\n        private ContactData contactData;\n\n        @JsonProperty(\"Parameters\")\n        private Map<String,Object> parameters;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class ContactData implements Serializable {\n\n        @JsonProperty(\"Attributes\")\n        private Map<String, String> attributes;\n\n        @JsonProperty(\"Channel\")\n        private String channel;\n\n        @JsonProperty(\"ContactId\")\n        private String contactId;\n\n        @JsonProperty(\"CustomerEndpoint\")\n        private CustomerEndpoint customerEndpoint;\n\n        @JsonProperty(\"InitialContactId\")\n        private String initialContactId;\n\n        @JsonProperty(\"InitiationMethod\")\n        private String initiationMethod;\n\n        @JsonProperty(\"InstanceARN\")\n        private String instanceArn;\n\n        @JsonProperty(\"MediaStreams\")\n        private MediaStreams mediaStreams;\n\n        @JsonProperty(\"PreviousContactId\")\n        private String previousContactId;\n\n        @JsonProperty(\"Queue\")\n        private String queue;\n\n        @JsonProperty(\"SystemEndpoint\")\n        private SystemEndpoint systemEndpoint;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class CustomerEndpoint implements Serializable {\n\n        @JsonProperty(\"Address\")\n        private String address;\n\n        @JsonProperty(\"Type\")\n        private String type;\n    }\n\n    \/**\n     * Class to represent a MediaStreams object for Kinesis Media Streaming.\n     *\n     * @see <a href=\"https:\/\/docs.aws.amazon.com\/connect\/latest\/adminguide\/media-streaming-attributes.html\">Media Streaming Attributes<\/a>\n     *\n     *\/\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class MediaStreams implements Serializable {\n        @JsonProperty(\"Customer\")\n        private Customer customer;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Customer implements Serializable {\n        @JsonProperty(\"Audio\")\n        private Audio audio;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Audio implements Serializable {\n        @JsonProperty(\"StartFragmentNumber\")\n        private String startFragmentNumber;\n        @JsonProperty(\"StartTimestamp\")\n        private String startTimestamp;\n        @JsonProperty(\"StreamARN\")\n        private String streamARN;\n        @JsonProperty(\"StopFragmentNumber\")\n        private String stopFragmentNumber;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class SystemEndpoint implements Serializable {\n\n        @JsonProperty(\"Address\")\n        private String address;\n\n        @JsonProperty(\"Type\")\n        private String type;\n    }\n}\n","new_contents":"\/*\n * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http:\/\/aws.amazon.com\/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n *\/\n\npackage com.amazonaws.services.lambda.runtime.events;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n\/**\n * Class to represent an Amazon Connect contact flow event.\n *\n * @see <a href=\"https:\/\/docs.aws.amazon.com\/connect\/latest\/adminguide\/connect-lambda-functions.html>Connect Lambda Functions<\/a>\n *\n * @author msailes <msailes@amazon.co.uk>\n *\/\n\n@Data\n@Builder(setterPrefix = \"with\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class ConnectEvent implements Serializable {\n\n    @JsonProperty(\"Details\")\n    private Details details;\n\n    @JsonProperty(\"Name\")\n    private String name;\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Details implements Serializable {\n\n        @JsonProperty(\"ContactData\")\n        private ContactData contactData;\n\n        @JsonProperty(\"Parameters\")\n        private Map<String,Object> parameters;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class ContactData implements Serializable {\n\n        @JsonProperty(\"Attributes\")\n        private Map<String, String> attributes;\n\n        @JsonProperty(\"Channel\")\n        private String channel;\n\n        @JsonProperty(\"ContactId\")\n        private String contactId;\n\n        @JsonProperty(\"CustomerEndpoint\")\n        private CustomerEndpoint customerEndpoint;\n\n        @JsonProperty(\"InitialContactId\")\n        private String initialContactId;\n\n        @JsonProperty(\"InitiationMethod\")\n        private String initiationMethod;\n\n        @JsonProperty(\"InstanceARN\")\n        private String instanceArn;\n\n        @JsonProperty(\"MediaStreams\")\n        private MediaStreams mediaStreams;\n\n        @JsonProperty(\"PreviousContactId\")\n        private String previousContactId;\n\n        @JsonProperty(\"Queue\")\n        private Queue queue;\n\n        @JsonProperty(\"SystemEndpoint\")\n        private SystemEndpoint systemEndpoint;\n    }\n\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Queue implements Serializable {\n        @JsonProperty(\"ARN\")\n        private String arn;\n        @JsonProperty(\"Name\")\n        private String name;\n        @JsonProperty(\"OutboundCallerId\")\n        private OutboundCallerId outboundCallerId;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class OutboundCallerId implements Serializable {\n        @JsonProperty(\"Address\")\n        private String address;\n        @JsonProperty(\"Type\")\n        private String type;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class CustomerEndpoint implements Serializable {\n\n        @JsonProperty(\"Address\")\n        private String address;\n\n        @JsonProperty(\"Type\")\n        private String type;\n    }\n\n    \/**\n     * Class to represent a MediaStreams object for Kinesis Media Streaming.\n     *\n     * @see <a href=\"https:\/\/docs.aws.amazon.com\/connect\/latest\/adminguide\/media-streaming-attributes.html\">Media Streaming Attributes<\/a>\n     *\n     *\/\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class MediaStreams implements Serializable {\n        @JsonProperty(\"Customer\")\n        private Customer customer;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Customer implements Serializable {\n        @JsonProperty(\"Audio\")\n        private Audio audio;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class Audio implements Serializable {\n        @JsonProperty(\"StartFragmentNumber\")\n        private String startFragmentNumber;\n        @JsonProperty(\"StartTimestamp\")\n        private String startTimestamp;\n        @JsonProperty(\"StreamARN\")\n        private String streamARN;\n        @JsonProperty(\"StopFragmentNumber\")\n        private String stopFragmentNumber;\n    }\n\n    @Data\n    @Builder(setterPrefix = \"with\")\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class SystemEndpoint implements Serializable {\n\n        @JsonProperty(\"Address\")\n        private String address;\n\n        @JsonProperty(\"Type\")\n        private String type;\n    }\n}\n","code_block_diff":"{'diff_0': ['        private String previousContactId;\\n\\n        @JsonProperty(\"Queue\")\\n        private String queue;\\n\\n        @JsonProperty(\"SystemEndpoint\")\\n        private SystemEndpoint systemEndpoint;\\n    }\\n\\n    @Data\\n    @Builder(setterPrefix = \"with\")\\n    @NoArgsConstructor\\n', '        private String previousContactId;\\n\\n        @JsonProperty(\"Queue\")\\n        private Queue queue;\\n\\n        @JsonProperty(\"SystemEndpoint\")\\n        private SystemEndpoint systemEndpoint;\\n    }\\n\\n\\n    @Data\\n    @Builder(setterPrefix = \"with\")\\n    @NoArgsConstructor\\n    @AllArgsConstructor\\n    public static class Queue implements Serializable {\\n        @JsonProperty(\"ARN\")\\n        private String arn;\\n        @JsonProperty(\"Name\")\\n        private String name;\\n        @JsonProperty(\"OutboundCallerId\")\\n        private OutboundCallerId outboundCallerId;\\n    }\\n\\n    @Data\\n    @Builder(setterPrefix = \"with\")\\n    @NoArgsConstructor\\n    @AllArgsConstructor\\n    public static class OutboundCallerId implements Serializable {\\n        @JsonProperty(\"Address\")\\n        private String address;\\n        @JsonProperty(\"Type\")\\n        private String type;\\n    }\\n\\n    @Data\\n    @Builder(setterPrefix = \"with\")\\n    @NoArgsConstructor\\n']}","subject":"","message":"update ConnectEvent queue definition (#459)\n\nCo-authored-by: xudingyu <dingyux@amazon.com>\n","lang":"Java","license":"","repos":""}
{"commit":"cfadfbe31ba6c8742ab6fba63e78f34fd25a6a5d","old_file":"neatle\/src\/main\/java\/si\/inova\/neatle\/source\/CalllableInputSource.java","new_file":"neatle\/src\/main\/java\/si\/inova\/neatle\/source\/CalllableInputSource.java","old_contents":"package si.inova.neatle.source;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.concurrent.Callable;\r\n\r\n\/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2017 Inova IT\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\/\r\n\r\n\/**\r\n * A input source that invokes {@link Callable} just before the first chunk is requested.\r\n *\/\r\npublic class CalllableInputSource implements InputSource {\r\n\r\n    private final Callable<ByteBuffer> source;\r\n\r\n    private ByteBuffer byteBuffer;\r\n\r\n    public CalllableInputSource(Callable<ByteBuffer> source) {\r\n        this.source = source;\r\n    }\r\n\r\n    @Override\r\n    public void open() throws IOException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public byte[] nextChunk() throws IOException {\r\n        if (byteBuffer == null) {\r\n            try {\r\n                byteBuffer = source.call();\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Failed to get bytes from callback\");\r\n            }\r\n        }\r\n        if (byteBuffer == null || !byteBuffer.hasRemaining()) {\r\n            return null;\r\n        }\r\n\r\n        int remaining = Math.min(byteBuffer.remaining(), 20);\r\n        byte[] chunk = new byte[remaining];\r\n\r\n        byteBuffer.get(chunk);\r\n        return chunk;\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void close() throws IOException {\r\n        byteBuffer = null;\r\n    }\r\n}\r\n","new_contents":"package si.inova.neatle.source;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.concurrent.Callable;\r\n\r\n\/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2017 Inova IT\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\/\r\n\r\n\/**\r\n * A input source that invokes {@link Callable} just before the first chunk is requested.\r\n *\/\r\npublic class CalllableInputSource implements InputSource {\r\n\r\n    private final Callable<ByteBuffer> source;\r\n\r\n    private ByteBuffer byteBuffer;\r\n\r\n    public CalllableInputSource(Callable<ByteBuffer> source) {\r\n        this.source = source;\r\n    }\r\n\r\n    @Override\r\n    public void open() throws IOException {\r\n        \/\/nothing to do\r\n    }\r\n\r\n    @Override\r\n    public byte[] nextChunk() throws IOException {\r\n        if (byteBuffer == null) {\r\n            try {\r\n                byteBuffer = source.call();\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Failed to get bytes from callback\");\r\n            }\r\n        }\r\n        if (byteBuffer == null || !byteBuffer.hasRemaining()) {\r\n            return null;\r\n        }\r\n\r\n        int remaining = Math.min(byteBuffer.remaining(), 20);\r\n        byte[] chunk = new byte[remaining];\r\n\r\n        byteBuffer.get(chunk);\r\n        return chunk;\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void close() throws IOException {\r\n        byteBuffer = null;\r\n    }\r\n}\r\n","code_block_diff":"{'diff_0': ['\\n    @Override\\n    public void open() throws IOException {\\n\\n    }\\n\\n    @Override\\n', '\\n    @Override\\n    public void open() throws IOException {\\n        \/\/nothing to do\\n    }\\n\\n    @Override\\n']}","subject":"","message":"Codacy: Document empty method body\n\n","lang":"Java","license":"","repos":""}
{"commit":"efcb7cb77a7a78298ec37b95c4e4e3df0a4cbdcf","old_file":"example\/SmartlingApiExample.java","new_file":"example\/SmartlingApiExample.java","old_contents":"\/*\n * Copyright 2012 Smartling, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this work except in compliance with the License.\n * You may obtain a copy of the License in the LICENSE file, or at:\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\nimport com.smartling.api.sdk.dto.file.FileLastModified;\nimport com.smartling.api.sdk.dto.file.StringResponse;\nimport com.smartling.api.sdk.dto.file.UploadFileData;\nimport com.smartling.api.sdk.exceptions.SmartlingApiException;\nimport com.smartling.api.sdk.file.FileApiClient;\nimport com.smartling.api.sdk.file.FileApiClientImpl;\nimport com.smartling.api.sdk.file.FileType;\nimport com.smartling.api.sdk.file.parameters.FileLastModifiedParameterBuilder;\nimport com.smartling.api.sdk.file.parameters.FileListSearchParameterBuilder;\nimport com.smartling.api.sdk.file.parameters.FileUploadParameterBuilder;\nimport com.smartling.api.sdk.file.parameters.GetFileParameterBuilder;\nimport com.smartling.api.sdk.file.parameters.RetrievalType;\nimport com.smartling.api.sdk.file.response.EmptyResponse;\nimport com.smartling.api.sdk.file.response.FileList;\nimport com.smartling.api.sdk.file.response.FileStatus;\n\nimport java.io.File;\n\npublic class SmartlingApiExample\n{\n    private static final String   USER_ID       = \"YOUR-USER-ID\";\n    private static final String   USER_SECRET   = \"YOUR-USER-SECRET\";\n    private static final String   PROJECT_ID    = \"YOUR-PROJECT-ID\";\n    private static final String   LOCALE        = \"YOUR-LOCALE\";\n\n    private static final String   PATH_TO_FILE  = \"resources\/test.properties\";\n    private static final String   FILE_ENCODING = \"UTF-8\";\n    private static final FileType FILE_TYPE     = FileType.JAVA_PROPERTIES;\n    private static final String   CALLBACK_URL  = null;\n\n    public static void main(String args[]) throws SmartlingApiException\n    {\n        FileApiClient smartlingFAPI = new FileApiClientImpl.Builder(PROJECT_ID).authWithUserIdAndSecret(USER_ID, USER_SECRET).build();\n\n        \/\/ upload the file\n        File file = new File(PATH_TO_FILE);\n        FileUploadParameterBuilder fileUploadParameterBuilder = new FileUploadParameterBuilder(FILE_TYPE, getFileUri(file));\n        fileUploadParameterBuilder\n                .charset(FILE_ENCODING)\n                .approveContent(false)\n                .callbackUrl(CALLBACK_URL);\n        UploadFileData uploadFileResponse = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\n        System.out.println(uploadFileResponse);\n\n        \/\/ get last modified date\n        FileLastModified lastModifiedResponse = smartlingFAPI.getLastModified(new FileLastModifiedParameterBuilder(getFileUri(file)).locale(LOCALE));\n        System.out.println(lastModifiedResponse);\n\n        \/\/ rename the file\n        final String fileIdentifier = \"myTestFileIdentifier\";\n        EmptyResponse renameFileResponse = smartlingFAPI.renameFile(getFileUri(file), fileIdentifier);\n        System.out.println(renameFileResponse);\n\n        \/\/ run a search for files\n        FileList filesListResponse = smartlingFAPI.getFilesList(new FileListSearchParameterBuilder().withUriMask(fileIdentifier));\n        System.out.println(filesListResponse);\n\n        \/\/ check the file status\n        FileStatus fileStatusResponse = smartlingFAPI.getFileStatus(fileIdentifier);\n        System.out.println(fileStatusResponse);\n\n        \/\/ get the file back, including any translations that have been published.\n        StringResponse translatedContent = smartlingFAPI.getFile(new GetFileParameterBuilder(fileIdentifier, LOCALE).retrievalType(RetrievalType.PUBLISHED));\n        System.out.println(translatedContent.getContents());\n\n        \/\/ delete the file\n        EmptyResponse deleteFileResponse = smartlingFAPI.deleteFile(fileIdentifier);\n        System.out.println(deleteFileResponse);\n    }\n\n    private static String getFileUri(File file)\n    {\n        return file.getName();\n    }\n}\n","new_contents":"package com.smartling.api.stests.fileusecases.test123;\/*\n * Copyright 2012 Smartling, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this work except in compliance with the License.\n * You may obtain a copy of the License in the LICENSE file, or at:\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\nimport com.smartling.api.sdk.dto.file.FileLastModified;\nimport com.smartling.api.sdk.dto.file.StringResponse;\nimport com.smartling.api.sdk.dto.file.UploadFileData;\nimport com.smartling.api.sdk.exceptions.SmartlingApiException;\nimport com.smartling.api.sdk.file.FileApiClient;\nimport com.smartling.api.sdk.file.FileApiClientImpl;\nimport com.smartling.api.sdk.file.FileType;\nimport com.smartling.api.sdk.file.parameters.*;\nimport com.smartling.api.sdk.file.response.EmptyResponse;\nimport com.smartling.api.sdk.file.response.FileList;\nimport com.smartling.api.sdk.file.response.FileStatus;\nimport com.smartling.qa.commons.junit.Assert;\n\nimport java.io.File;\n\npublic class SmartlingApiExample\n{\n    private static final String   USER_ID       = \"YOUR-USER-ID\";\n    private static final String   USER_SECRET   = \"YOUR-USER-SECRET\";\n    private static final String   PROJECT_ID    = \"YOUR-PROJECT-ID\";\n    private static final String   LOCALE        = \"YOUR-LOCALE\";\n\n    private static final String   PATH_TO_FILE  = \"resources\/testUTF16.properties\";\n    private static final String   FILE_ENCODING = \"UTF-16\";\n    private static final FileType FILE_TYPE     = FileType.JAVA_PROPERTIES;\n    private static final String   CALLBACK_URL  = null;\n\n    public static void main(String args[]) throws SmartlingApiException\n    {\n        FileApiClient smartlingFAPI = new FileApiClientImpl.Builder(PROJECT_ID).authWithUserIdAndSecret(USER_ID, USER_SECRET).build();\n\n        \/\/ upload the file\n        File file = new File(PATH_TO_FILE);\n        FileUploadParameterBuilder fileUploadParameterBuilder = new FileUploadParameterBuilder(FILE_TYPE, getFileUri(file));\n        fileUploadParameterBuilder\n                .charset(FILE_ENCODING)\n                .approveContent(false)\n                .callbackUrl(CALLBACK_URL);\n\n        UploadFileData uploadFileResponse = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\n        System.out.println(uploadFileResponse);\n\n        Assert.assertFalse(uploadFileResponse.isOverwritten());\n\n\n        UploadFileData uploadFileResponse2 = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\n        System.out.println(uploadFileResponse2);\n\n        Assert.assertTrue(uploadFileResponse.isOverwritten());\n\n        \/\/ get last modified date\n        FileLastModified lastModifiedResponse = smartlingFAPI.getLastModified(new FileLastModifiedParameterBuilder(getFileUri(file)).locale(LOCALE));\n        System.out.println(lastModifiedResponse);\n\n        \/\/ rename the file\n        final String fileIdentifier = \"myTestFileIdentifier\";\n        EmptyResponse renameFileResponse = smartlingFAPI.renameFile(getFileUri(file), fileIdentifier);\n        System.out.println(renameFileResponse);\n\n        \/\/ run a search for files\n        FileList filesListResponse = smartlingFAPI.getFilesList(new FileListSearchParameterBuilder().withUriMask(fileIdentifier));\n        System.out.println(filesListResponse);\n\n        \/\/ check the file status\n        FileStatus fileStatusResponse = smartlingFAPI.getFileStatus(fileIdentifier);\n        System.out.println(fileStatusResponse);\n\n        \/\/ get the file back, including any translations that have been published.\n        StringResponse translatedContent1 = smartlingFAPI.getOriginalFile(new GetOriginalFileParameterBuilder(fileIdentifier));\n        System.out.println(translatedContent1.getContents());\n\n\n        \/\/ get the file back, including any translations that have been published.\n        StringResponse originalContent = smartlingFAPI.getFile(new GetFileParameterBuilder(fileIdentifier, LOCALE).retrievalType(RetrievalType.PUBLISHED));\n        System.out.println(originalContent.getContents());\n\n        Assert.assertEquals(originalContent.getEncoding(), FILE_ENCODING);\n\n        \/\/ delete the file\n        EmptyResponse deleteFileResponse = smartlingFAPI.deleteFile(fileIdentifier);\n        System.out.println(deleteFileResponse);\n    }\n\n    private static String getFileUri(File file)\n    {\n        return file.getName();\n    }\n}\n","code_block_diff":"{'diff_0': ['\/*\\n * Copyright 2012 Smartling, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \"License\");\\n', 'package com.smartling.api.stests.fileusecases.test123;\/*\\n * Copyright 2012 Smartling, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \"License\");\\n'], 'diff_1': ['import com.smartling.api.sdk.file.FileApiClient;\\nimport com.smartling.api.sdk.file.FileApiClientImpl;\\nimport com.smartling.api.sdk.file.FileType;\\nimport com.smartling.api.sdk.file.parameters.FileLastModifiedParameterBuilder;\\nimport com.smartling.api.sdk.file.parameters.FileListSearchParameterBuilder;\\nimport com.smartling.api.sdk.file.parameters.FileUploadParameterBuilder;\\nimport com.smartling.api.sdk.file.parameters.GetFileParameterBuilder;\\nimport com.smartling.api.sdk.file.parameters.RetrievalType;\\nimport com.smartling.api.sdk.file.response.EmptyResponse;\\nimport com.smartling.api.sdk.file.response.FileList;\\nimport com.smartling.api.sdk.file.response.FileStatus;\\n\\nimport java.io.File;\\n\\n', 'import com.smartling.api.sdk.file.FileApiClient;\\nimport com.smartling.api.sdk.file.FileApiClientImpl;\\nimport com.smartling.api.sdk.file.FileType;\\nimport com.smartling.api.sdk.file.parameters.*;\\nimport com.smartling.api.sdk.file.response.EmptyResponse;\\nimport com.smartling.api.sdk.file.response.FileList;\\nimport com.smartling.api.sdk.file.response.FileStatus;\\nimport com.smartling.qa.commons.junit.Assert;\\n\\nimport java.io.File;\\n\\n'], 'diff_2': ['    private static final String   PROJECT_ID    = \"YOUR-PROJECT-ID\";\\n    private static final String   LOCALE        = \"YOUR-LOCALE\";\\n\\n    private static final String   PATH_TO_FILE  = \"resources\/test.properties\";\\n    private static final String   FILE_ENCODING = \"UTF-8\";\\n    private static final FileType FILE_TYPE     = FileType.JAVA_PROPERTIES;\\n    private static final String   CALLBACK_URL  = null;\\n\\n', '    private static final String   PROJECT_ID    = \"YOUR-PROJECT-ID\";\\n    private static final String   LOCALE        = \"YOUR-LOCALE\";\\n\\n    private static final String   PATH_TO_FILE  = \"resources\/testUTF16.properties\";\\n    private static final String   FILE_ENCODING = \"UTF-16\";\\n    private static final FileType FILE_TYPE     = FileType.JAVA_PROPERTIES;\\n    private static final String   CALLBACK_URL  = null;\\n\\n'], 'diff_3': ['                .charset(FILE_ENCODING)\\n                .approveContent(false)\\n                .callbackUrl(CALLBACK_URL);\\n        UploadFileData uploadFileResponse = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\\n        System.out.println(uploadFileResponse);\\n\\n        \/\/ get last modified date\\n        FileLastModified lastModifiedResponse = smartlingFAPI.getLastModified(new FileLastModifiedParameterBuilder(getFileUri(file)).locale(LOCALE));\\n        System.out.println(lastModifiedResponse);\\n', '                .charset(FILE_ENCODING)\\n                .approveContent(false)\\n                .callbackUrl(CALLBACK_URL);\\n\\n        UploadFileData uploadFileResponse = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\\n        System.out.println(uploadFileResponse);\\n\\n        Assert.assertFalse(uploadFileResponse.isOverwritten());\\n\\n\\n        UploadFileData uploadFileResponse2 = smartlingFAPI.uploadFile(file, fileUploadParameterBuilder);\\n        System.out.println(uploadFileResponse2);\\n\\n        Assert.assertTrue(uploadFileResponse.isOverwritten());\\n\\n        \/\/ get last modified date\\n        FileLastModified lastModifiedResponse = smartlingFAPI.getLastModified(new FileLastModifiedParameterBuilder(getFileUri(file)).locale(LOCALE));\\n        System.out.println(lastModifiedResponse);\\n'], 'diff_4': ['        System.out.println(fileStatusResponse);\\n\\n        \/\/ get the file back, including any translations that have been published.\\n        StringResponse translatedContent = smartlingFAPI.getFile(new GetFileParameterBuilder(fileIdentifier, LOCALE).retrievalType(RetrievalType.PUBLISHED));\\n        System.out.println(translatedContent.getContents());\\n\\n        \/\/ delete the file\\n        EmptyResponse deleteFileResponse = smartlingFAPI.deleteFile(fileIdentifier);\\n', '        System.out.println(fileStatusResponse);\\n\\n        \/\/ get the file back, including any translations that have been published.\\n        StringResponse translatedContent1 = smartlingFAPI.getOriginalFile(new GetOriginalFileParameterBuilder(fileIdentifier));\\n        System.out.println(translatedContent1.getContents());\\n\\n\\n        \/\/ get the file back, including any translations that have been published.\\n        StringResponse originalContent = smartlingFAPI.getFile(new GetFileParameterBuilder(fileIdentifier, LOCALE).retrievalType(RetrievalType.PUBLISHED));\\n        System.out.println(originalContent.getContents());\\n\\n        Assert.assertEquals(originalContent.getEncoding(), FILE_ENCODING);\\n\\n        \/\/ delete the file\\n        EmptyResponse deleteFileResponse = smartlingFAPI.deleteFile(fileIdentifier);\\n']}","subject":"","message":"added new tests in example\n\n","lang":"Java","license":"","repos":""}
{"commit":"0bd96520c7db5f77f3ff0d6690e50a6c8ddbf9e4","old_file":"jobqueue\/src\/main\/java\/com\/birbit\/android\/jobqueue\/scheduling\/FrameworkScheduler.java","new_file":"jobqueue\/src\/main\/java\/com\/birbit\/android\/jobqueue\/scheduling\/FrameworkScheduler.java","old_contents":"package com.birbit.android.jobqueue.scheduling;\n\nimport android.annotation.TargetApi;\nimport android.app.job.JobInfo;\nimport android.app.job.JobParameters;\nimport android.app.job.JobScheduler;\nimport android.app.job.JobService;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PersistableBundle;\nimport android.support.annotation.Nullable;\n\nimport com.birbit.android.jobqueue.log.JqLog;\nimport com.birbit.android.jobqueue.network.NetworkUtil;\n\nimport java.util.UUID;\n\n\/**\n * Scheduler implementation that uses the frameworks' scheduler API.\n *\/\n@TargetApi(21)\nclass FrameworkScheduler extends Scheduler {\n    private static final String KEY_UUID = \"uuid\";\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_DELAY = \"delay\";\n    private static final String KEY_NETWORK_STATUS = \"networkStatus\";\n\n    private JobScheduler jobScheduler;\n    private static SharedPreferences preferences;\n    private ComponentName componentName;\n    \/\/ set when service invokes, cleared when service dies\n    @Nullable private JobService jobService;\n    private final Class<? extends FrameworkJobSchedulerService> serviceImpl;\n\n    FrameworkScheduler(Class<? extends FrameworkJobSchedulerService> serviceImpl) {\n        this.serviceImpl = serviceImpl;\n    }\n\n    void setJobService(@Nullable JobService jobService) {\n        this.jobService = jobService;\n    }\n\n    private static SharedPreferences getPreferences(Context context) {\n        synchronized (FrameworkScheduler.class) {\n            if (preferences == null) {\n                preferences = context.getSharedPreferences(\"jobqueue_fw_scheduler\",\n                        Context.MODE_PRIVATE);\n            }\n            return preferences;\n        }\n    }\n\n    private ComponentName getComponentName() {\n        if (componentName == null) {\n            componentName = new ComponentName(getApplicationContext().getPackageName(),\n                    serviceImpl.getCanonicalName());\n        }\n        return componentName;\n    }\n\n    \/**\n     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not\n     * to conflict with the rest of your application.\n     *\n     * @return A unique integer id for the next Job request to be sent to system scheduler\n     *\/\n    private int createId() {\n        synchronized (FrameworkScheduler.class) {\n            final SharedPreferences preferences = getPreferences(getApplicationContext());\n            final int id = preferences.getInt(KEY_ID, 0) + 1;\n            preferences.edit().putInt(KEY_ID, id).commit();\n            return id;\n        }\n    }\n\n    private JobScheduler getJobScheduler() {\n        if (jobScheduler == null) {\n            jobScheduler = (JobScheduler) getApplicationContext()\n                    .getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        }\n        return jobScheduler;\n    }\n\n    @Override\n    public void request(SchedulerConstraint constraint) {\n        JobScheduler jobScheduler = getJobScheduler();\n\n        final int id = createId();\n        JobInfo.Builder builder = new JobInfo.Builder(id, getComponentName())\n                .setExtras(toPersistentBundle(constraint))\n                .setPersisted(true);\n        switch (constraint.getNetworkStatus()) {\n            case NetworkUtil.UNMETERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n                break;\n            case NetworkUtil.METERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);\n                break;\n            default:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE);\n                builder.setRequiresDeviceIdle(true);\n                break;\n        }\n        if (constraint.getOverrideDeadlineInMs() != null) {\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\n        }\n        int scheduled = jobScheduler.schedule(builder.build());\n        JqLog.d(\"[FW Scheduler] scheduled a framework job. Success? %s id: %d\" +\n                \" created id: %d\", scheduled > 0, scheduled, id);\n    }\n\n    @Override\n    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] on finished job %s. reschedule:%s\", constraint, reschedule);\n        }\n        JobService service = this.jobService;\n        if (service == null) {\n            JqLog.e(\"[FW Scheduler] scheduler onfinished is called but i don't have a job service\");\n            return;\n        }\n\n        Object data = constraint.getData();\n        if (data instanceof JobParameters) {\n            JobParameters params = (JobParameters) data;\n            service.jobFinished(params, reschedule);\n        } else {\n            JqLog.e(\"[FW Scheduler] cannot obtain the job parameters\");\n        }\n\n    }\n\n    @Override\n    public void cancelAll() {\n        JqLog.d(\"[FW Scheduler] cancel all\");\n        getJobScheduler().cancelAll();\n    }\n\n    private static PersistableBundle toPersistentBundle(SchedulerConstraint constraint) {\n        PersistableBundle bundle = new PersistableBundle();\n        \/\/ put boolean is api 22\n        bundle.putString(KEY_UUID, constraint.getUuid());\n        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());\n        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());\n        return bundle;\n    }\n\n    private static SchedulerConstraint fromBundle(PersistableBundle bundle) {\n        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));\n        if (constraint.getUuid() == null) {\n            \/\/ backward compatibility\n            constraint.setUuid(UUID.randomUUID().toString());\n        }\n        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));\n        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));\n        return constraint;\n    }\n\n    boolean onStartJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] start job %s %d\", constraint, params.getJobId());\n        }\n        constraint.setData(params);\n        return start(constraint);\n    }\n\n    boolean onStopJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        return stop(constraint);\n    }\n}\n","new_contents":"package com.birbit.android.jobqueue.scheduling;\n\nimport android.annotation.TargetApi;\nimport android.app.job.JobInfo;\nimport android.app.job.JobParameters;\nimport android.app.job.JobScheduler;\nimport android.app.job.JobService;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PersistableBundle;\nimport android.support.annotation.Nullable;\n\nimport com.birbit.android.jobqueue.log.JqLog;\nimport com.birbit.android.jobqueue.network.NetworkUtil;\n\nimport java.util.UUID;\n\n\/**\n * Scheduler implementation that uses the frameworks' scheduler API.\n *\/\n@TargetApi(21)\nclass FrameworkScheduler extends Scheduler {\n    private static final String KEY_UUID = \"uuid\";\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_DELAY = \"delay\";\n    private static final String KEY_NETWORK_STATUS = \"networkStatus\";\n\n    private JobScheduler jobScheduler;\n    private static SharedPreferences preferences;\n    private ComponentName componentName;\n    \/\/ set when service invokes, cleared when service dies\n    @Nullable private JobService jobService;\n    private final Class<? extends FrameworkJobSchedulerService> serviceImpl;\n\n    FrameworkScheduler(Class<? extends FrameworkJobSchedulerService> serviceImpl) {\n        this.serviceImpl = serviceImpl;\n    }\n\n    void setJobService(@Nullable JobService jobService) {\n        this.jobService = jobService;\n    }\n\n    private static SharedPreferences getPreferences(Context context) {\n        synchronized (FrameworkScheduler.class) {\n            if (preferences == null) {\n                preferences = context.getSharedPreferences(\"jobqueue_fw_scheduler\",\n                        Context.MODE_PRIVATE);\n            }\n            return preferences;\n        }\n    }\n\n    private ComponentName getComponentName() {\n        if (componentName == null) {\n            componentName = new ComponentName(getApplicationContext().getPackageName(),\n                    serviceImpl.getCanonicalName());\n        }\n        return componentName;\n    }\n\n    \/**\n     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not\n     * to conflict with the rest of your application.\n     *\n     * @return A unique integer id for the next Job request to be sent to system scheduler\n     *\/\n    private int createId() {\n        synchronized (FrameworkScheduler.class) {\n            final SharedPreferences preferences = getPreferences(getApplicationContext());\n            final int id = preferences.getInt(KEY_ID, 0) + 1;\n            preferences.edit().putInt(KEY_ID, id).commit();\n            return id;\n        }\n    }\n\n    private JobScheduler getJobScheduler() {\n        if (jobScheduler == null) {\n            jobScheduler = (JobScheduler) getApplicationContext()\n                    .getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        }\n        return jobScheduler;\n    }\n\n    @Override\n    public void request(SchedulerConstraint constraint) {\n        JobScheduler jobScheduler = getJobScheduler();\n\n        final int id = createId();\n        JobInfo.Builder builder = new JobInfo.Builder(id, getComponentName())\n                .setExtras(toPersistentBundle(constraint))\n                .setPersisted(true);\n        switch (constraint.getNetworkStatus()) {\n            case NetworkUtil.UNMETERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n                break;\n            case NetworkUtil.METERED:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);\n                break;\n            default:\n                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE);\n                builder.setRequiresDeviceIdle(true);\n                break;\n        }\n        if (constraint.getDelayInMs() > 0) {\n            builder.setMinimumLatency(constraint.getDelayInMs());\n        }\n        if (constraint.getOverrideDeadlineInMs() != null) {\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\n        }\n        int scheduled = jobScheduler.schedule(builder.build());\n        JqLog.d(\"[FW Scheduler] scheduled a framework job. Success? %s id: %d\" +\n                \" created id: %d\", scheduled > 0, scheduled, id);\n    }\n\n    @Override\n    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] on finished job %s. reschedule:%s\", constraint, reschedule);\n        }\n        JobService service = this.jobService;\n        if (service == null) {\n            JqLog.e(\"[FW Scheduler] scheduler onfinished is called but i don't have a job service\");\n            return;\n        }\n\n        Object data = constraint.getData();\n        if (data instanceof JobParameters) {\n            JobParameters params = (JobParameters) data;\n            service.jobFinished(params, reschedule);\n        } else {\n            JqLog.e(\"[FW Scheduler] cannot obtain the job parameters\");\n        }\n\n    }\n\n    @Override\n    public void cancelAll() {\n        JqLog.d(\"[FW Scheduler] cancel all\");\n        getJobScheduler().cancelAll();\n    }\n\n    private static PersistableBundle toPersistentBundle(SchedulerConstraint constraint) {\n        PersistableBundle bundle = new PersistableBundle();\n        \/\/ put boolean is api 22\n        bundle.putString(KEY_UUID, constraint.getUuid());\n        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());\n        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());\n        return bundle;\n    }\n\n    private static SchedulerConstraint fromBundle(PersistableBundle bundle) {\n        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));\n        if (constraint.getUuid() == null) {\n            \/\/ backward compatibility\n            constraint.setUuid(UUID.randomUUID().toString());\n        }\n        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));\n        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));\n        return constraint;\n    }\n\n    boolean onStartJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        if (JqLog.isDebugEnabled()) {\n            JqLog.d(\"[FW Scheduler] start job %s %d\", constraint, params.getJobId());\n        }\n        constraint.setData(params);\n        return start(constraint);\n    }\n\n    boolean onStopJob(JobParameters params) {\n        SchedulerConstraint constraint = fromBundle(params.getExtras());\n        return stop(constraint);\n    }\n}\n","code_block_diff":"{'diff_0': ['                builder.setRequiresDeviceIdle(true);\\n                break;\\n        }\\n        if (constraint.getOverrideDeadlineInMs() != null) {\\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\\n        }\\n', '                builder.setRequiresDeviceIdle(true);\\n                break;\\n        }\\n        if (constraint.getDelayInMs() > 0) {\\n            builder.setMinimumLatency(constraint.getDelayInMs());\\n        }\\n        if (constraint.getOverrideDeadlineInMs() != null) {\\n            builder.setOverrideDeadline(constraint.getOverrideDeadlineInMs());\\n        }\\n']}","subject":"","message":"pass correct delay to the scheduler #187\n\n","lang":"Java","license":"","repos":""}
