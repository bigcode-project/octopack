{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"14167df6ccf4974d5b6c1d1d3860e5d104f0fd15","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"14167df6ccf4974d5b6c1d1d3860e5d104f0fd15","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"78d49a06d93dad641a810b5703f8ef024c60e24c","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"cf1902d1d8af1e1033ae8591c07239f0f223560e","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"4463e43a8ebc4f3f2cfd858fac840e87ef3a1a94","old_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/ErrorResponseBodyTest.java","new_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/ErrorResponseBodyTest.java","old_contents":"","new_contents":"package com.nike.riposte.server.error.handler;\n\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Tests the default methods of {@link ErrorResponseBody}.\n *\n * @author Nic Munroe\n *\/\npublic class ErrorResponseBodyTest {\n    @Test\n    public void bodyToSerialize_returns_same_instance_by_default() {\n        ErrorResponseBody instance = () -> \"someErrorId\";\n        assertThat(instance.bodyToSerialize()).isSameAs(instance);\n    }\n}","subject":"","message":"Clean up docs and tests for PR #99\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"53ce403c64a196fed429114ad8982a609dc223df","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"551ded88856e6dc6732c201716a5145238ce04d6","old_file":"riposte-core\/src\/test\/java\/com\/nike\/riposte\/server\/testutils\/ComponentTestUtils.java","new_file":"riposte-core\/src\/test\/java\/com\/nike\/riposte\/server\/testutils\/ComponentTestUtils.java","old_contents":"package com.nike.riposte.server.testutils;\n\nimport com.nike.backstopper.apierror.ApiError;\nimport com.nike.backstopper.model.DefaultErrorContractDTO;\nimport com.nike.internal.util.Pair;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport org.apache.commons.lang3.RandomUtils;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Deflater;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.Inflater;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.CharsetUtil;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static java.util.Arrays.stream;\nimport static org.apache.commons.lang3.StringUtils.containsOnly;\nimport static org.apache.commons.lang3.StringUtils.split;\nimport static org.apache.commons.lang3.StringUtils.substringAfter;\nimport static org.apache.commons.lang3.StringUtils.substringBefore;\nimport static org.apache.commons.lang3.StringUtils.substringBetween;\nimport static org.apache.commons.lang3.StringUtils.substringsBetween;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Helper methods for working with component tests.\n *\n * @author Nic Munroe\n *\/\npublic class ComponentTestUtils {\n\n    private static final String HEADER_SEPARATOR = \":\";\n    private static final String payloadDictionary = \"aBcDefGhiJkLmN@#$%\";\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static int findFreePort() throws IOException {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            return serverSocket.getLocalPort();\n        }\n    }\n\n    public static String generatePayload(int payloadSize) {\n        return generatePayload(payloadSize, payloadDictionary);\n    }\n\n    public static String generatePayload(int payloadSize, String dictionary) {\n        StringBuilder payload = new StringBuilder();\n\n        for(int i = 0; i < payloadSize; i++) {\n            int randomInt = RandomUtils.nextInt(0, dictionary.length() - 1);\n            payload.append(dictionary.charAt(randomInt));\n        }\n\n        return payload.toString();\n    }\n\n    public static ByteBuf createByteBufPayload(int payloadSize) {\n        return Unpooled.wrappedBuffer(generatePayload(payloadSize).getBytes(UTF_8));\n    }\n\n    public static byte[] gzipPayload(String payload) {\n        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bytesOut)) {\n            byte[] payloadBytes = payload.getBytes(UTF_8);\n            gzipOutputStream.write(payloadBytes);\n            gzipOutputStream.finish();\n            return bytesOut.toByteArray();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String ungzipPayload(byte[] compressed) {\n        try {\n            if ((compressed == null) || (compressed.length == 0)) {\n                throw new RuntimeException(\"Null\/empty compressed payload. is_null=\" + (compressed == null));\n            }\n\n            final StringBuilder outStr = new StringBuilder();\n            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(compressed));\n            final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(gis, \"UTF-8\"));\n\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                outStr.append(line);\n            }\n\n            return outStr.toString();\n        }\n        catch(IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static byte[] deflatePayload(String payload) {\n        Deflater deflater = new Deflater(6, false);\n        byte[] payloadBytes = payload.getBytes(UTF_8);\n        deflater.setInput(payloadBytes);\n        deflater.finish();\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!deflater.finished()) {\n            int count = deflater.deflate(buffer);\n            outputStream.write(buffer, 0, count);\n        }\n\n        return outputStream.toByteArray();\n    }\n\n    public static String inflatePayload(byte[] compressed) {\n        Inflater inflater = new Inflater();\n        inflater.setInput(compressed);\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!inflater.finished()) {\n            try {\n                int count = inflater.inflate(buffer);\n                outputStream.write(buffer, 0, count);\n            }\n            catch (DataFormatException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return new String(outputStream.toByteArray(), UTF_8);\n    }\n\n    public static String base64Encode(byte[] bytes) {\n        return Base64.getEncoder().encodeToString(bytes);\n    }\n\n    public static byte[] base64Decode(String encodedStr) {\n        return Base64.getDecoder().decode(encodedStr);\n    }\n\n    public enum CompressionType {\n        GZIP(ComponentTestUtils::gzipPayload,\n             ComponentTestUtils::ungzipPayload,\n             HttpHeaders.Values.GZIP),\n        DEFLATE(ComponentTestUtils::deflatePayload,\n                ComponentTestUtils::inflatePayload,\n                HttpHeaders.Values.DEFLATE),\n        IDENTITY(s -> s.getBytes(UTF_8),\n                 b -> new String(b, UTF_8),\n                 HttpHeaders.Values.IDENTITY);\n\n        private final Function<String, byte[]> compressionFunction;\n        private final Function<byte[], String> decompressionFunction;\n        public final String contentEncodingHeaderValue;\n\n        CompressionType(Function<String, byte[]> compressionFunction,\n                        Function<byte[], String> decompressionFunction,\n                        String contentEncodingHeaderValue) {\n            this.compressionFunction = compressionFunction;\n            this.decompressionFunction = decompressionFunction;\n            this.contentEncodingHeaderValue = contentEncodingHeaderValue;\n        }\n\n        public byte[] compress(String s) {\n            return compressionFunction.apply(s);\n        }\n\n        public String decompress(byte[] compressed) {\n            return decompressionFunction.apply(compressed);\n        }\n    }\n\n    public static Bootstrap createNettyHttpClientBootstrap() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup())\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ChannelPipeline p = ch.pipeline();\n                         p.addLast(new HttpClientCodec());\n                         p.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                         p.addLast(\"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                                 throw new RuntimeException(\"Client response handler was not setup before the call\");\n                             }\n                         });\n                     }\n                 });\n\n        return bootstrap;\n    }\n\n    public static Channel connectNettyHttpClientToLocalServer(Bootstrap bootstrap, int port) throws InterruptedException {\n        return bootstrap.connect(\"localhost\", port).sync().channel();\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(Channel ch) {\n        return setupNettyHttpClientResponseHandler(ch, null);\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(\n        Channel ch, Consumer<ChannelPipeline> pipelineAdjuster\n    ) {\n        CompletableFuture<NettyHttpClientResponse> responseFromServerFuture = new CompletableFuture<>();\n        ch.pipeline().replace(\"clientResponseHandler\", \"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)\n                throws Exception {\n                if (msg instanceof FullHttpResponse) {\n                    \/\/ Store the proxyServer response for asserting on later.\n                    responseFromServerFuture.complete(new NettyHttpClientResponse((FullHttpResponse) msg));\n                } else {\n                    \/\/ Should never happen.\n                    throw new RuntimeException(\"Received unexpected message type: \" + msg.getClass());\n                }\n            }\n        });\n\n        if (pipelineAdjuster != null)\n            pipelineAdjuster.accept(ch.pipeline());\n        \n        return responseFromServerFuture;\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n        return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n\n        CompletableFuture<NettyHttpClientResponse> responseFuture = setupNettyHttpClientResponseHandler(ch, pipelineAdjuster);\n\n        \/\/ Send the request.\n        ch.writeAndFlush(request);\n\n        \/\/ Wait for the response to be received\n        return responseFuture.get(incompleteCallTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    public static class NettyHttpClientResponse {\n        public final int statusCode;\n        public final HttpHeaders headers;\n        public final String payload;\n        public final byte[] payloadBytes;\n        public final FullHttpResponse fullHttpResponse;\n\n        public NettyHttpClientResponse(FullHttpResponse fullHttpResponse) {\n            this.statusCode = fullHttpResponse.getStatus().code();\n            this.headers = fullHttpResponse.headers();\n            ByteBuf content = fullHttpResponse.content();\n            this.payloadBytes = new byte[content.readableBytes()];\n            content.getBytes(content.readerIndex(), this.payloadBytes);\n            this.payload = new String(this.payloadBytes, UTF_8);\n            this.fullHttpResponse = fullHttpResponse;\n        }\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        return executeRequest(request, port, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        Bootstrap bootstrap = createNettyHttpClientBootstrap();\n        try {\n            \/\/ Connect to the proxyServer.\n            Channel ch = connectNettyHttpClientToLocalServer(bootstrap, port);\n\n            try {\n                return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, pipelineAdjuster);\n            }\n            finally {\n                ch.close();\n            }\n        } finally {\n            bootstrap.group().shutdownGracefully();\n        }\n    }\n\n    public static NettyHttpClientRequestBuilder request() {\n        return new NettyHttpClientRequestBuilder();\n    }\n\n    public static class NettyHttpClientRequestBuilder {\n        private HttpMethod method;\n        private String uri;\n        private String payload;\n        private HttpHeaders headers = new DefaultHttpHeaders();\n        private Consumer<ChannelPipeline> pipelineAdjuster;\n\n        public NettyHttpClientRequestBuilder withMethod(HttpMethod method) {\n            this.method = method;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withUri(String uri) {\n            this.uri = uri;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withPaylod(String payload) {\n            this.payload = payload;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withKeepAlive() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withConnectionClose() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeader(String key, Object value) {\n            this.headers.set(key, value);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeaders(Iterable<Pair<String, Object>> headers) {\n            for (Pair<String, Object> header : headers) {\n                withHeader(header.getKey(), header.getValue());\n            }\n            return this;\n        }\n\n        @SafeVarargs\n        public final NettyHttpClientRequestBuilder withHeaders(Pair<String, Object>... headers) {\n            return withHeaders(Arrays.asList(headers));\n        }\n\n        public NettyHttpClientRequestBuilder withPipelineAdjuster(Consumer<ChannelPipeline> pipelineAdjuster) {\n            this.pipelineAdjuster = pipelineAdjuster;\n            return this;\n        }\n\n        public FullHttpRequest build() {\n            ByteBuf content;\n            if (payload != null)\n                content = Unpooled.copiedBuffer(payload, CharsetUtil.UTF_8);\n            else\n                content = Unpooled.buffer(0);\n\n            DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, method, uri, content);\n\n            if (headers != null) \n                request.headers().set(headers);\n\n            return request;\n        }\n\n        public NettyHttpClientResponse execute(int port, long incompleteCallTimeoutMillis) throws Exception {\n            return executeRequest(build(), port, incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n\n        public NettyHttpClientResponse execute(Channel ch, long incompleteCallTimeoutMillis) throws InterruptedException, ExecutionException, TimeoutException {\n            return executeNettyHttpClientCall(ch, build(), incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n    }\n\n    public static void verifyErrorReceived(String response, int responseStatusCode, ApiError expectedApiError) throws IOException {\n        assertThat(responseStatusCode).isEqualTo(expectedApiError.getHttpStatusCode());\n        DefaultErrorContractDTO responseAsError = objectMapper.readValue(response, DefaultErrorContractDTO.class);\n        assertThat(responseAsError.errors).hasSize(1);\n        assertThat(responseAsError.errors.get(0).code).isEqualTo(expectedApiError.getErrorCode());\n        assertThat(responseAsError.errors.get(0).message).isEqualTo(expectedApiError.getMessage());\n        assertThat(responseAsError.errors.get(0).metadata).isEqualTo(expectedApiError.getMetadata());\n    }\n\n    public static String extractBodyFromRawRequest(String request) {\n        return substringAfter(request.toString(), \"\\r\\n\\r\\n\"); \/\/body start after \\r\\n\\r\\n combo\n    }\n\n    public static String extractFullBodyFromChunks(String downstreamBody) {\n        return stream(substringsBetween(downstreamBody, \"\\r\\n\", \"\\r\\n\")) \/\/get all chunks\n                .filter(chunk -> containsOnly(chunk, payloadDictionary)) \/\/filter out chunk sizes\n                .collect(Collectors.joining());\n    }\n\n    public static Map<String, Object> extractHeaders(String requestHeaderString) {\n        String concatHeaders = substringBetween(requestHeaderString, \"HTTP\/1.1\\r\\n\", \"\\r\\n\\r\\n\");\n\n        Map<String, Object> extractedHeaders = new HashMap<>();\n\n        for (String concatHeader : split(concatHeaders, \"\\r\\n\")) {\n            extractedHeaders.put(substringBefore(concatHeader, HEADER_SEPARATOR).trim(), substringAfter(concatHeader, HEADER_SEPARATOR).trim());\n        }\n\n        return extractedHeaders;\n    }\n}\n","new_contents":"package com.nike.riposte.server.testutils;\n\nimport com.nike.backstopper.apierror.ApiError;\nimport com.nike.backstopper.model.DefaultErrorContractDTO;\nimport com.nike.internal.util.Pair;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport org.apache.commons.lang3.RandomUtils;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Deflater;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.Inflater;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.CharsetUtil;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static org.apache.commons.lang3.StringUtils.split;\nimport static org.apache.commons.lang3.StringUtils.substringAfter;\nimport static org.apache.commons.lang3.StringUtils.substringBefore;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Helper methods for working with component tests.\n *\n * @author Nic Munroe\n *\/\npublic class ComponentTestUtils {\n\n    private static final String HEADER_SEPARATOR = \":\";\n    private static final String payloadDictionary = \"aBcDefGhiJkLmN@#$%\";\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static int findFreePort() throws IOException {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            return serverSocket.getLocalPort();\n        }\n    }\n\n    public static String generatePayload(int payloadSize) {\n        return generatePayload(payloadSize, payloadDictionary);\n    }\n\n    public static String generatePayload(int payloadSize, String dictionary) {\n        StringBuilder payload = new StringBuilder();\n\n        for(int i = 0; i < payloadSize; i++) {\n            int randomInt = RandomUtils.nextInt(0, dictionary.length() - 1);\n            payload.append(dictionary.charAt(randomInt));\n        }\n\n        return payload.toString();\n    }\n\n    public static ByteBuf createByteBufPayload(int payloadSize) {\n        return Unpooled.wrappedBuffer(generatePayload(payloadSize).getBytes(UTF_8));\n    }\n\n    public static byte[] gzipPayload(String payload) {\n        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bytesOut)) {\n            byte[] payloadBytes = payload.getBytes(UTF_8);\n            gzipOutputStream.write(payloadBytes);\n            gzipOutputStream.finish();\n            return bytesOut.toByteArray();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String ungzipPayload(byte[] compressed) {\n        try {\n            if ((compressed == null) || (compressed.length == 0)) {\n                throw new RuntimeException(\"Null\/empty compressed payload. is_null=\" + (compressed == null));\n            }\n\n            final StringBuilder outStr = new StringBuilder();\n            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(compressed));\n            final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(gis, \"UTF-8\"));\n\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                outStr.append(line);\n            }\n\n            return outStr.toString();\n        }\n        catch(IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static byte[] deflatePayload(String payload) {\n        Deflater deflater = new Deflater(6, false);\n        byte[] payloadBytes = payload.getBytes(UTF_8);\n        deflater.setInput(payloadBytes);\n        deflater.finish();\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!deflater.finished()) {\n            int count = deflater.deflate(buffer);\n            outputStream.write(buffer, 0, count);\n        }\n\n        return outputStream.toByteArray();\n    }\n\n    public static String inflatePayload(byte[] compressed) {\n        Inflater inflater = new Inflater();\n        inflater.setInput(compressed);\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!inflater.finished()) {\n            try {\n                int count = inflater.inflate(buffer);\n                outputStream.write(buffer, 0, count);\n            }\n            catch (DataFormatException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return new String(outputStream.toByteArray(), UTF_8);\n    }\n\n    public static String base64Encode(byte[] bytes) {\n        return Base64.getEncoder().encodeToString(bytes);\n    }\n\n    public static byte[] base64Decode(String encodedStr) {\n        return Base64.getDecoder().decode(encodedStr);\n    }\n\n    public enum CompressionType {\n        GZIP(ComponentTestUtils::gzipPayload,\n             ComponentTestUtils::ungzipPayload,\n             HttpHeaders.Values.GZIP),\n        DEFLATE(ComponentTestUtils::deflatePayload,\n                ComponentTestUtils::inflatePayload,\n                HttpHeaders.Values.DEFLATE),\n        IDENTITY(s -> s.getBytes(UTF_8),\n                 b -> new String(b, UTF_8),\n                 HttpHeaders.Values.IDENTITY);\n\n        private final Function<String, byte[]> compressionFunction;\n        private final Function<byte[], String> decompressionFunction;\n        public final String contentEncodingHeaderValue;\n\n        CompressionType(Function<String, byte[]> compressionFunction,\n                        Function<byte[], String> decompressionFunction,\n                        String contentEncodingHeaderValue) {\n            this.compressionFunction = compressionFunction;\n            this.decompressionFunction = decompressionFunction;\n            this.contentEncodingHeaderValue = contentEncodingHeaderValue;\n        }\n\n        public byte[] compress(String s) {\n            return compressionFunction.apply(s);\n        }\n\n        public String decompress(byte[] compressed) {\n            return decompressionFunction.apply(compressed);\n        }\n    }\n\n    public static Bootstrap createNettyHttpClientBootstrap() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup())\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ChannelPipeline p = ch.pipeline();\n                         p.addLast(new HttpClientCodec());\n                         p.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                         p.addLast(\"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                                 throw new RuntimeException(\"Client response handler was not setup before the call\");\n                             }\n                         });\n                     }\n                 });\n\n        return bootstrap;\n    }\n\n    public static Channel connectNettyHttpClientToLocalServer(Bootstrap bootstrap, int port) throws InterruptedException {\n        return bootstrap.connect(\"localhost\", port).sync().channel();\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(Channel ch) {\n        return setupNettyHttpClientResponseHandler(ch, null);\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(\n        Channel ch, Consumer<ChannelPipeline> pipelineAdjuster\n    ) {\n        CompletableFuture<NettyHttpClientResponse> responseFromServerFuture = new CompletableFuture<>();\n        ch.pipeline().replace(\"clientResponseHandler\", \"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)\n                throws Exception {\n                if (msg instanceof FullHttpResponse) {\n                    \/\/ Store the proxyServer response for asserting on later.\n                    responseFromServerFuture.complete(new NettyHttpClientResponse((FullHttpResponse) msg));\n                } else {\n                    \/\/ Should never happen.\n                    throw new RuntimeException(\"Received unexpected message type: \" + msg.getClass());\n                }\n            }\n        });\n\n        if (pipelineAdjuster != null)\n            pipelineAdjuster.accept(ch.pipeline());\n        \n        return responseFromServerFuture;\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n        return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n\n        CompletableFuture<NettyHttpClientResponse> responseFuture = setupNettyHttpClientResponseHandler(ch, pipelineAdjuster);\n\n        \/\/ Send the request.\n        ch.writeAndFlush(request);\n\n        \/\/ Wait for the response to be received\n        return responseFuture.get(incompleteCallTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    public static class NettyHttpClientResponse {\n        public final int statusCode;\n        public final HttpHeaders headers;\n        public final String payload;\n        public final byte[] payloadBytes;\n        public final FullHttpResponse fullHttpResponse;\n\n        public NettyHttpClientResponse(FullHttpResponse fullHttpResponse) {\n            this.statusCode = fullHttpResponse.getStatus().code();\n            this.headers = fullHttpResponse.headers();\n            ByteBuf content = fullHttpResponse.content();\n            this.payloadBytes = new byte[content.readableBytes()];\n            content.getBytes(content.readerIndex(), this.payloadBytes);\n            this.payload = new String(this.payloadBytes, UTF_8);\n            this.fullHttpResponse = fullHttpResponse;\n        }\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        return executeRequest(request, port, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        Bootstrap bootstrap = createNettyHttpClientBootstrap();\n        try {\n            \/\/ Connect to the proxyServer.\n            Channel ch = connectNettyHttpClientToLocalServer(bootstrap, port);\n\n            try {\n                return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, pipelineAdjuster);\n            }\n            finally {\n                ch.close();\n            }\n        } finally {\n            bootstrap.group().shutdownGracefully();\n        }\n    }\n\n    public static NettyHttpClientRequestBuilder request() {\n        return new NettyHttpClientRequestBuilder();\n    }\n\n    public static class NettyHttpClientRequestBuilder {\n        private HttpMethod method;\n        private String uri;\n        private String payload;\n        private HttpHeaders headers = new DefaultHttpHeaders();\n        private Consumer<ChannelPipeline> pipelineAdjuster;\n\n        public NettyHttpClientRequestBuilder withMethod(HttpMethod method) {\n            this.method = method;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withUri(String uri) {\n            this.uri = uri;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withPaylod(String payload) {\n            this.payload = payload;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withKeepAlive() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withConnectionClose() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeader(String key, Object value) {\n            this.headers.set(key, value);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeaders(Iterable<Pair<String, Object>> headers) {\n            for (Pair<String, Object> header : headers) {\n                withHeader(header.getKey(), header.getValue());\n            }\n            return this;\n        }\n\n        @SafeVarargs\n        public final NettyHttpClientRequestBuilder withHeaders(Pair<String, Object>... headers) {\n            return withHeaders(Arrays.asList(headers));\n        }\n\n        public NettyHttpClientRequestBuilder withPipelineAdjuster(Consumer<ChannelPipeline> pipelineAdjuster) {\n            this.pipelineAdjuster = pipelineAdjuster;\n            return this;\n        }\n\n        public FullHttpRequest build() {\n            ByteBuf content;\n            if (payload != null)\n                content = Unpooled.copiedBuffer(payload, CharsetUtil.UTF_8);\n            else\n                content = Unpooled.buffer(0);\n\n            DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, method, uri, content);\n\n            if (headers != null) \n                request.headers().set(headers);\n\n            return request;\n        }\n\n        public NettyHttpClientResponse execute(int port, long incompleteCallTimeoutMillis) throws Exception {\n            return executeRequest(build(), port, incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n\n        public NettyHttpClientResponse execute(Channel ch, long incompleteCallTimeoutMillis) throws InterruptedException, ExecutionException, TimeoutException {\n            return executeNettyHttpClientCall(ch, build(), incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n    }\n\n    public static void verifyErrorReceived(String response, int responseStatusCode, ApiError expectedApiError) throws IOException {\n        assertThat(responseStatusCode).isEqualTo(expectedApiError.getHttpStatusCode());\n        DefaultErrorContractDTO responseAsError = objectMapper.readValue(response, DefaultErrorContractDTO.class);\n        assertThat(responseAsError.errors).hasSize(1);\n        assertThat(responseAsError.errors.get(0).code).isEqualTo(expectedApiError.getErrorCode());\n        assertThat(responseAsError.errors.get(0).message).isEqualTo(expectedApiError.getMessage());\n        assertThat(responseAsError.errors.get(0).metadata).isEqualTo(expectedApiError.getMetadata());\n    }\n\n    public static String extractBodyFromRawRequestOrResponse(String request) {\n        return substringAfter(request, \"\\r\\n\\r\\n\"); \/\/body start after \\r\\n\\r\\n combo\n    }\n\n    public static String extractFullBodyFromChunks(String chunkedBody) {\n        if (!chunkedBody.contains(\"\\r\\n\")) {\n            return chunkedBody;\n        }\n\n        \/\/ https:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec3.html#sec3.6.1\n        String[] chunksWithSizes = chunkedBody.split(\"\\r\\n\");\n        boolean nextChunkIsChunkSize = true;\n        StringBuilder finalResultMinusChunkMetadata = new StringBuilder();\n        for (String chunk : chunksWithSizes) {\n            if (!nextChunkIsChunkSize) {\n                \/\/ This is not metadata - it is actual body payload.\n                finalResultMinusChunkMetadata.append(chunk);\n            }\n\n            \/\/ Toggle our \"next is metadata\" flag, as according to the RFC it should alternate between\n            \/\/      chunk-size and chunk-data.\n            nextChunkIsChunkSize = !nextChunkIsChunkSize;\n        }\n\n        return finalResultMinusChunkMetadata.toString();\n    }\n\n    public static HttpHeaders extractHeaders(String rawRequestOrResponseString) {\n        int indexOfFirstCrlf = rawRequestOrResponseString.indexOf(\"\\r\\n\");\n        int indexOfBodySeparator = rawRequestOrResponseString.indexOf(\"\\r\\n\\r\\n\");\n\n        if (indexOfFirstCrlf == -1 || indexOfBodySeparator == -1) {\n            throw new IllegalArgumentException(\"The given rawRequestOrResponseString does not appear to be a valid HTTP message\");\n        }\n\n        String concatHeaders = rawRequestOrResponseString.substring(indexOfFirstCrlf + \"\\r\\n\".length(), indexOfBodySeparator);\n\n        HttpHeaders extractedHeaders = new DefaultHttpHeaders();\n\n        for (String concatHeader : split(concatHeaders, \"\\r\\n\")) {\n            extractedHeaders.add(substringBefore(concatHeader, HEADER_SEPARATOR).trim(), substringAfter(concatHeader, HEADER_SEPARATOR).trim());\n        }\n\n        return extractedHeaders;\n    }\n\n    public static Map<String, List<String>> headersToMap(HttpHeaders headers) {\n        Map<String, List<String>> result = new LinkedHashMap<>();\n        headers.names().forEach(headerKey -> result.put(headerKey, headers.getAll(headerKey)));\n        return result;\n    }\n}\n","subject":"","message":"Remove forced chunking on ProxyRouterEndpoint responses\n\nAlso fix bug of content-type being set on ProxyRouterEndpoint responses, and fix some RFC conformity issues for StandardEndpoints around always-empty-payload status codes and content-length header\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"b545aaadbbcee127af4d46b2a913a1d1b01f779b","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"2a5004d5256b878a63b4a47b28e44662ffa10e12","old_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/impl\/DelegatedErrorResponseBodyTest.java","new_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/impl\/DelegatedErrorResponseBodyTest.java","old_contents":"","new_contents":"package com.nike.riposte.server.error.handler.impl;\n\nimport org.junit.Test;\n\nimport java.util.UUID;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Tests the functionality of {@link DelegatedErrorResponseBody}.\n *\n * @author Nic Munroe\n *\/\npublic class DelegatedErrorResponseBodyTest {\n\n    @Test\n    public void constructor_sets_fields_as_expected() {\n        \/\/ given\n        String errorId = UUID.randomUUID().toString();\n        Object someObject = new Object();\n\n        \/\/ when\n        DelegatedErrorResponseBody impl = new DelegatedErrorResponseBody(errorId, someObject);\n\n        \/\/ then\n        assertThat(impl.errorId).isEqualTo(errorId);\n        assertThat(impl.errorId()).isEqualTo(errorId);\n        assertThat(impl.bodyToSerialize).isSameAs(someObject);\n        assertThat(impl.bodyToSerialize()).isSameAs(someObject);\n    }\n\n}\n","subject":"","message":"Add DelegatedErrorResponseBody\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"9e6ee00c5975ffe31cbae3d6bf49d550c0fa969d","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"9ce98981f705ea6274168e651b2faf95e2030baf","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"9ce98981f705ea6274168e651b2faf95e2030baf","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"394342a7f31538e5009c29c8b4f9ecd6b91403cb","old_file":"flowable\/src\/main\/java\/io\/reactivex\/flowable\/Flowable.java","new_file":"flowable\/src\/main\/java\/io\/reactivex\/flowable\/Flowable.java","old_contents":"\/**\n * Copyright (c) 2016-present, RxJava Contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n * the License for the specific language governing permissions and limitations under the License.\n *\/\npackage io.reactivex.flowable;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\nimport org.reactivestreams.*;\n\nimport hu.akarnokd.reactivestreams.extensions.*;\nimport io.reactivex.common.*;\nimport io.reactivex.common.annotations.*;\nimport io.reactivex.common.exceptions.Exceptions;\nimport io.reactivex.common.functions.*;\nimport io.reactivex.common.internal.functions.*;\nimport io.reactivex.common.internal.schedulers.ImmediateThinScheduler;\nimport io.reactivex.common.internal.utils.*;\nimport io.reactivex.flowable.internal.operators.*;\nimport io.reactivex.flowable.internal.subscribers.*;\nimport io.reactivex.flowable.subscribers.*;\n\n\/**\n * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,\n * intermediate operators and the ability to consume reactive dataflows.\n * <p>\n * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators\n * therefore accept general {@code Publisher}s directly and allow direct interoperation with other\n * Reactive-Streams implementations.\n * <p>\n * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},\n * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have\n * overloads that allow setting their internal buffer size explicitly.\n * <p>\n * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:\n * <p>\n * <img width=\"640\" height=\"317\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/legend.png\" alt=\"\">\n * <p>\n * For more information see the <a href=\"http:\/\/reactivex.io\/documentation\/Publisher.html\">ReactiveX\n * documentation<\/a>.\n *\n * @param <T>\n *            the type of the items emitted by the Flowable\n *\/\npublic abstract class Flowable<T> implements Publisher<T> {\n    \/** The default buffer size. *\/\n    static final int BUFFER_SIZE;\n    static {\n        BUFFER_SIZE = Math.max(16, Integer.getInteger(\"rx2.buffer-size\", 128));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an Iterable of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an Iterable of Publishers sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(null, sources));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an array of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an array of Publisher sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> ambArray(Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        int len = sources.length;\n        if (len == 0) {\n            return empty();\n        } else\n        if (len == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(sources, null));\n    }\n\n    \/**\n     * Returns the default internal buffer size used by most async operators.\n     * <p>The value can be overridden via system parameter {@code rx2.buffer-size}\n     * <em>before<\/em> the Flowable class is loaded.\n     * @return the default internal buffer size.\n     *\/\n    public static int bufferSize() {\n        return BUFFER_SIZE;\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Function<? super Object[], ? extends R> combiner, Publisher<? extends T>... sources) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publisher, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Publisher\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            int bufferSize, Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize);\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines two source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from either of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return combineLatest(f, source1, source2);\n    }\n\n    \/**\n     * Combines three source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);\n    }\n\n    \/**\n     * Combines four source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Combines five source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Combines six source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Combines seven source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Combines eight source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Combines nine source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <T9> the element type of the ninth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param source9\n     *            the ninth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Concatenates elements of each Publisher provided via an Iterable sequence into a single sequence\n     * of elements without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the common value type of the sources\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Flowable instance\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        \/\/ unlike general sources, fromIterable can only throw on a boundary because it is consumed only there\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), 2, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {\n        return concat(sources, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param prefetch\n     *            the number of Publishers to prefetch from the sources sequence.\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by two Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return concatArray(source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by three Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the three source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return concatArray(source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by four Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @param source4\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the four source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return concatArray(source1, source2, source3, source4);\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources.\n     * <p>\n     * Note: named this way because of overload conflict with concat(Publisher&lt;Publisher&gt).\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Publisher instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, false));\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources and delays errors from any of them\n     * till all terminate.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Flowable instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, true));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {\n        return concatArrayEager(bufferSize(), bufferSize(), sources);\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE\n     *                       is interpreted as indication to subscribe to all sources at once\n     * @param prefetch the number of elements to prefetch from each Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\n     * one after the other, one at a time and delays any errors till the all inner Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity());\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatDelayError(sources, bufferSize(), true);\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @param prefetch the number of elements to prefetch from the outer Publisher\n     * @param tillTheEnd if true exceptions from the outer and all inner Publishers are delayed to the end\n     *                   if false, exception from the outer Publisher is delayed till the current Publisher terminates\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {\n        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and the inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Provides an API (via a cold Flowable) that bridges the reactive world with the callback-style,\n     * generally non-backpressured world.\n     * <p>\n     * Example:\n     * <pre><code>\n     * Flowable.&lt;Event&gt;create(emitter -&gt; {\n     *     Callback listener = new Callback() {\n     *         &#64;Override\n     *         public void onEvent(Event e) {\n     *             emitter.onNext(e);\n     *             if (e.isLast()) {\n     *                 emitter.onComplete();\n     *             }\n     *         }\n     *\n     *         &#64;Override\n     *         public void onFailure(Exception e) {\n     *             emitter.onError(e);\n     *         }\n     *     };\n     *\n     *     AutoCloseable c = api.someMethod(listener);\n     *\n     *     emitter.setCancellable(c::close);\n     *\n     * }, BackpressureStrategy.BUFFER);\n     * <\/code><\/pre>\n     * <p>\n     * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The\n     * rest of its methods are thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior is determined by the {@code mode} parameter.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code create} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type\n     * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}\n     * @param mode the backpressure mode to apply if the downstream Subscriber doesn't request (fast) enough\n     * @return the new Flowable instance\n     * @see FlowableOnSubscribe\n     * @see BackpressureStrategy\n     * @see Cancellable\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        ObjectHelper.requireNonNull(mode, \"mode is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCreate<T>(source, mode));\n    }\n\n    \/**\n     * Returns a Flowable that calls a Publisher factory to create a Publisher for each new Subscriber\n     * that subscribes. That is, for each subscriber, the actual Publisher that subscriber observes is\n     * determined by the factory function.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defer.png\" alt=\"\">\n     * <p>\n     * The defer Subscriber allows you to defer or delay emitting items from a Publisher until such time as an\n     * Subscriber subscribes to the Publisher. This allows a {@link Subscriber} to easily obtain updates or a\n     * refreshed version of the sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}\n     *  returned by the {@code supplier}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            the Publisher factory function to invoke for each {@link Subscriber} that subscribes to the\n     *            resulting Publisher\n     * @param <T>\n     *            the type of the items emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given\n     *         Publisher factory function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defer.html\">ReactiveX operators documentation: Defer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> defer(Callable<? extends Publisher<? extends T>> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDefer<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits no items to the {@link Subscriber} and immediately invokes its\n     * {@link Subscriber#onComplete onComplete} method.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/empty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code empty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that emits no items to the {@link Subscriber} but immediately invokes the\n     *         {@link Subscriber}'s {@link Subscriber#onComplete() onComplete} method\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Empty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> empty() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            a Callable factory to return a Throwable for each individual Subscriber\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"errorSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableError<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param throwable\n     *            the particular Throwable to pass to {@link Subscriber#onError onError}\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(final Throwable throwable) {\n        ObjectHelper.requireNonNull(throwable, \"throwable is null\");\n        return error(Functions.justCallable(throwable));\n    }\n\n    \/**\n     * Converts an Array into a Publisher that emits the items in the Array.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code array}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of elements\n     * @param <T>\n     *            the type of items in the Array and the type of items to be emitted by the resulting Publisher\n     * @return a Flowable that emits each item in the source Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromArray(T... items) {\n        ObjectHelper.requireNonNull(items, \"items is null\");\n        if (items.length == 0) {\n            return empty();\n        }\n        if (items.length == 1) {\n            return just(items[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromArray<T>(items));\n    }\n\n    \/**\n     * Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then\n     * emits the value returned from that function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/fromCallable.png\" alt=\"\">\n     * <p>\n     * This allows you to defer the execution of the function you specify until a Subscriber subscribes to the\n     * Publisher. That is to say, it makes the function \"lazy.\"\n     * <dl>\n     *   <dt><b>Backpressure:<\/b><\/dt>\n     *   <dd>The operator honors backpressure from downstream.<\/dd>\n     *   <dt><b>Scheduler:<\/b><\/dt>\n     *   <dd>{@code fromCallable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this\n     *         function only when a Subscriber subscribes to the Publisher that {@code fromCallable} returns\n     * @param <T>\n     *         the type of the item emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given function\n     * @see #defer(Callable)\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromCallable(Callable<? extends T> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromCallable<T>(supplier));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, 0L, null));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, timeout, unit));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.s.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"cast\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts an {@link Iterable} sequence into a Publisher that emits the items in the sequence.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code iterable}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source\n     *            the source {@link Iterable} sequence\n     * @param <T>\n     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the\n     *            resulting Publisher\n     * @return a Flowable that emits each item in the source {@link Iterable} sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromIterable<T>(source));\n    }\n\n    \/**\n     * Converts an arbitrary Reactive-Streams Publisher into a Flowable if not already a\n     * Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and its behavior is determined by the\n     *  backpressure behavior of the wrapped publisher.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type of the flow\n     * @param source the Publisher to convert\n     * @return the new Flowable instance\n     * @throws NullPointerException if publisher is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> source) {\n        if (source instanceof Flowable) {\n            return RxJavaFlowablePlugins.onAssembly((Flowable<T>)source);\n        }\n        ObjectHelper.requireNonNull(source, \"publisher is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(source));\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateless and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the generated value type\n     * @param generator the Consumer called whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> generate(final Consumer<Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(Functions.nullSupplier(),\n                FlowableInternalHelper.<T, Object>simpleGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator,\n            Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), disposeState);\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {\n        return generate(initialState, generator, Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator, Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(initialState, \"initialState is null\");\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        ObjectHelper.requireNonNull(disposeState, \"disposeState is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGenerate<T, S>(initialState, generator, disposeState));\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.p.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) {\n        return interval(initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.ps.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @param scheduler\n     *            the Scheduler on which the waiting happens and items are emitted\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter, while running on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream\n     *  is not ready to receive the next value.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long period, TimeUnit unit) {\n        return interval(period, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time, on a\n     * specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @param scheduler\n     *            the Scheduler to use for scheduling the items\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {\n        return interval(period, period, unit, scheduler);\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {\n        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>you provide the {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @param scheduler the target scheduler where the values and terminal signals will be emitted\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0L) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0L) {\n            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a single item and then completes.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.png\" alt=\"\">\n     * <p>\n     * To convert any object into a Publisher that emits that object, pass that object into the {@code just}\n     * method.\n     * <p>\n     * This is similar to the {@link #fromArray(java.lang.Object[])} method, except that {@code from} will convert\n     * an {@link Iterable} object into a Publisher that emits each of the items in the Iterable, one at a\n     * time, while the {@code just} method converts an Iterable into a Publisher that emits the entire\n     * Iterable as a single item.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to emit\n     * @param <T>\n     *            the type of that item\n     * @return a Flowable that emits {@code value} as a single item and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJust<T>(item));\n    }\n\n    \/**\n     * Converts two items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n\n        return fromArray(item1, item2);\n    }\n\n    \/**\n     * Converts three items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n\n        return fromArray(item1, item2, item3);\n    }\n\n    \/**\n     * Converts four items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n\n        return fromArray(item1, item2, item3, item4);\n    }\n\n    \/**\n     * Converts five items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5);\n    }\n\n    \/**\n     * Converts six items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6);\n    }\n\n    \/**\n     * Converts seven items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7);\n    }\n\n    \/**\n     * Converts eight items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);\n    }\n\n    \/**\n     * Converts nine items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);\n    }\n\n    \/**\n     * Converts ten items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param item10\n     *            tenth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth item is null\");\n        ObjectHelper.requireNonNull(item10, \"The tenth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {\n        return merge(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 1.1.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens an Array of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.io.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers in the Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);\n    }\n\n    \/**\n     * Flattens four Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true);\n    }\n\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return mergeDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 2.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Flowable, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged Publishers\n     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from\n     * propagating that error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if both merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the two source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged\n     * Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain\n     * from propagating that error notification until all of the merged Publishers have finished emitting\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);\n    }\n\n\n    \/**\n     * Flattens four Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any of\n     * the merged Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}\n     * will refrain from propagating that error notification until all of the merged Publishers have finished\n     * emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);\n    }\n\n    \/**\n     * Returns a Flowable that never sends any items or notifications to a {@link Subscriber}.\n     * <p>\n     * <img width=\"640\" height=\"185\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/never.png\" alt=\"\">\n     * <p>\n     * This Publisher is useful primarily for testing purposes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code never} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of items (not) emitted by the Publisher\n     * @return a Flowable that never emits any items or sends any notifications to a {@link Subscriber}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Never<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> never() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Integers within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code range} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Integer in the sequence\n     * @param count\n     *            the number of sequential Integers to generate\n     * @return a Flowable that emits a range of sequential Integers\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Integer.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Integer> range(int start, int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return empty();\n        } else\n        if (count == 1) {\n            return just(start);\n        } else\n        if ((long)start + (count - 1) > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Integer overflow\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRange(start, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Longs within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Long in the sequence\n     * @param count\n     *            the number of sequential Longs to generate\n     * @return a Flowable that emits a range of sequential Longs\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Long.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Long> rangeLong(long start, long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0) {\n            return empty();\n        }\n\n        if (count == 1) {\n            return just(start);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRangeLong(start, count));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Flowable that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual) {\n        return sequenceEqual(source1, source2, isEqual, bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(isEqual, \"isEqual is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSequenceEqual<T>(source1, source2, isEqual, bufferSize));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param bufferSize\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return switchOnNextDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param prefetch\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single {@code 0L}\n     * @param unit\n     *            time units to use for {@code delay}\n     * @return a Flowable that emits {@code 0L} after a specified delay, and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> timer(long delay, TimeUnit unit) {\n        return timer(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     * completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single 0L\n     * @param unit\n     *            time units to use for {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for scheduling the item\n     * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     *         completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));\n    }\n\n    \/**\n     * Create a Flowable by wrapping a Publisher <em>which has to be implemented according\n     * to the Reactive-Streams specification by handling backpressure and\n     * cancellation correctly; no safeguards are provided by the Flowable itself<\/em>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure and the behavior is determined by the\n     *  provided Publisher implementation.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type emitted\n     * @param onSubscribe the Publisher instance to wrap\n     * @return the new Flowable instance\n     * @throws IllegalArgumentException if {@code onSubscribe} is a subclass of {@code Flowable}; such\n     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}\n     * instead.\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        if (onSubscribe instanceof Flowable) {\n            throw new IllegalArgumentException(\"unsafeCreate(Flowable) should be upgraded\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of on cancellation.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {\n        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of just before\n     * termination if you have set {@code disposeEagerly} to {@code true} and cancellation does not occur\n     * before termination. Otherwise resource disposal will occur on cancellation.  Eager disposal is\n     * particularly appropriate for a synchronous Publisher that reuses resources. {@code disposeAction} will\n     * only be called once per subscription.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @param eager\n     *            if {@code true} then disposal will happen either on cancellation or just before emission of\n     *            a terminal event ({@code onComplete} or {@code onError}).\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier,\n                    Consumer<? super D> resourceDisposer, boolean eager) {\n        ObjectHelper.requireNonNull(resourceSupplier, \"resourceSupplier is null\");\n        ObjectHelper.requireNonNull(sourceSupplier, \"sourceSupplier is null\");\n        ObjectHelper.requireNonNull(resourceDisposer, \"disposer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common value type\n     * @param <R> the zipped result type\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * <i>n<\/i> items emitted, in sequence, by the <i>n<\/i> Publishers emitted by a specified Publisher.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the Publishers emitted\n     * by the source Publisher; the second item emitted by the new Publisher will be the result of the\n     * function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancel the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(just(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the value type of the inner Publishers\n     * @param <R> the zipped result type\n     * @param sources\n     *            a Publisher of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the Publishers emitted by\n     *            {@code ws}, results in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,\n            final Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return fromPublisher(sources).toList().flatMap((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);\n    }\n\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @param bufferSize the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * three items emitted, in sequence, by three other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new\n     * Publisher will be the result of the function applied to the second item emitted by {@code o1}, the\n     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * four items emitted, in sequence, by four other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * five items emitted, in sequence, by five other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and\n     * the first item emitted by {@code o5}; the second item emitted by the new Publisher will be the result of\n     * the function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * six items emitted, in sequence, by six other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * seven items emitted, in sequence, by seven other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * eight items emitted, in sequence, by eight other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * nine items emitted, in sequence, by nine other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <T9> the value type of the ninth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param source9\n     *            a ninth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {\n\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an array of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;\n     * a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param <R> the result type\n     * @param sources\n     *            an array of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper,\n            boolean delayError, int bufferSize, Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     *\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @param <T> the common source value type\n     * @param <R> the zipped result type\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipIterable(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> zipper, boolean delayError,\n            int bufferSize) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError));\n    }\n\n    \/\/ ***************************************************************************************************\n    \/\/ Instance operators\n    \/\/ ***************************************************************************************************\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source\n     * Publisher satisfy a condition.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/all.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code all} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item and returns a Boolean\n     * @return a Single that emits {@code true} if all items emitted by the source Publisher satisfy the\n     *         predicate; otherwise, {@code false}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/all.html\">ReactiveX operators documentation: All<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> all(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAll<T>(this, predicate));\n    }\n\n    \/**\n     * Mirrors the Publisher (current or provided) that first either emits an item or sends a termination\n     * notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher competing to react first. A subscription to this provided Publisher will occur after subscribing\n     *            to the current Publisher.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ambWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return ambArray(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a\n     * specified condition, otherwise {@code false}. <em>Note:<\/em> this always emits {@code false} if the\n     * source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/exists.png\" alt=\"\">\n     * <p>\n     * In Rx.Net this is the {@code any} Subscriber but we renamed it in RxJava to better match Java naming\n     * idioms.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code any} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the condition to test items emitted by the source Publisher\n     * @return a Single that emits a Boolean that indicates whether any item emitted by the source\n     *         Publisher satisfies the {@code predicate}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> any(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAny<T>(this, predicate));\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if it emits no items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the first item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst() {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the first item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst(T defaultItem) {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Invokes a method on each item emitted by this {@code Flowable} and blocks until the Flowable\n     * completes.\n     * <p>\n     * <em>Note:<\/em> This will block even if the underlying Flowable is asynchronous.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.forEach.png\" alt=\"\">\n     * <p>\n     * This is similar to {@link Flowable#subscribe(Subscriber)}, but it blocks. Because it blocks it does not\n     * need the {@link Subscriber#onComplete()} or {@link Subscriber#onError(Throwable)} methods. If the\n     * underlying Flowable terminates with an error, rather than calling {@code onError}, this method will\n     * throw an exception.\n     *\n     * <p>The difference between this method and {@link #subscribe(Consumer)} is that the {@code onNext} action\n     * is executed on the emission thread instead of the current thread.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the {@link Consumer} to invoke for each item emitted by the {@code Flowable}\n     * @throws RuntimeException\n     *             if an error occurs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX documentation: Subscribe<\/a>\n     * @see #subscribe(Consumer)\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingForEach(Consumer<? super T> onNext) {\n        Iterator<T> it = blockingIterable().iterator();\n        while (it.hasNext()) {\n            try {\n                onNext.accept(it.next());\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                ((Disposable)it).dispose();\n                throw ExceptionHelper.wrapOrThrow(e);\n            }\n        }\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable() {\n        return blockingIterable(bufferSize());\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize the number of items to prefetch from the current Flowable\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return new BlockingFlowableIterable<T>(this, bufferSize);\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if this {@code Flowable} emits no items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the last item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast() {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the last item emitted by the {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast(T defaultItem) {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},\n     * waiting if necessary for one to become available.\n     * <p>\n     * If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,\n     * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.\n     * <p>\n     * Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}\n     * event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an Iterable that always returns the latest item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingLatest() {\n        return new BlockingFlowableLatest<T>(this);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that always returns the item most recently emitted by this\n     * {@code Flowable}.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.mostRecent.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialItem\n     *            the initial item that the {@link Iterable} sequence will yield if this\n     *            {@code Flowable} has not yet emitted an item\n     * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}\n     *         has most recently emitted\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingMostRecent(T initialItem) {\n        return new BlockingFlowableMostRecent<T>(this, initialItem);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, then\n     * returns that item.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.next.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} that blocks upon each iteration until this {@code Flowable} emits\n     *         a new item, whereupon the Iterable returns that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingNext() {\n        return new BlockingFlowableNext<T>(this);\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item, otherwise\n     * throw a {@code NoSuchElementException}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the single item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle() {\n        return singleOrError().blockingLast();\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item; if it emits\n     * more than one item, throw an {@code IllegalArgumentException}; if it emits no items, return a default\n     * value.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the single item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle(T defaultItem) {\n        return single(defaultItem).blockingLast();\n    }\n\n    \/**\n     * Returns a {@link Future} representing the single value emitted by this {@code Flowable}.\n     * <p>\n     * If the {@link Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an\n     * {@link java.lang.IllegalArgumentException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}\n     * will receive an {@link java.util.NoSuchElementException}.\n     * <p>\n     * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toBlocking().toFuture()}.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toFuture.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Future} that expects a single item to be emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Future<T> toFuture() {\n        return subscribeWith(new FutureSubscriber<T>());\n    }\n\n    \/**\n     * Runs the source observable to a terminal event, ignoring any values and rethrowing any exception.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe() {\n        FlowableBlockingSubscribe.subscribe(this);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @param onComplete the callback action for the completion event.\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);\n    }\n\n    \/**\n     * Subscribes to the source and calls the Subscriber methods <strong>on the current thread<\/strong>.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The supplied {@code Subscriber} determines how backpressure is applied.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * The cancellation and backpressure is composed through.\n     * @param subscriber the subscriber to forward events and calls to in the current thread\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Subscriber<? super T> subscriber) {\n        FlowableBlockingSubscribe.subscribe(this, subscriber);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count) {\n        return buffer(count, count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count, int skip) {\n        return buffer(count, skip, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {\n        return buffer(count, count, bufferSupplier);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits\n     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {\n        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,\n            Scheduler scheduler, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {\n        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) {\n        return buffer(timespan, unit, Schedulers.computation(), count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {\n        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @param restartTimerOnMaxSize if true the time window is restarted when the max capacity of the current buffer\n     *            is reached\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(\n            long timespan, TimeUnit unit,\n            Scheduler scheduler, int count,\n            Callable<U> bufferSupplier,\n            boolean restartTimerOnMaxSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument and on the specified {@code scheduler}. When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing> Flowable<List<T>> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {\n        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {\n        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param initialCapacity\n     *            the initial capacity of each buffer chunk\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     * @see #buffer(Publisher)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.<T>asCallable());\n\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundaryIndicatorSupplier, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cache() {\n        return cacheWithInitialCapacity(16);\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * <p>\n     * <em>Note:<\/em> The capacity hint is not an upper bound on cache size. For that, consider\n     * {@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.\n     *\n     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher, converted to the specified\n     * type.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output value type cast to\n     * @param clazz\n     *            the target class type that {@code cast} will cast the items emitted by the source Publisher\n     *            into before emitting them from the resulting Publisher\n     * @return a Flowable that emits each item from the source Publisher after converting it to the\n     *         specified type\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> cast(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return map(Functions.castFunction(clazz));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collect} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItemSupplier\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItemSupplier, \"initialItemSupplier is null\");\n        ObjectHelper.requireNonNull(collector, \"collector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCollect<T, U>(this, initialItemSupplier, collector));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collectInto} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItem\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collectInto(final U initialItem, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItem, \"initialItem is null\");\n        return collect(Functions.justCallable(initialItem), collector);\n    }\n\n    \/**\n     * Transform a Publisher by applying a particular Transformer function to it.\n     * <p>\n     * This method operates on the Publisher itself whereas {@link #lift} operates on the Publisher's\n     * Subscribers or Subscribers.\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@link #lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with the backpressure behavior which only depends\n     *  on what kind of {@code Publisher} the transformer returns.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code compose} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the output Publisher\n     * @param composer implements the function that transforms the source Publisher\n     * @return the source Publisher, transformed by the transformer function\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {\n        return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, \"composer is null\")).apply(this));\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMap(mapper, 2);\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapEager(mapper, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean tillTheEnd) {\n        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch\n     *               the number of elements to prefetch from each source Publisher\n     * @param tillTheEnd\n     *               if true, exceptions from the current Flowable and all the inner Publishers are delayed until\n     *               all of them terminate, if false, exception from the current Flowable is delayed until the\n     *               currently running Publisher terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, prefetch));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted from the current Publisher, then the next, one after\n     * the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be concatenated after the current\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> concatWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concat(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether the source Publisher emitted a\n     * specified item.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/contains.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code contains} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to search for in the emissions from the source Publisher\n     * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,\n     *         or {@code false} if the source Publisher completes without emitting that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> contains(final Object item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return any(Functions.equalsWith(item));\n    }\n\n    \/**\n     * Returns a Single that counts the total number of items emitted by the source Publisher and emits\n     * this count as a 64-bit Long.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/longCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code count} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a\n     *         64-bit Long item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/count.html\">ReactiveX operators documentation: Count<\/a>\n     * @see #count()\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Long> count() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCount<T>(this));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by another item within a computed debounce duration.\n     * <p>\n     * <img width=\"640\" height=\"425\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the {@code debounceSelector} to mark\n     *      boundaries.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the debounce value type (ignored)\n     * @param debounceIndicator\n     *            function to retrieve a sequence that indicates the throttle duration for each item\n     * @return a Flowable that omits items emitted by the source Publisher that are followed by another item\n     *         within a computed debounce duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {\n        ObjectHelper.requireNonNull(debounceIndicator, \"debounceIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on\n     * each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the {@link TimeUnit} for the timeout\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires on a specified\n     * Scheduler. The timer resets on each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the unit of time for the specified timeout\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or a specified default item\n     * if the source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defaultIfEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, this operator is guaranteed to honor backpressure from downstream.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as well; if the rule is violated,\n     *  a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the item to emit if the source Publisher emits no items\n     * @return a Flowable that emits either the specified default item if the source Publisher emits no\n     *         items, or the items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defaultifempty.html\">ReactiveX operators documentation: DefaultIfEmpty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> defaultIfEmpty(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"item is null\");\n        return switchIfEmpty(just(defaultItem));\n    }\n\n    \/**\n     * Returns a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     * per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.o.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the function are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the item delay value type (ignored)\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     *         per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelayIndicator) {\n        ObjectHelper.requireNonNull(itemDelayIndicator, \"itemDelayIndicator is null\");\n        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit) {\n        return delay(delay, unit, Schedulers.computation(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {\n        return delay(delay, unit, Schedulers.computation(), delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delay(delay, unit, scheduler, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelay<T>(this, Math.max(0L, delay), unit, scheduler, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to and emissions from the source Publisher via another\n     * Publisher on a per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.oo.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the functions are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the subscription delay value type (ignored)\n     * @param <V>\n     *            the item delay value type (ignored)\n     * @param subscriptionIndicator\n     *            a function that returns a Publisher that triggers the subscription to the source Publisher\n     *            once it emits any item\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the subscription and emissions of the source Publisher via another\n     *         Publisher on a per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,\n            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {\n        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to this Publisher\n     * until the other Publisher emits an element or completes normally.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator forwards the backpressure requests to this Publisher once\n     *  the subscription happens and requests Long.MAX_VALUE from the other Publisher<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the value type of the other Publisher, irrelevant\n     * @param subscriptionIndicator the other Publisher that should trigger the subscription\n     *        to this Publisher.\n     * @return a Flowable that delays the subscription to this Publisher\n     *         until the other Publisher emits an element or completes normally.\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delaySubscription(Publisher<U> subscriptionIndicator) {\n        ObjectHelper.requireNonNull(subscriptionIndicator, \"subscriptionIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, subscriptionIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @return a Flowable that delays the subscription to the source Publisher by the given amount\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit) {\n        return delaySubscription(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time,\n     * both waiting and subscribing on a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the Scheduler on which the waiting and subscription will happen\n     * @return a Flowable that delays the subscription to the source Publisher by a given\n     *         amount, waiting and subscribing on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delaySubscription(timer(delay, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the\n     * {@link Notification} objects emitted by the source Publisher into the items or notifications they\n     * represent.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/dematerialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code dematerialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T2> the output value type\n     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Dematerialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T2> Flowable<T2> dematerialize() {\n        @SuppressWarnings(\"unchecked\")\n        Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDematerialize<T2>(m));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits only those items emitted by the source Publisher that are distinct from\n     *         each other\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinct() {\n        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {\n        return distinct(keySelector, Functions.<K>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @param collectionSupplier\n     *            function called for each individual Subscriber to return a Collection subtype for holding the extracted\n     *            keys and whose add() method's return indicates uniqueness.\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,\n            Callable<? extends Collection<? super K>> collectionSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged() {\n        return distinctUntilChanged(Functions.identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors, according to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items from the source Publisher whose keys are distinct from\n     *         those of their immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors when compared with each other via the provided comparator function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparer the function that receives the previous item and the current item and is\n     *                   expected to return true if the two are equal, thus skipping the current value.\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {\n        ObjectHelper.requireNonNull(comparer, \"comparer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));\n    }\n\n    \/**\n     * Calls the specified action after this Flowable signals onError or onCompleted or gets cancelled by\n     * the downstream.\n     * <p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action\n     * is executed once per subscription.\n     * <p>Note that the {@code onFinally} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onFinally the action called when this Flowable terminates or gets cancelled\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doFinally(Action onFinally) {\n        ObjectHelper.requireNonNull(onFinally, \"onFinally is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));\n    }\n\n    \/**\n     * Calls the specified consumer with the current item after this item has been emitted to the downstream.\n     * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onAfterNext the Consumer that will be called after emitting an item from upstream to the downstream\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {\n        ObjectHelper.requireNonNull(onAfterNext, \"onAfterNext is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));\n    }\n\n    \/**\n     * Registers an {@link Action} to be called when this Publisher invokes either\n     * {@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/finallyDo.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onAfterTerminate\n     *            an {@link Action} to be invoked when the source Publisher finishes\n     * @return a Flowable that emits the same items as the source Publisher, then invokes the\n     *         {@link Action}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doOnTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, onAfterTerminate);\n    }\n\n    \/**\n     * Calls the cancel {@code Action} if the downstream cancels the sequence.\n     * <p>\n     * The action is shared between subscriptions and thus may be called concurrently from multiple\n     * threads; the action must be thread safe.\n     * <p>\n     * If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,\n     * sometimes as a {@code CompositeException} if there were multiple exceptions along the way.\n     * <p>\n     * Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnUnsubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure\n     *  behavior is preserved between its upstream and its downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onCancel\n     *            the action that gets called when the source {@code Publisher}'s Subscription is cancelled\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnCancel(Action onCancel) {\n        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnComplete.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onComplete\n     *            the action to invoke when the source Publisher calls {@code onComplete}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnComplete(Action onComplete) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                onComplete, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same type\n     * passes through, before forwarding them to downstream.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Action onAfterTerminate) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action for each item it emits.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNotification\n     *            the action to invoke for each item emitted by the source Publisher\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {\n        ObjectHelper.requireNonNull(onNotification, \"consumer is null\");\n        return doOnEach(\n                Functions.notificationOnNext(onNotification),\n                Functions.notificationOnError(onNotification),\n                Functions.notificationOnComplete(onNotification),\n                Functions.EMPTY_ACTION\n            );\n    }\n\n    \/**\n     * Modifies the source Publisher so that it notifies a Subscriber for each item and terminal event it emits.\n     * <p>\n     * In case the {@code onError} of the supplied Subscriber throws, the downstream will receive a composite\n     * exception containing the original exception and the exception thrown by {@code onError}. If either the\n     * {@code onNext} or the {@code onComplete} method of the supplied Subscriber throws, the downstream will be\n     * terminated and will receive this thrown exception.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param subscriber\n     *            the Subscriber to be notified about onNext, onError and onComplete events on its\n     *            respective methods before the actual downstream Subscriber gets notified.\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {\n        ObjectHelper.requireNonNull(subscriber, \"subscriber is null\");\n        return doOnEach(\n                FlowableInternalHelper.subscriberOnNext(subscriber),\n                FlowableInternalHelper.subscriberOnError(subscriber),\n                FlowableInternalHelper.subscriberOnComplete(subscriber),\n                Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action if it calls {@code onError}.\n     * <p>\n     * In case the {@code onError} action throws, the downstream will receive a composite exception containing\n     * the original exception and the exception thrown by {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onError\n     *            the action to invoke if the source Publisher calls {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {\n        return doOnEach(Functions.emptyConsumer(), onError,\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of\n     * the sequence (subscription, cancellation, requesting).\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *              a Consumer called with the Subscription sent via Subscriber.onSubscribe()\n     * @param onRequest\n     *              a LongConsumer called with the request amount sent via Subscription.request()\n     * @param onCancel\n     *              called when the downstream cancels the Subscription via cancel()\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,\n            final LongConsumer onRequest, final Action onCancel) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");\n        ObjectHelper.requireNonNull(onCancel, \"onCancel is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onNext}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the action to invoke when the source Publisher calls {@code onNext}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {\n        return doOnEach(onNext, Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it receives a\n     * request for more items.\n     * <p>\n     * <b>Note:<\/b> This operator is for tracing the internal behavior of back-pressure request\n     * patterns and generally intended for debugging use.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     * <dt><b>Scheduler:<\/b><\/dt>\n     * <dd>{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onRequest\n     *            the action that gets called when a Subscriber requests items from this\n     *            {@code Publisher}\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators\n     *      documentation: Do<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnRequest(LongConsumer onRequest) {\n        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from\n     * its subscribers. Each subscription will result in an invocation of the given action except when the\n     * source {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke\n     * the given action for the first subscription.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnSubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *            the Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}\n     * @return the source {@code Publisher} modified so as to call this Consumer when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {\n        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete} or\n     * {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnTerminate.png\" alt=\"\">\n     * <p>\n     * This differs from {@code doAfterTerminate} in that this happens <em>before<\/em> the {@code onComplete} or\n     * {@code onError} notification.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onTerminate\n     *            the action to invoke when the source Publisher calls {@code onComplete} or {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doAfterTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnTerminate(final Action onTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),\n                onTerminate, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from\n     * this Flowable or completes if this Flowable sequence has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Maybe that emits a single item: the item at the specified position in the sequence of\n     *         those emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable, or a default item if that index is out of range.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @param defaultItem\n     *            the default item\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index, T defaultItem) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable or signals a {@link NoSuchElementException} if this Flowable has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAtOrError(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, true));\n    }\n\n    \/**\n     * Filters items emitted by a Publisher by only emitting those that satisfy a specified predicate.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/filter.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code filter} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates each item emitted by the source Publisher, returning {@code true}\n     *            if it passes the filter\n     * @return a Flowable that emits only those items emitted by the source Publisher that the filter\n     *         evaluates as {@code true}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFilter<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Maybe that emits only the very first item emitted by this Flowable or\n     * completes if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstElement.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstElement() {\n        return elementAt(0);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable, or a default\n     * item if this Flowable completes without emitting anything.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/first.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code first} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher doesn't emit anything\n     * @return a Single that emits only the very first item from the source, or a default item if the\n     *         source Publisher completes without emitting any items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> first(T defaultItem) {\n        return elementAt(0, defaultItem);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable or\n     * signals a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstOrError() {\n        return elementAtOrError(0);\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return flatMap(mapper, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {\n        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {\n        return flatMap(mapper, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from each inner Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items,\n     * while limiting the maximum number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier,\n            int maxConcurrency) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(\n                this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        return flatMap(mapper, combiner, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     * <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner functions\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors) {\n        return flatMap(mapper, combiner, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, combiner, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from the inner Publishers.\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {\n        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return flatMapIterable(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of applying a function to the pair of values from the source\n     * Publisher and an Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and the source {@code Publisher}s is\n     *  consumed in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the collection element type\n     * @param <V>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for each item emitted by the source\n     *            Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @return a Flowable that emits the items returned by {@code resultSelector} for each item in the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the element type of the inner Iterable sequences\n     * @param <V>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element.\n     * <p>\n     * Alias to {@link #subscribe(Consumer)}\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Consumer} to execute for each item.\n     * @return\n     *            a Disposable that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEach(Consumer<? super T> onNext) {\n        return subscribe(onNext);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element until the\n     * onNext Predicate returns false.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext) {\n        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and error events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {\n        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and the terminal events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @param onComplete\n     *            {@link Action} to execute when completion is signalled.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,\n            final Action onComplete) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n\n        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);\n        subscribe(s);\n        return s;\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {\n        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {\n        return groupBy(keySelector, Functions.<T>identity(), delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector) {\n        return groupBy(keySelector, valueSelector, false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector, boolean delayError) {\n        return groupBy(keySelector, valueSelector, delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @param bufferSize\n     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that correlates two Publishers when they overlap in time and groups the results.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupJoin.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupJoin} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the other Publisher to correlate items from the source Publisher with\n     * @param leftEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the source Publisher\n     * @param rightEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the {@code right} Publisher\n     * @param resultSelector\n     *            a function that takes an item emitted by each Publisher and returns the value to be emitted\n     *            by the resulting Publisher\n     * @return a Flowable that emits items based on combining those items emitted by the source Publishers\n     *         whose durations overlap\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n    \/**\n     * Hides the identity of this Flowable and its Subscription.\n     * <p>Allows hiding extra features such as {@link Processor}'s\n     * {@link Subscriber} methods or preventing certain identity-based\n     * optimizations (fusion).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure, the behavior is determined by the upstream's\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     *\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> hide() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableHide<T>(this));\n    }\n\n    \/**\n     * Ignores all items emitted by the source Publisher and only calls {@code onComplete} or {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ignoreElements.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator ignores backpressure as it doesn't emit any elements and consumes the source {@code Publisher}\n     *  in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is\n     *         called by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/ignoreelements.html\">ReactiveX operators documentation: IgnoreElements<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ignoreElements() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if the source Publisher is empty, otherwise {@code false}.\n     * <p>\n     * In Rx.Net this is negated as the {@code any} Subscriber but we renamed this in RxJava to better match Java\n     * naming idioms.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/isEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code isEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits a Boolean\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> isEmpty() {\n        return all(Functions.alwaysFalse());\n    }\n\n    \/**\n     * Correlates the items emitted by two Publishers based on overlapping durations.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/join_.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code join} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the second Publisher to join items from\n     * @param leftEnd\n     *            a function to select a duration for each item emitted by the source Publisher, used to\n     *            determine overlap\n     * @param rightEnd\n     *            a function to select a duration for each item emitted by the {@code right} Publisher, used to\n     *            determine overlap\n     * @param resultSelector\n     *            a function that computes an item to be emitted by the resulting Publisher for any two\n     *            overlapping items emitted by the two Publishers\n     * @return a Flowable that emits items correlating to items emitted by the source Publishers that have\n     *         overlapping durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n\n    \/**\n     * Returns a Maybe that emits the last item emitted by this Flowable or completes if\n     * this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable, or a default item\n     * if this Flowable completes without emitting any items.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code last} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher is empty\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> last(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable or signals\n     * a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"236\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, true));\n    }\n\n    \/**\n     * <strong>This method requires advanced knowledge about building operators; please consider\n     * other standard composition methods first;<\/strong>\n     * Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass\n     * the values of the current Publisher through the Operator function.\n     * <p>\n     * In other words, this allows chaining Subscribers together on a Publisher for acting on the values within\n     * the Publisher.\n     * <p> {@code\n     * Publisher.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()\n     * }\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@code lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The {@code Operator} instance provided is responsible to be backpressure-aware or\n     *  document the fact that the consumer of the returned {@code Publisher} has to apply one of\n     *  the {@code onBackpressureXXX} operators.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output value type\n     * @param lifter the Operator that implements the Publisher-operating function to be applied to the source\n     *             Publisher\n     * @return a Flowable that is the result of applying the lifted Operator to the source Publisher\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {\n        ObjectHelper.requireNonNull(lifter, \"lifter is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLift<R, T>(this, lifter));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified function to each item emitted by the source Publisher and\n     * emits the results of these function applications.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/map.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output type\n     * @param mapper\n     *            a function to apply to each item emitted by the Publisher\n     * @return a Flowable that emits the items from the source Publisher, transformed by the specified\n     *         function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMap<T, R>(this, mapper));\n    }\n\n    \/**\n     * Returns a Flowable that represents all of the emissions <em>and<\/em> notifications from the source\n     * Publisher into emissions marked with their original types within {@link Notification} objects.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/materialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects it from the source {@code Publisher}.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits items that are the result of materializing the items and notifications\n     *         of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Materialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Notification<T>> materialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMaterialize<T>(this));\n    }\n\n    \/**\n     * Flattens this and another Publisher into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code mergeWith} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> mergeWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return merge(this, other);\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of {@link #bufferSize()} slots.\n     *\n     * <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly\n     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler, boolean)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) {\n        return observeOn(scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @param bufferSize the size of the buffer.\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n\n    \/**\n     * Filters the items emitted by a Publisher, only emitting those of the specified type.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ofClass.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output type\n     * @param clazz\n     *            the class type to filter the items emitted by the source Publisher\n     * @return a Flowable that emits items from the source Publisher of type {@code clazz}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> ofType(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return filter(Functions.isInstanceOf(clazz)).cast(clazz);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer() {\n        return onBackpressureBuffer(bufferSize(), false, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(boolean delayError) {\n        return onBackpressureBuffer(bufferSize(), delayError, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity) {\n        return onBackpressureBuffer(capacity, false, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) {\n        return onBackpressureBuffer(capacity, delayError, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) {\n        ObjectHelper.verifyPositive(capacity, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, Functions.EMPTY_ACTION));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,\n            Action onOverflow) {\n        ObjectHelper.requireNonNull(onOverflow, \"onOverflow is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, onOverflow));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) {\n        return onBackpressureBuffer(capacity, false, false, onOverflow);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will behave as determined\n     * by {@code overflowStrategy} if the buffer capacity is exceeded.\n     *\n     * <ul>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR} (default) will {@code onError} dropping all undelivered items,\n     *     cancelling the source, and notifying the producer with {@code onOverflow}. <\/li>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST} will drop any new items emitted by the producer while\n     *     the buffer is full, without generating any {@code onError}.  Each drop will however invoke {@code onOverflow}\n     *     to signal the overflow to the producer.<\/li>j\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST} will drop the oldest items in the buffer in order to make\n     *     room for newly emitted ones. Overflow will not generate an{@code onError}, but each drop will invoke\n     *     {@code onOverflow} to signal the overflow to the producer.<\/li>\n     * <\/ul>\n     *\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @param overflowStrategy how should the {@code Publisher} react to buffer overflows.  Null is not allowed.\n     * @return the source {@code Flowable} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {\n        ObjectHelper.requireNonNull(overflowStrategy, \"strategy is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBufferStrategy<T>(this, capacity, onOverflow, overflowStrategy));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {\n        ObjectHelper.requireNonNull(onDrop, \"onDrop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to\n     * hold onto the latest value and emit that on request.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.latest.png\" alt=\"\">\n     * <p>\n     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that\n     * the downstream is not blocking while requesting more values.\n     * <p>\n     * Note that if the upstream Publisher does support backpressure, this operator ignores that capability\n     * and doesn't propagate any backpressure requests from downstream.\n     * <p>\n     * Note that due to the nature of how backpressure requests are propagated through subscribeOn\/observeOn,\n     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified so that it emits the most recently-received item upon request\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureLatest() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureLatest<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass a function that returns a Publisher ({@code resumeFunction}) to\n     * {@code onErrorResumeNext}, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to the Publisher returned from\n     * {@code resumeFunction}, which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an error happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  a {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param resumeFunction\n     *            a function that returns a Publisher that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {\n        ObjectHelper.requireNonNull(resumeFunction, \"resumeFunction is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onErrorResumeNext} method, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which\n     * will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,\n     * because no Publisher necessarily invokes {@code onError}, the Subscriber may never know that an error\n     * happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher source that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return onErrorResumeNext(Functions.justFunction(next));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param valueSupplier\n     *            a function that returns a single value that will be emitted along with a regular onComplete in case\n     *            the current Flowable signals an onError event\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {\n        ObjectHelper.requireNonNull(valueSupplier, \"valueSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorReturn<T>(this, valueSupplier));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the value that is emitted along with a regular onComplete in case the current\n     *            Flowable signals an exception\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturnItem(final T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return onErrorReturn(Functions.justFunction(item));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an {@link java.lang.Exception}.\n     * <p>\n     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}\n     * or {@link java.lang.Error} but lets those continue through.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onExceptionResumeNextViaPublisher.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an exception that prevents it from emitting the expected item\n     * to its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onExceptionResumeNext} method changes\n     * this behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onExceptionResumeNext} method, if the original Publisher encounters an exception, instead of\n     * invoking its Subscriber's {@code onError} method, it will instead relinquish control to\n     * {@code resumeSequence} which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an exception happened.\n     * <p>\n     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher that will take over if the source Publisher encounters\n     *            an exception\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, Functions.justFunction(next), true));\n    }\n\n    \/**\n     * Nulls out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Flowable which out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onTerminateDetach() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDetach<T>(this));\n    }\n\n    \/**\n     * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel() {\n        return ParallelFlowable.from(this);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        return ParallelFlowable.from(this, parallelism);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion and\n     * uses the defined per-'rail' prefetch amount.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @param prefetch the number of items each 'rail' should prefetch\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism, int prefetch) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return ParallelFlowable.from(this, parallelism, prefetch);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish() {\n        return publish(bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        return publish(selector, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<? extends R>> selector, int prefetch) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowablePublishMulticast<T, R>(this, selector, prefetch, false));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowablePublish.create(this, bufferSize);\n    }\n\n    \/**\n     * Requests {@code n} initially from the upstream and then 75% of {@code n} subsequently\n     * after 75% of {@code n} values have been emitted to the downstream.\n     *\n     * <p>This operator allows preventing the downstream to trigger unbounded mode via {@code request(Long.MAX_VALUE)}\n     * or compensate for the per-item overhead of small and frequent requests.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects backpressure from upstream and honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param n the initial request amount, further request will happen after 75% of this value\n     * @return the Publisher that rebatches request amounts from downstream\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> rebatchRequests(int n) {\n        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);\n    }\n\n    \/**\n     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * and emits the final result from the final call to your function as its sole item.\n     * <p>\n     * If the source is empty, a {@code NoSuchElementException} is signalled.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduce.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be used in the next accumulator call\n     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by\n     *         the source Flowable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduce<T>(this, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seed\n     *            the initial (seed) accumulator value\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seed, \"seed is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceSeed<T, R>(this, seed, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduceWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seedSupplier\n     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceWith<T, R>(this, seedSupplier, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher indefinitely.\n     * <p>\n     * <img width=\"640\" height=\"309\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher repeatedly and in sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat() {\n        return repeat(Long.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     * {@code count} times.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param times\n     *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty\n     *            sequence\n     * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     *         {@code count} times\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat(long times) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        if (times == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeat<T>(this, times));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher until\n     * the provided stop function returns true.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stop\n     *                a boolean supplier that is called when the current Flowable completes and unless it returns\n     *                false, the current Flowable is resubscribed\n     * @return the new Flowable instance\n     * @throws NullPointerException\n     *             if {@code stop} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatUntil(BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatUntil<T>(this, stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of\n     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will\n     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeatWhen.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.\n     * @return the source Publisher modified with repeat logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatWhen<T>(this, handler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher\n     * that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its\n     *         items to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay() {\n        return FlowableReplay.createFrom(this);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on the items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @return a Flowable that emits items that are the results of invoking the selector on a\n     *         {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying {@code bufferSize} notifications.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     *         replaying no more than {@code bufferSize} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {\n        return replay(selector, bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(\n                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying a maximum of {@code bufferSize} items.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param scheduler\n     *            the Scheduler on which the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying no more than {@code bufferSize} notifications\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),\n                FlowableInternalHelper.replayFunction(selector, scheduler)\n        );\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"435\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ft.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {\n        return replay(selector, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fs.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param scheduler\n     *            the Scheduler where the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),\n                FlowableInternalHelper.replayFunction(selector, scheduler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items emitted by that Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay(final int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {\n        return replay(bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A\n     * Connectable Publisher resembles an ordinary Publisher, except that it does not begin emitting items\n     * when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is used as a time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param scheduler\n     *            the scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted by the Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(bufferSize), scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(long time, TimeUnit unit) {\n        return replay(time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.create(this, time, unit, scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * will replay all of its items and notifications to any future {@link Subscriber} on the given\n     * {@link Scheduler}. A Connectable Publisher resembles an ordinary Publisher, except that it does not\n     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the Scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     *         will replay all of its items and notifications to any future {@link Subscriber} on the given\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(), scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * (infinite retry count).\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher rather than propagating the {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry() {\n        return retry(Long.MAX_VALUE, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * and the predicate returns true for that specific exception and retry count.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the predicate that determines if a resubscription may happen in case of a specific exception\n     *            and retry count\n     * @return the source Publisher modified with retry logic\n     * @see #retry()\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryBiPredicate<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * up to a specified number of retries.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher for a maximum of {@code count} resubscriptions rather than propagating the\n     * {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of retry attempts before failing\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long count) {\n        return retry(count, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Retries at most times or until the predicate returns false, whichever happens first.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param times the number of times to repeat\n     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate));\n    }\n\n    \/**\n     * Retries the current Flowable if the predicate returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {\n        return retry(Long.MAX_VALUE, predicate);\n    }\n\n    \/**\n     * Retries until the given stop function returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param stop the function that should return true to stop retrying\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryUntil(final BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onError}. An {@code onError} notification from the source will result in the emission of a\n     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call\n     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retryWhen.f.png\" alt=\"\">\n     *\n     * Example:\n     *\n     * This retries 3 times, each time incrementing the number of seconds it waits.\n     *\n     * <pre><code>\n     *  Publisher.create((Subscriber<? super String> s) -> {\n     *      System.out.println(\"subscribing\");\n     *      s.onError(new RuntimeException(\"always fails\"));\n     *  }).retryWhen(attempts -> {\n     *      return attempts.zipWith(Publisher.range(1, 3), (n, i) -> i).flatMap(i -> {\n     *          System.out.println(\"delay retry by \" + i + \" second(s)\");\n     *          return Publisher.timer(i, TimeUnit.SECONDS);\n     *      });\n     *  }).blockingForEach(System.out::println);\n     * <\/code><\/pre>\n     *\n     * Output is:\n     *\n     * <pre> {@code\n     * subscribing\n     * delay retry by 1 second(s)\n     * subscribing\n     * delay retry by 2 second(s)\n     * subscribing\n     * delay retry by 3 second(s)\n     * subscribing\n     * } <\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the\n     *            retry\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryWhen(\n            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryWhen<T>(this, handler));\n    }\n\n    \/**\n     * Subscribes to the current Flowable and wraps the given Subscriber into a SafeSubscriber\n     * (if not already a SafeSubscriber) that\n     * deals with exceptions thrown by a misbehaving Subscriber (that doesn't follow the\n     * Reactive-Streams specification).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>This operator leaves the reactive world and the backpressure behavior depends on the Subscriber's behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the incoming Subscriber instance\n     * @throws NullPointerException if s is null\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void safeSubscribe(Subscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        if (s instanceof SafeSubscriber) {\n            subscribe((SafeSubscriber<? super T>)s);\n        } else {\n            subscribe(new SafeSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> sample(long period, TimeUnit unit) {\n        return sample(period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) {\n        return sample(period, unit, Schedulers.computation(), emitLast);\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler\n     * and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.nolast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> sample(Publisher<U> sampler) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher\n     * and optionally emit the very last upstream item when the upstream or other Publisher complete.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final <U> Flowable<T> sample(Publisher<U> sampler, boolean emitLast) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scan.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits the results of each call to the accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> scan(BiFunction<T, T, T> accumulator) {\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScan<T>(this, accumulator));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param initialValue\n     *            the initial (seed) accumulator item\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(initialValue, \"seed is null\");\n        return scanWith(Functions.justCallable(initialValue), accumulator);\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <p>\n     * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scanWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param seedSupplier\n     *            a Callable that returns the initial (seed) accumulator item for each individual Subscriber\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));\n    }\n\n    \/**\n     * Forces a Publisher's emissions and notifications to be serialized and for it to obey\n     * <a href=\"http:\/\/reactivex.io\/documentation\/contract.html\">the Publisher contract<\/a> in other ways.\n     * <p>\n     * It is possible for a Publisher to invoke its Subscribers' methods asynchronously, perhaps from\n     * different threads. This could make such a Publisher poorly-behaved, in that it might try to invoke\n     * {@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call\n     * {@code onNext} from two different threads concurrently. You can force such a Publisher to be\n     * well-behaved and sequential by applying the {@code serialize} method to it.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/synchronize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code serialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Publisher} that is guaranteed to be well-behaved and to make only serialized calls to\n     *         its Subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/serialize.html\">ReactiveX operators documentation: Serialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> serialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSerialized<T>(this));\n    }\n\n    \/**\n     * Returns a new {@link Publisher} that multicasts (shares) the original {@link Publisher}. As long as\n     * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.\n     * When all subscribers have cancelled it will cancel the source {@link Publisher}.\n     * <p>\n     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount()}.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishRefCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure and and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator will signal a {@code MissingBackpressureException} to\n     *  its {@code Subscriber}s.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code share} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@code Publisher} that upon connection causes the source {@code Publisher} to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/refcount.html\">ReactiveX operators documentation: RefCount<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> share() {\n        return publish().refCount();\n    }\n\n    \/**\n     * Returns a Maybe that completes if this Flowable is empty, signals one item if this Flowable\n     * signals exactly one item or signals an {@code IllegalArgumentException} if this Flowable signals\n     * more than one item.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Maybe that emits the single item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher\n     * emits only a single item, or a default item if the source Publisher emits no items. If the source\n     * Publisher emits more than one item, an {@code IllegalArgumentException} is signalled instead.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code single} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to emit if the source Publisher emits no item\n     * @return a Single that emits the single item emitted by the source Publisher, or a default item if\n     *         the source Publisher is empty\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> single(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by this Flowable, if this Flowable\n     * emits only a single item, otherwise\n     * if this Flowable completes without emitting any items a {@link NoSuchElementException} will be signalled and\n     * if this Flowable emits more than one item, an {@code IllegalArgumentException} will be signalled.\n     * <p>\n     * <img width=\"640\" height=\"205\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, true));\n    }\n\n    \/**\n     * Returns a Flowable that skips the first {@code count} items emitted by the source Publisher and emits\n     * the remainder.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the number of items to skip\n     * @return a Flowable that is identical to the source Publisher except that it does not emit the first\n     *         {@code count} items that the source Publisher emits\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long count) {\n        if (count <= 0L) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkip<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skip} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} elapses and the emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long time, TimeUnit unit) {\n        return skipUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * on a specified {@link Scheduler} elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for the timed skipping<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} on which the timed wait happens\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that drops a specified number of items from the end of the sequence emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.png\" alt=\"\">\n     * <p>\n     * This Subscriber accumulates a queue long enough to store the first {@code count} items. As more items are\n     * received, items are taken from the front of the queue and emitted by the returned Publisher. This causes\n     * such items to be delayed.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of items to drop from the end of the source sequence\n     * @return a Flowable that emits the items emitted by the source Publisher except for the dropped ones\n     *         at the end\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit) {\n        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) {\n        return skipLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use to track the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return skipLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be skipped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        \/\/ the internal buffer holds pairs of (timestamp, value) so double the default buffer size\n        int s = bufferSize << 1;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that skips items emitted by the source Publisher until a second Publisher emits\n     * an item.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param other\n     *            the second Publisher that has to emit an item before the source Publisher's elements begin\n     *            to be mirrored by the resulting Publisher\n     * @return a Flowable that skips items from the source Publisher until the second Publisher emits an\n     *         item, then emits the remaining items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipuntil.html\">ReactiveX operators documentation: SkipUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> skipUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that skips all items emitted by the source Publisher as long as a specified\n     * condition holds true, but emits all further source items as soon as the condition becomes false.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function to test each item emitted from the source Publisher\n     * @return a Flowable that begins emitting items emitted by the source Publisher when the specified\n     *         predicate becomes false\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipwhile.html\">ReactiveX operators documentation: SkipWhile<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));\n    }\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted() {\n        return toList().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order based on a specified comparison function.\n     *\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param sortFunction\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Iterable} before it begins to emit items\n     * emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            an Iterable that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Iterable<? extends T> items) {\n        return concatArray(fromIterable(items), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Publisher} before it begins to emit\n     * items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Publisher} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concatArray(other, this);\n    }\n\n    \/**\n     * Returns a Flowable that emits a specified item before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param value\n     *            the item to emit first\n     * @return a Flowable that emits the specified item before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(T value) {\n        ObjectHelper.requireNonNull(value, \"item is null\");\n        return concatArray(just(value), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the specified items before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWithArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of values to emit first\n     * @return a Flowable that emits the specified items before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWithArray(T... items) {\n        Flowable<T> fromArray = fromArray(items);\n        if (fromArray == empty()) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return concatArray(fromArray, this);\n    }\n\n    \/**\n     * Ensures that the event flow between the upstream and downstream follow\n     * the Reactive-Streams 1.0 specification by honoring the 3 additional rules\n     * (which are omitted in standard operators due to performance reasons).\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns<\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel<\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException)<\/li>\n     * <\/ul>\n     * In addition, if rule \u00a72.12 (onSubscribe must be called at most once) is violated,\n     * the sequence is cancelled an onError(IllegalStateException) is emitted.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code strict} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     * @since 2.0.5 - experimental\n     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    @CheckReturnValue\n    @Deprecated\n    public final Flowable<T> strict() {\n        return this;\n    }\n\n    \/**\n     * Subscribes to a Publisher and ignores {@code onNext} and {@code onComplete} emissions.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe() {\n        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides a callback to handle the items it emits.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext) {\n        return subscribe(onNext, Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error\n     * notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete) {\n        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @param onSubscribe\n     *             the {@code Consumer} that receives the upstream's Subscription\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Consumer<? super Subscription> onSubscribe) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n\n        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);\n\n        subscribe(ls);\n\n        return ls;\n    }\n\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Override\n    public final void subscribe(Subscriber<? super T> s) {\n        if (s instanceof RelaxedSubscriber) {\n            subscribe((RelaxedSubscriber<? super T>)s);\n        } else {\n            ObjectHelper.requireNonNull(s, \"s is null\");\n            subscribe(new StrictSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Establish a connection between this Flowable and the given RelaxedSubscriber and\n     * start streaming events based on the demand of the RelaxedSubscriber.\n     * <p>\n     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n     * <p>\n     * Each {@link Subscription} will work for only a single {@link RelaxedSubscriber}.\n     * <p>\n     * If the same {@link RelaxedSubscriber} instance is subscribed to multiple {@link Flowable}s and\/or the\n     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}\n     * methods manually.\n     * <p>\n     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal\n     * the error via {@link RelaxedSubscriber#onError(Throwable)}.\n     * <p>\n     * This subscribe method relaxes the following Reactive-Streams rules:\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns.\n     *     <b>RelaxedSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.<\/b><\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel.\n     *     <b>Calling request() or cancel() is NOP at this point.<\/b><\/li>\n     * <li>\u00a72.12: onSubscribe must be called at most once on the same instance.\n     *     <b>RelaxedSubscriber reuse is not checked and if happens, it is the responsibility of\n     *     the RelaxedSubscriber to ensure proper serialization of its onXXX methods.<\/b><\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException).\n     *     <b>Non-positive requests signal via RxJavaFlowablePlugins.onError and the stream is not affected.<\/b><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code RelaxedSubscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the RelaxedSubscriber that will consume signals from this Flowable\n     * @since 2.0.7 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final void subscribe(RelaxedSubscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        try {\n            Subscriber<? super T> z = RxJavaFlowablePlugins.onSubscribe(this, s);\n\n            ObjectHelper.requireNonNull(z, \"Plugin returned null Subscriber\");\n\n            subscribeActual(z);\n        } catch (NullPointerException e) { \/\/ NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            \/\/ can't call onError because no way to know if a Subscription has been set or not\n            \/\/ can't call onSubscribe because the call might have set a Subscription already\n            RxJavaCommonPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n\n    \/**\n     * Operator implementations (both source and intermediate) should implement this method that\n     * performs the necessary business logic.\n     * <p>There is no need to call any of the plugin hooks on the current Flowable instance or\n     * the Subscriber.\n     * @param s the incoming Subscriber, never null\n     *\/\n    protected abstract void subscribeActual(Subscriber<? super T> s);\n\n    \/**\n     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given\n     * Subscriber as is.\n     * <p>Usage example:\n     * <pre><code>\n     * Flowable&lt;Integer> source = Flowable.range(1, 10);\n     * CompositeDisposable composite = new CompositeDisposable();\n     *\n     * ResourceSubscriber&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n     *     \/\/ ...\n     * };\n     *\n     * composite.add(source.subscribeWith(rs));\n     * <\/code><\/pre>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code Subscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <E> the type of the Subscriber to use and return\n     * @param subscriber the Subscriber (subclass) to use and return, not null\n     * @return the input {@code subscriber}\n     * @throws NullPointerException if {@code subscriber} is null\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n        subscribe(subscriber);\n        return subscriber;\n    }\n\n    \/**\n     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/subscribeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform subscription actions on\n     * @return the source Publisher modified so that its subscriptions happen on the\n     *         specified {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #observeOn\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or the items of an alternate\n     * Publisher if the source Publisher is empty.\n     * <img width=\"640\" height=\"255\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchifempty.png\" alt=\"\">\n     * <p\/>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, the alternate {@code Publisher} is expected to honor backpressure.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as instead.\n     *  In either case, if violated, a {@code MissingBackpressureException} <em>may<\/em> get\n     *  signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *              the alternate Publisher to subscribe to if the source does not emit any items\n     * @return  a Publisher that emits the items emitted by the source Publisher or the items of an\n     *          alternate Publisher if the source Publisher is empty.\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMap(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, false);\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMapDelayError(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, true);\n    }\n\n    <R> Flowable<R> switchMap0(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize, boolean delayError) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchMap<T, R>(this, mapper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.png\" alt=\"\">\n     * <p>\n     * This method returns a Publisher that will invoke a subscribing {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking\n     * {@link Subscriber#onComplete onComplete}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior in case the first request is smaller than the {@code count}. Otherwise, the source {@code Publisher}\n     *  is consumed in an unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @return a Flowable that emits only the first {@code count} items emitted by the source Publisher, or\n     *         all of the items from the source Publisher if that Publisher emits fewer than {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> take(long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTake<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time runs\n     * out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> take(long time, TimeUnit unit) {\n        return takeUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time (on a\n     * specified Scheduler) runs out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler used for time source\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out,\n     *         according to the specified Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream if the {@code count} is non-zero; ignores\n     *  backpressure if the {@code count} is zero as it doesn't signal any values.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit from the end of the sequence of items emitted by the source\n     *            Publisher\n     * @return a Flowable that emits at most the last {@code count} items emitted by the source Publisher\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n        } else\n        if (count == 1) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastOne<T>(this));\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {\n        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(count, time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit) {\n        return takeLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) {\n        return takeLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return takeLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher, checks the specified predicate\n     * for each item, and then completes when the condition is satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.p.png\" alt=\"\">\n     * <p>\n     * The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition is\n     * evaluated <em>after<\/em> the item is emitted.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstream\n     *  source and the downstream consumer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stopPredicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that first emits items emitted by the source Publisher, checks the specified\n     *         condition after each item, and then completes when the condition is satisfied.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     * @see Flowable#takeWhile(Predicate)\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {\n        ObjectHelper.requireNonNull(stopPredicate, \"stopPredicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher until a second Publisher\n     * emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items\n     *            from the source Publisher\n     * @param <U>\n     *            the type of items emitted by {@code other}\n     * @return a Flowable that emits the items emitted by the source Publisher until such time as {@code other} emits its first item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> takeUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher so long as each item satisfied a\n     * specified condition, and then completes as soon as this condition is not satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that emits the items from the source Publisher so long as each item satisfies the\n     *         condition defined by {@code predicate}, then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\">ReactiveX operators documentation: TakeWhile<\/a>\n     * @see Flowable#takeUntil(Predicate)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param windowDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code windowDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {\n        return throttleFirst(windowDuration, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the windows are managed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param skipDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code skipDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {\n        return sample(intervalDuration, unit);\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the duration is governed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {\n        return sample(intervalDuration, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window, where the time window is governed by a specified\n     * Scheduler.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {\n        return debounce(timeout, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval() {\n        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(Scheduler scheduler) {\n        return timeInterval(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {\n        return timeInterval(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if an item emitted by the source Publisher doesn't arrive within a window of\n     * time after the emission of the previous item, where that period of time is measured by a Publisher that\n     * is a function of the previous item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout3.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source\n     *            Publisher and that determines the timeout window for the subsequent item\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if an item emitted by the source Publisher takes longer to arrive than\n     *         the time window defined by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        return timeout0(null, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but that switches to a fallback Publisher if\n     * an item emitted by the source Publisher doesn't arrive within a window of time after the emission of the\n     * previous item, where that period of time is measured by a Publisher that is a function of the previous\n     * item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout4.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher, for each item emitted by the source Publisher, that\n     *            determines the timeout window for the subsequent item\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to mirroring a fallback Publisher\n     *         if an item emitted by the source Publisher takes longer to arrive than the time window defined\n     *         by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator, Flowable<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(null, itemTimeoutIndicator, other);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher terminates and notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between emitted items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument.\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {\n        return timeout0(timeout, timeUnit, null, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param other\n     *            the fallback Publisher to use in case of a timeout\n     * @return the source Publisher modified to switch to the fallback Publisher in case of a timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration\n     * starting from its predecessor, the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to run the timeout timers on\n     * @param other\n     *            the Publisher to use as the fallback in case of a timeout\n     * @return the source Publisher modified so that it will switch to the fallback Publisher in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the\n     * specified timeout duration starting from its predecessor, the resulting Publisher terminates and\n     * notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the Scheduler to run the timeout timers on\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {\n        return timeout0(timeout, timeUnit, null, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if either the first item emitted by the source Publisher or any subsequent item\n     * doesn't arrive within time windows defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher that determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within\n     *         the time windows specified by the timeout selectors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutIndicator is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but switches to a fallback Publisher if either\n     * the first item emitted by the source Publisher or any subsequent item doesn't arrive within time windows\n     * defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher which determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to the {@code other} Publisher if\n     *         either the first item emitted by the source Publisher or any subsequent item doesn't arrive\n     *         within time windows defined by the timeout selectors\n     * @throws NullPointerException\n     *             if {@code itemTimeoutIndicator} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutSelector is null\");\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, other);\n    }\n\n    private Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,\n            Scheduler scheduler) {\n        ObjectHelper.requireNonNull(timeUnit, \"timeUnit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other));\n    }\n\n    private <U, V> Flowable<T> timeout0(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(itemTimeoutIndicator, \"itemTimeoutIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeout<T, U, V>(this, firstTimeoutIndicator, itemTimeoutIndicator, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp() {\n        return timestamp(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {\n        return timestamp(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp(TimeUnit unit) {\n        return timestamp(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return map(Functions.<T>timestampWith(unit, scheduler));\n    }\n\n    \/**\n     * Calls the specified converter function during assembly time and returns its resulting value.\n     * <p>\n     * This allows fluent conversion to any other type.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The backpressure behavior depends on what happens in the {@code converter} function.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code to} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the resulting object type\n     * @param converter the function that receives the current Flowable instance and returns a value\n     * @return the value returned by the function\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> R to(Function<? super Flowable<T>, R> converter) {\n        try {\n            return ObjectHelper.requireNonNull(converter, \"converter is null\").apply(this);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, ArrayListSupplier.<T>asCallable()));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *         the number of elements expected from the current Flowable\n     * @return a Flowable that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList(final int capacityHint) {\n        ObjectHelper.verifyPositive(capacityHint, \"capacityHint\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the subclass of a collection of Ts\n     * @param collectionSupplier\n     *               the Callable returning the collection (for each individual Subscriber) to be filled in\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> toList(Callable<U> collectionSupplier) {\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, U>(this, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing all items emitted by the source Publisher,\n     * mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return collect(HashMapSupplier.<K, T>asCallable(), Functions.toMapKeySelector(keySelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing values corresponding to items emitted by the\n     * source Publisher, mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain a single entry that\n     * corresponds to the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @param valueSelector\n     *            the function that extracts the value from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(HashMapSupplier.<K, V>asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains keys and values extracted from the items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the Map\n     * @param valueSelector\n     *            the function that extracts the value from the source items to be used as value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Flowable that emits a single item: a Map that contains the mapped items emitted by the\n     *         source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, V>> mapSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of items emitted by the\n     * source Publisher keyed by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from the source items to be used as key in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {\n        Function<T, T> valueSelector = Functions.identity();\n        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of values extracted by a\n     * specified {@code valueSelector} function from items emitted by the source Publisher, keyed by a\n     * specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as key in the HashMap\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as value in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {\n        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from\n     * items emitted by the source Publisher, and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @param collectionFactory\n     *            the function that returns a Collection instance for a particular key to be used in the Map\n     * @return a Single that emits a single item: a Map that contains the collection of mapped items from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, Collection<V>>> mapSupplier,\n            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.requireNonNull(mapSupplier, \"mapSupplier is null\");\n        ObjectHelper.requireNonNull(collectionFactory, \"collectionFactory is null\");\n        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items\n     * emitted by the source Publisher and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Single that emits a single item: a Map that contains a list items mapped from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            Callable<Map<K, Collection<V>>> mapSupplier\n            ) {\n        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList() {\n        return toSortedList(Functions.naturalComparator());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList().map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList(capacityHint).map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Flowable that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Flowable that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(int capacityHint) {\n        return toSortedList(Functions.naturalComparator(), capacityHint);\n    }\n\n    \/**\n     * Modifies the source Publisher so that subscribers will cancel it on a specified\n     * {@link Scheduler}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform cancellation actions on\n     * @return the source Publisher modified so that its cancellations happen on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current window and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows, each containing at most\n     *         {@code count} items from the source Publisher\n     * @throws IllegalArgumentException if either count is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count) {\n        return window(count, count, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip) {\n        return window(count, skip, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {\n        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return window(timespan, timeskip, unit, scheduler, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.verifyPositive(timespan, \"timespan\");\n        ObjectHelper.verifyPositive(timeskip, \"timeskip\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping windows representing items emitted by the\n     *         source Publisher during fixed, consecutive durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) {\n        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count) {\n        return window(timespan, unit, Schedulers.computation(), count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count, boolean restart) {\n        return window(timespan, unit, Schedulers.computation(), count, restart);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows containing items emitted by the\n     *         source Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler) {\n        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count) {\n        return window(timespan, unit, scheduler, count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count, boolean restart) {\n        return window(timespan, unit, scheduler, count, restart, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(\n            long timespan, TimeUnit unit, Scheduler scheduler,\n            long count, boolean restart, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator) {\n        return window(boundaryIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundaryIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator) {\n        return window(openingIndicator, closingIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return window(boundaryIndicatorSupplier, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));\n    }\n\n    \/**\n     * Merges the specified Publisher into this Publisher sequence by using the {@code resultSelector}\n     * function only when the source Publisher (this instance) emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/withLatestFrom.png\" alt=\"\">\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure: the backpressure support\n     *  depends on the upstream and downstream's backpressure behavior. The other Publisher\n     *  is consumed in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator, by default, doesn't run any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param <R> the result type of the combination\n     * @param other\n     *            the other Publisher\n     * @param combiner\n     *            the function to call when this Publisher emits an item and the other Publisher has already\n     *            emitted an item, to generate the item to be emitted by the resulting Publisher\n     * @return a Flowable that merges the specified Publisher into this Publisher by using the\n     *         {@code resultSelector} function only when the source Publisher sequence (this instance) emits an\n     *         item\n     * @since 2.0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> withLatestFrom(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFrom<T, U, R>(this, combiner, other));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> source1, Publisher<T2> source2,\n            Function3<? super T, ? super T1, ? super T2, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3,\n            Function4<? super T, ? super T1, ? super T2, ? super T3, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <T4> the fourth other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param source4 the fourth other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, T4, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3, Publisher<T4> source4,\n            Function5<? super T, ? super T1, ? super T2, ? super T3, ? super T4, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the array of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Publisher<?>[] others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the iterable of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Iterable<? extends Publisher<?>> others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and a specified Iterable sequence.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.i.png\" alt=\"\">\n     * <p>\n     * Note that the {@code other} Iterable is evaluated as items are observed from the source Publisher; it is\n     * not pre-consumed. This allows you to zip infinite streams on either side.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items in the {@code other} Iterable\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the Iterable sequence\n     * @param zipper\n     *            a function that combines the pairs of items from the Publisher and the Iterable to generate\n     *            the items to be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Iterable\n     *         sequence and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return zip(this, other, zipper);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {\n        return zip(this, other, zipper, delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {\n        return zip(this, other, zipper, delayError, bufferSize);\n    }\n\n    \/\/ -------------------------------------------------------------------------\n    \/\/ Fluent test support, super handy and reduces test preparation boilerplate\n    \/\/ -------------------------------------------------------------------------\n    \/**\n     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber consumes this Flowable in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test() { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>();\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount,\n     * optionally cancels it before the subscription and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @param cancel should the TestSubscriber be cancelled before the subscription?\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest, boolean cancel) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        if (cancel) {\n            ts.cancel();\n        }\n        subscribe(ts);\n        return ts;\n    }\n\n}\n","new_contents":"\/**\n * Copyright (c) 2016-present, RxJava Contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n * the License for the specific language governing permissions and limitations under the License.\n *\/\npackage io.reactivex.flowable;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\nimport org.reactivestreams.*;\n\nimport hu.akarnokd.reactivestreams.extensions.*;\nimport io.reactivex.common.*;\nimport io.reactivex.common.annotations.*;\nimport io.reactivex.common.exceptions.Exceptions;\nimport io.reactivex.common.functions.*;\nimport io.reactivex.common.internal.functions.*;\nimport io.reactivex.common.internal.schedulers.ImmediateThinScheduler;\nimport io.reactivex.common.internal.utils.*;\nimport io.reactivex.flowable.internal.operators.*;\nimport io.reactivex.flowable.internal.subscribers.*;\nimport io.reactivex.flowable.subscribers.*;\n\n\/**\n * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,\n * intermediate operators and the ability to consume reactive dataflows.\n * <p>\n * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators\n * therefore accept general {@code Publisher}s directly and allow direct interoperation with other\n * Reactive-Streams implementations.\n * <p>\n * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},\n * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have\n * overloads that allow setting their internal buffer size explicitly.\n * <p>\n * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:\n * <p>\n * <img width=\"640\" height=\"317\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/legend.png\" alt=\"\">\n * <p>\n * For more information see the <a href=\"http:\/\/reactivex.io\/documentation\/Publisher.html\">ReactiveX\n * documentation<\/a>.\n *\n * @param <T>\n *            the type of the items emitted by the Flowable\n *\/\npublic abstract class Flowable<T> implements Publisher<T> {\n    \/** The default buffer size. *\/\n    static final int BUFFER_SIZE;\n    static {\n        BUFFER_SIZE = Math.max(1, Integer.getInteger(\"rx2.buffer-size\", 128));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an Iterable of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an Iterable of Publishers sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(null, sources));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an array of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an array of Publisher sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> ambArray(Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        int len = sources.length;\n        if (len == 0) {\n            return empty();\n        } else\n        if (len == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(sources, null));\n    }\n\n    \/**\n     * Returns the default internal buffer size used by most async operators.\n     * <p>The value can be overridden via system parameter {@code rx2.buffer-size}\n     * <em>before<\/em> the Flowable class is loaded.\n     * @return the default internal buffer size.\n     *\/\n    public static int bufferSize() {\n        return BUFFER_SIZE;\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Function<? super Object[], ? extends R> combiner, Publisher<? extends T>... sources) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publisher, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Publisher\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            int bufferSize, Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize);\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines two source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from either of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return combineLatest(f, source1, source2);\n    }\n\n    \/**\n     * Combines three source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);\n    }\n\n    \/**\n     * Combines four source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Combines five source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Combines six source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Combines seven source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Combines eight source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Combines nine source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <T9> the element type of the ninth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param source9\n     *            the ninth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Concatenates elements of each Publisher provided via an Iterable sequence into a single sequence\n     * of elements without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the common value type of the sources\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Flowable instance\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        \/\/ unlike general sources, fromIterable can only throw on a boundary because it is consumed only there\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), 2, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {\n        return concat(sources, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param prefetch\n     *            the number of Publishers to prefetch from the sources sequence.\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by two Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return concatArray(source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by three Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the three source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return concatArray(source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by four Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @param source4\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the four source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return concatArray(source1, source2, source3, source4);\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources.\n     * <p>\n     * Note: named this way because of overload conflict with concat(Publisher&lt;Publisher&gt).\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Publisher instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, false));\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources and delays errors from any of them\n     * till all terminate.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Flowable instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, true));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {\n        return concatArrayEager(bufferSize(), bufferSize(), sources);\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE\n     *                       is interpreted as indication to subscribe to all sources at once\n     * @param prefetch the number of elements to prefetch from each Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\n     * one after the other, one at a time and delays any errors till the all inner Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity());\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatDelayError(sources, bufferSize(), true);\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @param prefetch the number of elements to prefetch from the outer Publisher\n     * @param tillTheEnd if true exceptions from the outer and all inner Publishers are delayed to the end\n     *                   if false, exception from the outer Publisher is delayed till the current Publisher terminates\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {\n        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and the inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Provides an API (via a cold Flowable) that bridges the reactive world with the callback-style,\n     * generally non-backpressured world.\n     * <p>\n     * Example:\n     * <pre><code>\n     * Flowable.&lt;Event&gt;create(emitter -&gt; {\n     *     Callback listener = new Callback() {\n     *         &#64;Override\n     *         public void onEvent(Event e) {\n     *             emitter.onNext(e);\n     *             if (e.isLast()) {\n     *                 emitter.onComplete();\n     *             }\n     *         }\n     *\n     *         &#64;Override\n     *         public void onFailure(Exception e) {\n     *             emitter.onError(e);\n     *         }\n     *     };\n     *\n     *     AutoCloseable c = api.someMethod(listener);\n     *\n     *     emitter.setCancellable(c::close);\n     *\n     * }, BackpressureStrategy.BUFFER);\n     * <\/code><\/pre>\n     * <p>\n     * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The\n     * rest of its methods are thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior is determined by the {@code mode} parameter.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code create} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type\n     * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}\n     * @param mode the backpressure mode to apply if the downstream Subscriber doesn't request (fast) enough\n     * @return the new Flowable instance\n     * @see FlowableOnSubscribe\n     * @see BackpressureStrategy\n     * @see Cancellable\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        ObjectHelper.requireNonNull(mode, \"mode is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCreate<T>(source, mode));\n    }\n\n    \/**\n     * Returns a Flowable that calls a Publisher factory to create a Publisher for each new Subscriber\n     * that subscribes. That is, for each subscriber, the actual Publisher that subscriber observes is\n     * determined by the factory function.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defer.png\" alt=\"\">\n     * <p>\n     * The defer Subscriber allows you to defer or delay emitting items from a Publisher until such time as an\n     * Subscriber subscribes to the Publisher. This allows a {@link Subscriber} to easily obtain updates or a\n     * refreshed version of the sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}\n     *  returned by the {@code supplier}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            the Publisher factory function to invoke for each {@link Subscriber} that subscribes to the\n     *            resulting Publisher\n     * @param <T>\n     *            the type of the items emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given\n     *         Publisher factory function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defer.html\">ReactiveX operators documentation: Defer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> defer(Callable<? extends Publisher<? extends T>> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDefer<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits no items to the {@link Subscriber} and immediately invokes its\n     * {@link Subscriber#onComplete onComplete} method.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/empty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code empty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that emits no items to the {@link Subscriber} but immediately invokes the\n     *         {@link Subscriber}'s {@link Subscriber#onComplete() onComplete} method\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Empty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> empty() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            a Callable factory to return a Throwable for each individual Subscriber\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"errorSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableError<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param throwable\n     *            the particular Throwable to pass to {@link Subscriber#onError onError}\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(final Throwable throwable) {\n        ObjectHelper.requireNonNull(throwable, \"throwable is null\");\n        return error(Functions.justCallable(throwable));\n    }\n\n    \/**\n     * Converts an Array into a Publisher that emits the items in the Array.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code array}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of elements\n     * @param <T>\n     *            the type of items in the Array and the type of items to be emitted by the resulting Publisher\n     * @return a Flowable that emits each item in the source Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromArray(T... items) {\n        ObjectHelper.requireNonNull(items, \"items is null\");\n        if (items.length == 0) {\n            return empty();\n        }\n        if (items.length == 1) {\n            return just(items[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromArray<T>(items));\n    }\n\n    \/**\n     * Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then\n     * emits the value returned from that function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/fromCallable.png\" alt=\"\">\n     * <p>\n     * This allows you to defer the execution of the function you specify until a Subscriber subscribes to the\n     * Publisher. That is to say, it makes the function \"lazy.\"\n     * <dl>\n     *   <dt><b>Backpressure:<\/b><\/dt>\n     *   <dd>The operator honors backpressure from downstream.<\/dd>\n     *   <dt><b>Scheduler:<\/b><\/dt>\n     *   <dd>{@code fromCallable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this\n     *         function only when a Subscriber subscribes to the Publisher that {@code fromCallable} returns\n     * @param <T>\n     *         the type of the item emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given function\n     * @see #defer(Callable)\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromCallable(Callable<? extends T> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromCallable<T>(supplier));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, 0L, null));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, timeout, unit));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.s.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"cast\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts an {@link Iterable} sequence into a Publisher that emits the items in the sequence.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code iterable}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source\n     *            the source {@link Iterable} sequence\n     * @param <T>\n     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the\n     *            resulting Publisher\n     * @return a Flowable that emits each item in the source {@link Iterable} sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromIterable<T>(source));\n    }\n\n    \/**\n     * Converts an arbitrary Reactive-Streams Publisher into a Flowable if not already a\n     * Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and its behavior is determined by the\n     *  backpressure behavior of the wrapped publisher.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type of the flow\n     * @param source the Publisher to convert\n     * @return the new Flowable instance\n     * @throws NullPointerException if publisher is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> source) {\n        if (source instanceof Flowable) {\n            return RxJavaFlowablePlugins.onAssembly((Flowable<T>)source);\n        }\n        ObjectHelper.requireNonNull(source, \"publisher is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(source));\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateless and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the generated value type\n     * @param generator the Consumer called whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> generate(final Consumer<Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(Functions.nullSupplier(),\n                FlowableInternalHelper.<T, Object>simpleGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator,\n            Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), disposeState);\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {\n        return generate(initialState, generator, Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator, Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(initialState, \"initialState is null\");\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        ObjectHelper.requireNonNull(disposeState, \"disposeState is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGenerate<T, S>(initialState, generator, disposeState));\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.p.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) {\n        return interval(initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.ps.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @param scheduler\n     *            the Scheduler on which the waiting happens and items are emitted\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter, while running on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream\n     *  is not ready to receive the next value.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long period, TimeUnit unit) {\n        return interval(period, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time, on a\n     * specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @param scheduler\n     *            the Scheduler to use for scheduling the items\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {\n        return interval(period, period, unit, scheduler);\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {\n        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>you provide the {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @param scheduler the target scheduler where the values and terminal signals will be emitted\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0L) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0L) {\n            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a single item and then completes.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.png\" alt=\"\">\n     * <p>\n     * To convert any object into a Publisher that emits that object, pass that object into the {@code just}\n     * method.\n     * <p>\n     * This is similar to the {@link #fromArray(java.lang.Object[])} method, except that {@code from} will convert\n     * an {@link Iterable} object into a Publisher that emits each of the items in the Iterable, one at a\n     * time, while the {@code just} method converts an Iterable into a Publisher that emits the entire\n     * Iterable as a single item.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to emit\n     * @param <T>\n     *            the type of that item\n     * @return a Flowable that emits {@code value} as a single item and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJust<T>(item));\n    }\n\n    \/**\n     * Converts two items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n\n        return fromArray(item1, item2);\n    }\n\n    \/**\n     * Converts three items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n\n        return fromArray(item1, item2, item3);\n    }\n\n    \/**\n     * Converts four items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n\n        return fromArray(item1, item2, item3, item4);\n    }\n\n    \/**\n     * Converts five items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5);\n    }\n\n    \/**\n     * Converts six items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6);\n    }\n\n    \/**\n     * Converts seven items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7);\n    }\n\n    \/**\n     * Converts eight items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);\n    }\n\n    \/**\n     * Converts nine items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);\n    }\n\n    \/**\n     * Converts ten items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param item10\n     *            tenth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth item is null\");\n        ObjectHelper.requireNonNull(item10, \"The tenth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {\n        return merge(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 1.1.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens an Array of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.io.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers in the Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);\n    }\n\n    \/**\n     * Flattens four Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true);\n    }\n\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return mergeDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 2.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Flowable, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged Publishers\n     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from\n     * propagating that error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if both merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the two source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged\n     * Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain\n     * from propagating that error notification until all of the merged Publishers have finished emitting\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);\n    }\n\n\n    \/**\n     * Flattens four Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any of\n     * the merged Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}\n     * will refrain from propagating that error notification until all of the merged Publishers have finished\n     * emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);\n    }\n\n    \/**\n     * Returns a Flowable that never sends any items or notifications to a {@link Subscriber}.\n     * <p>\n     * <img width=\"640\" height=\"185\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/never.png\" alt=\"\">\n     * <p>\n     * This Publisher is useful primarily for testing purposes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code never} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of items (not) emitted by the Publisher\n     * @return a Flowable that never emits any items or sends any notifications to a {@link Subscriber}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Never<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> never() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Integers within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code range} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Integer in the sequence\n     * @param count\n     *            the number of sequential Integers to generate\n     * @return a Flowable that emits a range of sequential Integers\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Integer.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Integer> range(int start, int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return empty();\n        } else\n        if (count == 1) {\n            return just(start);\n        } else\n        if ((long)start + (count - 1) > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Integer overflow\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRange(start, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Longs within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Long in the sequence\n     * @param count\n     *            the number of sequential Longs to generate\n     * @return a Flowable that emits a range of sequential Longs\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Long.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Long> rangeLong(long start, long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0) {\n            return empty();\n        }\n\n        if (count == 1) {\n            return just(start);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRangeLong(start, count));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Flowable that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual) {\n        return sequenceEqual(source1, source2, isEqual, bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(isEqual, \"isEqual is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSequenceEqual<T>(source1, source2, isEqual, bufferSize));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param bufferSize\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return switchOnNextDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param prefetch\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single {@code 0L}\n     * @param unit\n     *            time units to use for {@code delay}\n     * @return a Flowable that emits {@code 0L} after a specified delay, and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> timer(long delay, TimeUnit unit) {\n        return timer(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     * completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single 0L\n     * @param unit\n     *            time units to use for {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for scheduling the item\n     * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     *         completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));\n    }\n\n    \/**\n     * Create a Flowable by wrapping a Publisher <em>which has to be implemented according\n     * to the Reactive-Streams specification by handling backpressure and\n     * cancellation correctly; no safeguards are provided by the Flowable itself<\/em>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure and the behavior is determined by the\n     *  provided Publisher implementation.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type emitted\n     * @param onSubscribe the Publisher instance to wrap\n     * @return the new Flowable instance\n     * @throws IllegalArgumentException if {@code onSubscribe} is a subclass of {@code Flowable}; such\n     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}\n     * instead.\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        if (onSubscribe instanceof Flowable) {\n            throw new IllegalArgumentException(\"unsafeCreate(Flowable) should be upgraded\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of on cancellation.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {\n        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of just before\n     * termination if you have set {@code disposeEagerly} to {@code true} and cancellation does not occur\n     * before termination. Otherwise resource disposal will occur on cancellation.  Eager disposal is\n     * particularly appropriate for a synchronous Publisher that reuses resources. {@code disposeAction} will\n     * only be called once per subscription.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @param eager\n     *            if {@code true} then disposal will happen either on cancellation or just before emission of\n     *            a terminal event ({@code onComplete} or {@code onError}).\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier,\n                    Consumer<? super D> resourceDisposer, boolean eager) {\n        ObjectHelper.requireNonNull(resourceSupplier, \"resourceSupplier is null\");\n        ObjectHelper.requireNonNull(sourceSupplier, \"sourceSupplier is null\");\n        ObjectHelper.requireNonNull(resourceDisposer, \"disposer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common value type\n     * @param <R> the zipped result type\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * <i>n<\/i> items emitted, in sequence, by the <i>n<\/i> Publishers emitted by a specified Publisher.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the Publishers emitted\n     * by the source Publisher; the second item emitted by the new Publisher will be the result of the\n     * function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancel the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(just(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the value type of the inner Publishers\n     * @param <R> the zipped result type\n     * @param sources\n     *            a Publisher of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the Publishers emitted by\n     *            {@code ws}, results in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,\n            final Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return fromPublisher(sources).toList().flatMap((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);\n    }\n\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @param bufferSize the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * three items emitted, in sequence, by three other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new\n     * Publisher will be the result of the function applied to the second item emitted by {@code o1}, the\n     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * four items emitted, in sequence, by four other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * five items emitted, in sequence, by five other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and\n     * the first item emitted by {@code o5}; the second item emitted by the new Publisher will be the result of\n     * the function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * six items emitted, in sequence, by six other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * seven items emitted, in sequence, by seven other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * eight items emitted, in sequence, by eight other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * nine items emitted, in sequence, by nine other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <T9> the value type of the ninth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param source9\n     *            a ninth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {\n\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an array of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;\n     * a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param <R> the result type\n     * @param sources\n     *            an array of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper,\n            boolean delayError, int bufferSize, Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     *\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @param <T> the common source value type\n     * @param <R> the zipped result type\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipIterable(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> zipper, boolean delayError,\n            int bufferSize) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError));\n    }\n\n    \/\/ ***************************************************************************************************\n    \/\/ Instance operators\n    \/\/ ***************************************************************************************************\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source\n     * Publisher satisfy a condition.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/all.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code all} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item and returns a Boolean\n     * @return a Single that emits {@code true} if all items emitted by the source Publisher satisfy the\n     *         predicate; otherwise, {@code false}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/all.html\">ReactiveX operators documentation: All<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> all(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAll<T>(this, predicate));\n    }\n\n    \/**\n     * Mirrors the Publisher (current or provided) that first either emits an item or sends a termination\n     * notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher competing to react first. A subscription to this provided Publisher will occur after subscribing\n     *            to the current Publisher.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ambWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return ambArray(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a\n     * specified condition, otherwise {@code false}. <em>Note:<\/em> this always emits {@code false} if the\n     * source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/exists.png\" alt=\"\">\n     * <p>\n     * In Rx.Net this is the {@code any} Subscriber but we renamed it in RxJava to better match Java naming\n     * idioms.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code any} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the condition to test items emitted by the source Publisher\n     * @return a Single that emits a Boolean that indicates whether any item emitted by the source\n     *         Publisher satisfies the {@code predicate}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> any(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAny<T>(this, predicate));\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if it emits no items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the first item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst() {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the first item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst(T defaultItem) {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Invokes a method on each item emitted by this {@code Flowable} and blocks until the Flowable\n     * completes.\n     * <p>\n     * <em>Note:<\/em> This will block even if the underlying Flowable is asynchronous.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.forEach.png\" alt=\"\">\n     * <p>\n     * This is similar to {@link Flowable#subscribe(Subscriber)}, but it blocks. Because it blocks it does not\n     * need the {@link Subscriber#onComplete()} or {@link Subscriber#onError(Throwable)} methods. If the\n     * underlying Flowable terminates with an error, rather than calling {@code onError}, this method will\n     * throw an exception.\n     *\n     * <p>The difference between this method and {@link #subscribe(Consumer)} is that the {@code onNext} action\n     * is executed on the emission thread instead of the current thread.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the {@link Consumer} to invoke for each item emitted by the {@code Flowable}\n     * @throws RuntimeException\n     *             if an error occurs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX documentation: Subscribe<\/a>\n     * @see #subscribe(Consumer)\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingForEach(Consumer<? super T> onNext) {\n        Iterator<T> it = blockingIterable().iterator();\n        while (it.hasNext()) {\n            try {\n                onNext.accept(it.next());\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                ((Disposable)it).dispose();\n                throw ExceptionHelper.wrapOrThrow(e);\n            }\n        }\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable() {\n        return blockingIterable(bufferSize());\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize the number of items to prefetch from the current Flowable\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return new BlockingFlowableIterable<T>(this, bufferSize);\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if this {@code Flowable} emits no items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the last item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast() {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the last item emitted by the {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast(T defaultItem) {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},\n     * waiting if necessary for one to become available.\n     * <p>\n     * If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,\n     * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.\n     * <p>\n     * Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}\n     * event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an Iterable that always returns the latest item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingLatest() {\n        return new BlockingFlowableLatest<T>(this);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that always returns the item most recently emitted by this\n     * {@code Flowable}.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.mostRecent.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialItem\n     *            the initial item that the {@link Iterable} sequence will yield if this\n     *            {@code Flowable} has not yet emitted an item\n     * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}\n     *         has most recently emitted\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingMostRecent(T initialItem) {\n        return new BlockingFlowableMostRecent<T>(this, initialItem);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, then\n     * returns that item.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.next.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} that blocks upon each iteration until this {@code Flowable} emits\n     *         a new item, whereupon the Iterable returns that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingNext() {\n        return new BlockingFlowableNext<T>(this);\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item, otherwise\n     * throw a {@code NoSuchElementException}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the single item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle() {\n        return singleOrError().blockingLast();\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item; if it emits\n     * more than one item, throw an {@code IllegalArgumentException}; if it emits no items, return a default\n     * value.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the single item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle(T defaultItem) {\n        return single(defaultItem).blockingLast();\n    }\n\n    \/**\n     * Returns a {@link Future} representing the single value emitted by this {@code Flowable}.\n     * <p>\n     * If the {@link Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an\n     * {@link java.lang.IllegalArgumentException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}\n     * will receive an {@link java.util.NoSuchElementException}.\n     * <p>\n     * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toBlocking().toFuture()}.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toFuture.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Future} that expects a single item to be emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Future<T> toFuture() {\n        return subscribeWith(new FutureSubscriber<T>());\n    }\n\n    \/**\n     * Runs the source observable to a terminal event, ignoring any values and rethrowing any exception.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe() {\n        FlowableBlockingSubscribe.subscribe(this);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @param onComplete the callback action for the completion event.\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);\n    }\n\n    \/**\n     * Subscribes to the source and calls the Subscriber methods <strong>on the current thread<\/strong>.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The supplied {@code Subscriber} determines how backpressure is applied.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * The cancellation and backpressure is composed through.\n     * @param subscriber the subscriber to forward events and calls to in the current thread\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Subscriber<? super T> subscriber) {\n        FlowableBlockingSubscribe.subscribe(this, subscriber);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count) {\n        return buffer(count, count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count, int skip) {\n        return buffer(count, skip, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {\n        return buffer(count, count, bufferSupplier);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits\n     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {\n        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,\n            Scheduler scheduler, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {\n        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) {\n        return buffer(timespan, unit, Schedulers.computation(), count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {\n        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @param restartTimerOnMaxSize if true the time window is restarted when the max capacity of the current buffer\n     *            is reached\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(\n            long timespan, TimeUnit unit,\n            Scheduler scheduler, int count,\n            Callable<U> bufferSupplier,\n            boolean restartTimerOnMaxSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument and on the specified {@code scheduler}. When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing> Flowable<List<T>> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {\n        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {\n        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param initialCapacity\n     *            the initial capacity of each buffer chunk\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     * @see #buffer(Publisher)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.<T>asCallable());\n\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundaryIndicatorSupplier, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cache() {\n        return cacheWithInitialCapacity(16);\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * <p>\n     * <em>Note:<\/em> The capacity hint is not an upper bound on cache size. For that, consider\n     * {@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.\n     *\n     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher, converted to the specified\n     * type.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output value type cast to\n     * @param clazz\n     *            the target class type that {@code cast} will cast the items emitted by the source Publisher\n     *            into before emitting them from the resulting Publisher\n     * @return a Flowable that emits each item from the source Publisher after converting it to the\n     *         specified type\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> cast(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return map(Functions.castFunction(clazz));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collect} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItemSupplier\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItemSupplier, \"initialItemSupplier is null\");\n        ObjectHelper.requireNonNull(collector, \"collector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCollect<T, U>(this, initialItemSupplier, collector));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collectInto} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItem\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collectInto(final U initialItem, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItem, \"initialItem is null\");\n        return collect(Functions.justCallable(initialItem), collector);\n    }\n\n    \/**\n     * Transform a Publisher by applying a particular Transformer function to it.\n     * <p>\n     * This method operates on the Publisher itself whereas {@link #lift} operates on the Publisher's\n     * Subscribers or Subscribers.\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@link #lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with the backpressure behavior which only depends\n     *  on what kind of {@code Publisher} the transformer returns.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code compose} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the output Publisher\n     * @param composer implements the function that transforms the source Publisher\n     * @return the source Publisher, transformed by the transformer function\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {\n        return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, \"composer is null\")).apply(this));\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMap(mapper, 2);\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapEager(mapper, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean tillTheEnd) {\n        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch\n     *               the number of elements to prefetch from each source Publisher\n     * @param tillTheEnd\n     *               if true, exceptions from the current Flowable and all the inner Publishers are delayed until\n     *               all of them terminate, if false, exception from the current Flowable is delayed until the\n     *               currently running Publisher terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, prefetch));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted from the current Publisher, then the next, one after\n     * the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be concatenated after the current\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> concatWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concat(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether the source Publisher emitted a\n     * specified item.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/contains.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code contains} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to search for in the emissions from the source Publisher\n     * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,\n     *         or {@code false} if the source Publisher completes without emitting that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> contains(final Object item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return any(Functions.equalsWith(item));\n    }\n\n    \/**\n     * Returns a Single that counts the total number of items emitted by the source Publisher and emits\n     * this count as a 64-bit Long.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/longCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code count} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a\n     *         64-bit Long item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/count.html\">ReactiveX operators documentation: Count<\/a>\n     * @see #count()\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Long> count() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCount<T>(this));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by another item within a computed debounce duration.\n     * <p>\n     * <img width=\"640\" height=\"425\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the {@code debounceSelector} to mark\n     *      boundaries.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the debounce value type (ignored)\n     * @param debounceIndicator\n     *            function to retrieve a sequence that indicates the throttle duration for each item\n     * @return a Flowable that omits items emitted by the source Publisher that are followed by another item\n     *         within a computed debounce duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {\n        ObjectHelper.requireNonNull(debounceIndicator, \"debounceIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on\n     * each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the {@link TimeUnit} for the timeout\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires on a specified\n     * Scheduler. The timer resets on each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the unit of time for the specified timeout\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or a specified default item\n     * if the source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defaultIfEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, this operator is guaranteed to honor backpressure from downstream.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as well; if the rule is violated,\n     *  a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the item to emit if the source Publisher emits no items\n     * @return a Flowable that emits either the specified default item if the source Publisher emits no\n     *         items, or the items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defaultifempty.html\">ReactiveX operators documentation: DefaultIfEmpty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> defaultIfEmpty(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"item is null\");\n        return switchIfEmpty(just(defaultItem));\n    }\n\n    \/**\n     * Returns a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     * per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.o.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the function are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the item delay value type (ignored)\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     *         per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelayIndicator) {\n        ObjectHelper.requireNonNull(itemDelayIndicator, \"itemDelayIndicator is null\");\n        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit) {\n        return delay(delay, unit, Schedulers.computation(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {\n        return delay(delay, unit, Schedulers.computation(), delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delay(delay, unit, scheduler, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelay<T>(this, Math.max(0L, delay), unit, scheduler, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to and emissions from the source Publisher via another\n     * Publisher on a per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.oo.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the functions are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the subscription delay value type (ignored)\n     * @param <V>\n     *            the item delay value type (ignored)\n     * @param subscriptionIndicator\n     *            a function that returns a Publisher that triggers the subscription to the source Publisher\n     *            once it emits any item\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the subscription and emissions of the source Publisher via another\n     *         Publisher on a per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,\n            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {\n        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to this Publisher\n     * until the other Publisher emits an element or completes normally.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator forwards the backpressure requests to this Publisher once\n     *  the subscription happens and requests Long.MAX_VALUE from the other Publisher<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the value type of the other Publisher, irrelevant\n     * @param subscriptionIndicator the other Publisher that should trigger the subscription\n     *        to this Publisher.\n     * @return a Flowable that delays the subscription to this Publisher\n     *         until the other Publisher emits an element or completes normally.\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delaySubscription(Publisher<U> subscriptionIndicator) {\n        ObjectHelper.requireNonNull(subscriptionIndicator, \"subscriptionIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, subscriptionIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @return a Flowable that delays the subscription to the source Publisher by the given amount\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit) {\n        return delaySubscription(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time,\n     * both waiting and subscribing on a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the Scheduler on which the waiting and subscription will happen\n     * @return a Flowable that delays the subscription to the source Publisher by a given\n     *         amount, waiting and subscribing on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delaySubscription(timer(delay, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the\n     * {@link Notification} objects emitted by the source Publisher into the items or notifications they\n     * represent.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/dematerialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code dematerialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T2> the output value type\n     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Dematerialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T2> Flowable<T2> dematerialize() {\n        @SuppressWarnings(\"unchecked\")\n        Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDematerialize<T2>(m));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits only those items emitted by the source Publisher that are distinct from\n     *         each other\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinct() {\n        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {\n        return distinct(keySelector, Functions.<K>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @param collectionSupplier\n     *            function called for each individual Subscriber to return a Collection subtype for holding the extracted\n     *            keys and whose add() method's return indicates uniqueness.\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,\n            Callable<? extends Collection<? super K>> collectionSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged() {\n        return distinctUntilChanged(Functions.identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors, according to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items from the source Publisher whose keys are distinct from\n     *         those of their immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors when compared with each other via the provided comparator function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparer the function that receives the previous item and the current item and is\n     *                   expected to return true if the two are equal, thus skipping the current value.\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {\n        ObjectHelper.requireNonNull(comparer, \"comparer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));\n    }\n\n    \/**\n     * Calls the specified action after this Flowable signals onError or onCompleted or gets cancelled by\n     * the downstream.\n     * <p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action\n     * is executed once per subscription.\n     * <p>Note that the {@code onFinally} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onFinally the action called when this Flowable terminates or gets cancelled\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doFinally(Action onFinally) {\n        ObjectHelper.requireNonNull(onFinally, \"onFinally is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));\n    }\n\n    \/**\n     * Calls the specified consumer with the current item after this item has been emitted to the downstream.\n     * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onAfterNext the Consumer that will be called after emitting an item from upstream to the downstream\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {\n        ObjectHelper.requireNonNull(onAfterNext, \"onAfterNext is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));\n    }\n\n    \/**\n     * Registers an {@link Action} to be called when this Publisher invokes either\n     * {@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/finallyDo.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onAfterTerminate\n     *            an {@link Action} to be invoked when the source Publisher finishes\n     * @return a Flowable that emits the same items as the source Publisher, then invokes the\n     *         {@link Action}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doOnTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, onAfterTerminate);\n    }\n\n    \/**\n     * Calls the cancel {@code Action} if the downstream cancels the sequence.\n     * <p>\n     * The action is shared between subscriptions and thus may be called concurrently from multiple\n     * threads; the action must be thread safe.\n     * <p>\n     * If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,\n     * sometimes as a {@code CompositeException} if there were multiple exceptions along the way.\n     * <p>\n     * Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnUnsubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure\n     *  behavior is preserved between its upstream and its downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onCancel\n     *            the action that gets called when the source {@code Publisher}'s Subscription is cancelled\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnCancel(Action onCancel) {\n        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnComplete.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onComplete\n     *            the action to invoke when the source Publisher calls {@code onComplete}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnComplete(Action onComplete) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                onComplete, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same type\n     * passes through, before forwarding them to downstream.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Action onAfterTerminate) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action for each item it emits.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNotification\n     *            the action to invoke for each item emitted by the source Publisher\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {\n        ObjectHelper.requireNonNull(onNotification, \"consumer is null\");\n        return doOnEach(\n                Functions.notificationOnNext(onNotification),\n                Functions.notificationOnError(onNotification),\n                Functions.notificationOnComplete(onNotification),\n                Functions.EMPTY_ACTION\n            );\n    }\n\n    \/**\n     * Modifies the source Publisher so that it notifies a Subscriber for each item and terminal event it emits.\n     * <p>\n     * In case the {@code onError} of the supplied Subscriber throws, the downstream will receive a composite\n     * exception containing the original exception and the exception thrown by {@code onError}. If either the\n     * {@code onNext} or the {@code onComplete} method of the supplied Subscriber throws, the downstream will be\n     * terminated and will receive this thrown exception.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param subscriber\n     *            the Subscriber to be notified about onNext, onError and onComplete events on its\n     *            respective methods before the actual downstream Subscriber gets notified.\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {\n        ObjectHelper.requireNonNull(subscriber, \"subscriber is null\");\n        return doOnEach(\n                FlowableInternalHelper.subscriberOnNext(subscriber),\n                FlowableInternalHelper.subscriberOnError(subscriber),\n                FlowableInternalHelper.subscriberOnComplete(subscriber),\n                Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action if it calls {@code onError}.\n     * <p>\n     * In case the {@code onError} action throws, the downstream will receive a composite exception containing\n     * the original exception and the exception thrown by {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onError\n     *            the action to invoke if the source Publisher calls {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {\n        return doOnEach(Functions.emptyConsumer(), onError,\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of\n     * the sequence (subscription, cancellation, requesting).\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *              a Consumer called with the Subscription sent via Subscriber.onSubscribe()\n     * @param onRequest\n     *              a LongConsumer called with the request amount sent via Subscription.request()\n     * @param onCancel\n     *              called when the downstream cancels the Subscription via cancel()\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,\n            final LongConsumer onRequest, final Action onCancel) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");\n        ObjectHelper.requireNonNull(onCancel, \"onCancel is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onNext}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the action to invoke when the source Publisher calls {@code onNext}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {\n        return doOnEach(onNext, Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it receives a\n     * request for more items.\n     * <p>\n     * <b>Note:<\/b> This operator is for tracing the internal behavior of back-pressure request\n     * patterns and generally intended for debugging use.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     * <dt><b>Scheduler:<\/b><\/dt>\n     * <dd>{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onRequest\n     *            the action that gets called when a Subscriber requests items from this\n     *            {@code Publisher}\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators\n     *      documentation: Do<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnRequest(LongConsumer onRequest) {\n        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from\n     * its subscribers. Each subscription will result in an invocation of the given action except when the\n     * source {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke\n     * the given action for the first subscription.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnSubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *            the Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}\n     * @return the source {@code Publisher} modified so as to call this Consumer when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {\n        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete} or\n     * {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnTerminate.png\" alt=\"\">\n     * <p>\n     * This differs from {@code doAfterTerminate} in that this happens <em>before<\/em> the {@code onComplete} or\n     * {@code onError} notification.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onTerminate\n     *            the action to invoke when the source Publisher calls {@code onComplete} or {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doAfterTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnTerminate(final Action onTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),\n                onTerminate, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from\n     * this Flowable or completes if this Flowable sequence has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Maybe that emits a single item: the item at the specified position in the sequence of\n     *         those emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable, or a default item if that index is out of range.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @param defaultItem\n     *            the default item\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index, T defaultItem) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable or signals a {@link NoSuchElementException} if this Flowable has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAtOrError(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, true));\n    }\n\n    \/**\n     * Filters items emitted by a Publisher by only emitting those that satisfy a specified predicate.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/filter.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code filter} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates each item emitted by the source Publisher, returning {@code true}\n     *            if it passes the filter\n     * @return a Flowable that emits only those items emitted by the source Publisher that the filter\n     *         evaluates as {@code true}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFilter<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Maybe that emits only the very first item emitted by this Flowable or\n     * completes if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstElement.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstElement() {\n        return elementAt(0);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable, or a default\n     * item if this Flowable completes without emitting anything.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/first.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code first} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher doesn't emit anything\n     * @return a Single that emits only the very first item from the source, or a default item if the\n     *         source Publisher completes without emitting any items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> first(T defaultItem) {\n        return elementAt(0, defaultItem);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable or\n     * signals a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstOrError() {\n        return elementAtOrError(0);\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return flatMap(mapper, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {\n        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {\n        return flatMap(mapper, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from each inner Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items,\n     * while limiting the maximum number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier,\n            int maxConcurrency) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(\n                this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        return flatMap(mapper, combiner, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     * <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner functions\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors) {\n        return flatMap(mapper, combiner, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, combiner, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from the inner Publishers.\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {\n        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return flatMapIterable(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of applying a function to the pair of values from the source\n     * Publisher and an Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and the source {@code Publisher}s is\n     *  consumed in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the collection element type\n     * @param <V>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for each item emitted by the source\n     *            Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @return a Flowable that emits the items returned by {@code resultSelector} for each item in the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the element type of the inner Iterable sequences\n     * @param <V>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element.\n     * <p>\n     * Alias to {@link #subscribe(Consumer)}\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Consumer} to execute for each item.\n     * @return\n     *            a Disposable that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEach(Consumer<? super T> onNext) {\n        return subscribe(onNext);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element until the\n     * onNext Predicate returns false.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext) {\n        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and error events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {\n        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and the terminal events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @param onComplete\n     *            {@link Action} to execute when completion is signalled.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,\n            final Action onComplete) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n\n        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);\n        subscribe(s);\n        return s;\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {\n        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {\n        return groupBy(keySelector, Functions.<T>identity(), delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector) {\n        return groupBy(keySelector, valueSelector, false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector, boolean delayError) {\n        return groupBy(keySelector, valueSelector, delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @param bufferSize\n     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that correlates two Publishers when they overlap in time and groups the results.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupJoin.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupJoin} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the other Publisher to correlate items from the source Publisher with\n     * @param leftEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the source Publisher\n     * @param rightEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the {@code right} Publisher\n     * @param resultSelector\n     *            a function that takes an item emitted by each Publisher and returns the value to be emitted\n     *            by the resulting Publisher\n     * @return a Flowable that emits items based on combining those items emitted by the source Publishers\n     *         whose durations overlap\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n    \/**\n     * Hides the identity of this Flowable and its Subscription.\n     * <p>Allows hiding extra features such as {@link Processor}'s\n     * {@link Subscriber} methods or preventing certain identity-based\n     * optimizations (fusion).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure, the behavior is determined by the upstream's\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     *\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> hide() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableHide<T>(this));\n    }\n\n    \/**\n     * Ignores all items emitted by the source Publisher and only calls {@code onComplete} or {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ignoreElements.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator ignores backpressure as it doesn't emit any elements and consumes the source {@code Publisher}\n     *  in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is\n     *         called by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/ignoreelements.html\">ReactiveX operators documentation: IgnoreElements<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ignoreElements() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if the source Publisher is empty, otherwise {@code false}.\n     * <p>\n     * In Rx.Net this is negated as the {@code any} Subscriber but we renamed this in RxJava to better match Java\n     * naming idioms.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/isEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code isEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits a Boolean\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> isEmpty() {\n        return all(Functions.alwaysFalse());\n    }\n\n    \/**\n     * Correlates the items emitted by two Publishers based on overlapping durations.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/join_.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code join} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the second Publisher to join items from\n     * @param leftEnd\n     *            a function to select a duration for each item emitted by the source Publisher, used to\n     *            determine overlap\n     * @param rightEnd\n     *            a function to select a duration for each item emitted by the {@code right} Publisher, used to\n     *            determine overlap\n     * @param resultSelector\n     *            a function that computes an item to be emitted by the resulting Publisher for any two\n     *            overlapping items emitted by the two Publishers\n     * @return a Flowable that emits items correlating to items emitted by the source Publishers that have\n     *         overlapping durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n\n    \/**\n     * Returns a Maybe that emits the last item emitted by this Flowable or completes if\n     * this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable, or a default item\n     * if this Flowable completes without emitting any items.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code last} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher is empty\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> last(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable or signals\n     * a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"236\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, true));\n    }\n\n    \/**\n     * <strong>This method requires advanced knowledge about building operators; please consider\n     * other standard composition methods first;<\/strong>\n     * Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass\n     * the values of the current Publisher through the Operator function.\n     * <p>\n     * In other words, this allows chaining Subscribers together on a Publisher for acting on the values within\n     * the Publisher.\n     * <p> {@code\n     * Publisher.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()\n     * }\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@code lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The {@code Operator} instance provided is responsible to be backpressure-aware or\n     *  document the fact that the consumer of the returned {@code Publisher} has to apply one of\n     *  the {@code onBackpressureXXX} operators.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output value type\n     * @param lifter the Operator that implements the Publisher-operating function to be applied to the source\n     *             Publisher\n     * @return a Flowable that is the result of applying the lifted Operator to the source Publisher\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {\n        ObjectHelper.requireNonNull(lifter, \"lifter is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLift<R, T>(this, lifter));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified function to each item emitted by the source Publisher and\n     * emits the results of these function applications.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/map.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output type\n     * @param mapper\n     *            a function to apply to each item emitted by the Publisher\n     * @return a Flowable that emits the items from the source Publisher, transformed by the specified\n     *         function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMap<T, R>(this, mapper));\n    }\n\n    \/**\n     * Returns a Flowable that represents all of the emissions <em>and<\/em> notifications from the source\n     * Publisher into emissions marked with their original types within {@link Notification} objects.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/materialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects it from the source {@code Publisher}.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits items that are the result of materializing the items and notifications\n     *         of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Materialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Notification<T>> materialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMaterialize<T>(this));\n    }\n\n    \/**\n     * Flattens this and another Publisher into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code mergeWith} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> mergeWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return merge(this, other);\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of {@link #bufferSize()} slots.\n     *\n     * <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly\n     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler, boolean)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) {\n        return observeOn(scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @param bufferSize the size of the buffer.\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n\n    \/**\n     * Filters the items emitted by a Publisher, only emitting those of the specified type.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ofClass.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output type\n     * @param clazz\n     *            the class type to filter the items emitted by the source Publisher\n     * @return a Flowable that emits items from the source Publisher of type {@code clazz}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> ofType(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return filter(Functions.isInstanceOf(clazz)).cast(clazz);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer() {\n        return onBackpressureBuffer(bufferSize(), false, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(boolean delayError) {\n        return onBackpressureBuffer(bufferSize(), delayError, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity) {\n        return onBackpressureBuffer(capacity, false, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) {\n        return onBackpressureBuffer(capacity, delayError, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) {\n        ObjectHelper.verifyPositive(capacity, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, Functions.EMPTY_ACTION));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,\n            Action onOverflow) {\n        ObjectHelper.requireNonNull(onOverflow, \"onOverflow is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, onOverflow));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) {\n        return onBackpressureBuffer(capacity, false, false, onOverflow);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will behave as determined\n     * by {@code overflowStrategy} if the buffer capacity is exceeded.\n     *\n     * <ul>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR} (default) will {@code onError} dropping all undelivered items,\n     *     cancelling the source, and notifying the producer with {@code onOverflow}. <\/li>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST} will drop any new items emitted by the producer while\n     *     the buffer is full, without generating any {@code onError}.  Each drop will however invoke {@code onOverflow}\n     *     to signal the overflow to the producer.<\/li>j\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST} will drop the oldest items in the buffer in order to make\n     *     room for newly emitted ones. Overflow will not generate an{@code onError}, but each drop will invoke\n     *     {@code onOverflow} to signal the overflow to the producer.<\/li>\n     * <\/ul>\n     *\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @param overflowStrategy how should the {@code Publisher} react to buffer overflows.  Null is not allowed.\n     * @return the source {@code Flowable} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {\n        ObjectHelper.requireNonNull(overflowStrategy, \"strategy is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBufferStrategy<T>(this, capacity, onOverflow, overflowStrategy));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {\n        ObjectHelper.requireNonNull(onDrop, \"onDrop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to\n     * hold onto the latest value and emit that on request.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.latest.png\" alt=\"\">\n     * <p>\n     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that\n     * the downstream is not blocking while requesting more values.\n     * <p>\n     * Note that if the upstream Publisher does support backpressure, this operator ignores that capability\n     * and doesn't propagate any backpressure requests from downstream.\n     * <p>\n     * Note that due to the nature of how backpressure requests are propagated through subscribeOn\/observeOn,\n     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified so that it emits the most recently-received item upon request\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureLatest() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureLatest<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass a function that returns a Publisher ({@code resumeFunction}) to\n     * {@code onErrorResumeNext}, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to the Publisher returned from\n     * {@code resumeFunction}, which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an error happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  a {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param resumeFunction\n     *            a function that returns a Publisher that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {\n        ObjectHelper.requireNonNull(resumeFunction, \"resumeFunction is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onErrorResumeNext} method, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which\n     * will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,\n     * because no Publisher necessarily invokes {@code onError}, the Subscriber may never know that an error\n     * happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher source that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return onErrorResumeNext(Functions.justFunction(next));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param valueSupplier\n     *            a function that returns a single value that will be emitted along with a regular onComplete in case\n     *            the current Flowable signals an onError event\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {\n        ObjectHelper.requireNonNull(valueSupplier, \"valueSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorReturn<T>(this, valueSupplier));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the value that is emitted along with a regular onComplete in case the current\n     *            Flowable signals an exception\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturnItem(final T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return onErrorReturn(Functions.justFunction(item));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an {@link java.lang.Exception}.\n     * <p>\n     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}\n     * or {@link java.lang.Error} but lets those continue through.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onExceptionResumeNextViaPublisher.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an exception that prevents it from emitting the expected item\n     * to its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onExceptionResumeNext} method changes\n     * this behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onExceptionResumeNext} method, if the original Publisher encounters an exception, instead of\n     * invoking its Subscriber's {@code onError} method, it will instead relinquish control to\n     * {@code resumeSequence} which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an exception happened.\n     * <p>\n     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher that will take over if the source Publisher encounters\n     *            an exception\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, Functions.justFunction(next), true));\n    }\n\n    \/**\n     * Nulls out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Flowable which out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onTerminateDetach() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDetach<T>(this));\n    }\n\n    \/**\n     * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel() {\n        return ParallelFlowable.from(this);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        return ParallelFlowable.from(this, parallelism);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion and\n     * uses the defined per-'rail' prefetch amount.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @param prefetch the number of items each 'rail' should prefetch\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism, int prefetch) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return ParallelFlowable.from(this, parallelism, prefetch);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish() {\n        return publish(bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        return publish(selector, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<? extends R>> selector, int prefetch) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowablePublishMulticast<T, R>(this, selector, prefetch, false));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowablePublish.create(this, bufferSize);\n    }\n\n    \/**\n     * Requests {@code n} initially from the upstream and then 75% of {@code n} subsequently\n     * after 75% of {@code n} values have been emitted to the downstream.\n     *\n     * <p>This operator allows preventing the downstream to trigger unbounded mode via {@code request(Long.MAX_VALUE)}\n     * or compensate for the per-item overhead of small and frequent requests.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects backpressure from upstream and honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param n the initial request amount, further request will happen after 75% of this value\n     * @return the Publisher that rebatches request amounts from downstream\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> rebatchRequests(int n) {\n        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);\n    }\n\n    \/**\n     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * and emits the final result from the final call to your function as its sole item.\n     * <p>\n     * If the source is empty, a {@code NoSuchElementException} is signalled.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduce.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be used in the next accumulator call\n     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by\n     *         the source Flowable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduce<T>(this, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seed\n     *            the initial (seed) accumulator value\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seed, \"seed is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceSeed<T, R>(this, seed, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduceWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seedSupplier\n     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceWith<T, R>(this, seedSupplier, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher indefinitely.\n     * <p>\n     * <img width=\"640\" height=\"309\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher repeatedly and in sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat() {\n        return repeat(Long.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     * {@code count} times.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param times\n     *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty\n     *            sequence\n     * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     *         {@code count} times\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat(long times) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        if (times == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeat<T>(this, times));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher until\n     * the provided stop function returns true.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stop\n     *                a boolean supplier that is called when the current Flowable completes and unless it returns\n     *                false, the current Flowable is resubscribed\n     * @return the new Flowable instance\n     * @throws NullPointerException\n     *             if {@code stop} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatUntil(BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatUntil<T>(this, stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of\n     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will\n     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeatWhen.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.\n     * @return the source Publisher modified with repeat logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatWhen<T>(this, handler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher\n     * that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its\n     *         items to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay() {\n        return FlowableReplay.createFrom(this);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on the items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @return a Flowable that emits items that are the results of invoking the selector on a\n     *         {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying {@code bufferSize} notifications.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     *         replaying no more than {@code bufferSize} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {\n        return replay(selector, bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(\n                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying a maximum of {@code bufferSize} items.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param scheduler\n     *            the Scheduler on which the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying no more than {@code bufferSize} notifications\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),\n                FlowableInternalHelper.replayFunction(selector, scheduler)\n        );\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"435\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ft.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {\n        return replay(selector, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fs.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param scheduler\n     *            the Scheduler where the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),\n                FlowableInternalHelper.replayFunction(selector, scheduler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items emitted by that Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay(final int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {\n        return replay(bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A\n     * Connectable Publisher resembles an ordinary Publisher, except that it does not begin emitting items\n     * when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is used as a time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param scheduler\n     *            the scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted by the Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(bufferSize), scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(long time, TimeUnit unit) {\n        return replay(time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.create(this, time, unit, scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * will replay all of its items and notifications to any future {@link Subscriber} on the given\n     * {@link Scheduler}. A Connectable Publisher resembles an ordinary Publisher, except that it does not\n     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the Scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     *         will replay all of its items and notifications to any future {@link Subscriber} on the given\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(), scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * (infinite retry count).\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher rather than propagating the {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry() {\n        return retry(Long.MAX_VALUE, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * and the predicate returns true for that specific exception and retry count.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the predicate that determines if a resubscription may happen in case of a specific exception\n     *            and retry count\n     * @return the source Publisher modified with retry logic\n     * @see #retry()\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryBiPredicate<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * up to a specified number of retries.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher for a maximum of {@code count} resubscriptions rather than propagating the\n     * {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of retry attempts before failing\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long count) {\n        return retry(count, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Retries at most times or until the predicate returns false, whichever happens first.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param times the number of times to repeat\n     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate));\n    }\n\n    \/**\n     * Retries the current Flowable if the predicate returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {\n        return retry(Long.MAX_VALUE, predicate);\n    }\n\n    \/**\n     * Retries until the given stop function returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param stop the function that should return true to stop retrying\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryUntil(final BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onError}. An {@code onError} notification from the source will result in the emission of a\n     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call\n     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retryWhen.f.png\" alt=\"\">\n     *\n     * Example:\n     *\n     * This retries 3 times, each time incrementing the number of seconds it waits.\n     *\n     * <pre><code>\n     *  Publisher.create((Subscriber<? super String> s) -> {\n     *      System.out.println(\"subscribing\");\n     *      s.onError(new RuntimeException(\"always fails\"));\n     *  }).retryWhen(attempts -> {\n     *      return attempts.zipWith(Publisher.range(1, 3), (n, i) -> i).flatMap(i -> {\n     *          System.out.println(\"delay retry by \" + i + \" second(s)\");\n     *          return Publisher.timer(i, TimeUnit.SECONDS);\n     *      });\n     *  }).blockingForEach(System.out::println);\n     * <\/code><\/pre>\n     *\n     * Output is:\n     *\n     * <pre> {@code\n     * subscribing\n     * delay retry by 1 second(s)\n     * subscribing\n     * delay retry by 2 second(s)\n     * subscribing\n     * delay retry by 3 second(s)\n     * subscribing\n     * } <\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the\n     *            retry\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryWhen(\n            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryWhen<T>(this, handler));\n    }\n\n    \/**\n     * Subscribes to the current Flowable and wraps the given Subscriber into a SafeSubscriber\n     * (if not already a SafeSubscriber) that\n     * deals with exceptions thrown by a misbehaving Subscriber (that doesn't follow the\n     * Reactive-Streams specification).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>This operator leaves the reactive world and the backpressure behavior depends on the Subscriber's behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the incoming Subscriber instance\n     * @throws NullPointerException if s is null\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void safeSubscribe(Subscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        if (s instanceof SafeSubscriber) {\n            subscribe((SafeSubscriber<? super T>)s);\n        } else {\n            subscribe(new SafeSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> sample(long period, TimeUnit unit) {\n        return sample(period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) {\n        return sample(period, unit, Schedulers.computation(), emitLast);\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler\n     * and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.nolast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> sample(Publisher<U> sampler) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher\n     * and optionally emit the very last upstream item when the upstream or other Publisher complete.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final <U> Flowable<T> sample(Publisher<U> sampler, boolean emitLast) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scan.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits the results of each call to the accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> scan(BiFunction<T, T, T> accumulator) {\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScan<T>(this, accumulator));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param initialValue\n     *            the initial (seed) accumulator item\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(initialValue, \"seed is null\");\n        return scanWith(Functions.justCallable(initialValue), accumulator);\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <p>\n     * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scanWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param seedSupplier\n     *            a Callable that returns the initial (seed) accumulator item for each individual Subscriber\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));\n    }\n\n    \/**\n     * Forces a Publisher's emissions and notifications to be serialized and for it to obey\n     * <a href=\"http:\/\/reactivex.io\/documentation\/contract.html\">the Publisher contract<\/a> in other ways.\n     * <p>\n     * It is possible for a Publisher to invoke its Subscribers' methods asynchronously, perhaps from\n     * different threads. This could make such a Publisher poorly-behaved, in that it might try to invoke\n     * {@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call\n     * {@code onNext} from two different threads concurrently. You can force such a Publisher to be\n     * well-behaved and sequential by applying the {@code serialize} method to it.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/synchronize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code serialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Publisher} that is guaranteed to be well-behaved and to make only serialized calls to\n     *         its Subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/serialize.html\">ReactiveX operators documentation: Serialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> serialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSerialized<T>(this));\n    }\n\n    \/**\n     * Returns a new {@link Publisher} that multicasts (shares) the original {@link Publisher}. As long as\n     * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.\n     * When all subscribers have cancelled it will cancel the source {@link Publisher}.\n     * <p>\n     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount()}.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishRefCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure and and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator will signal a {@code MissingBackpressureException} to\n     *  its {@code Subscriber}s.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code share} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@code Publisher} that upon connection causes the source {@code Publisher} to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/refcount.html\">ReactiveX operators documentation: RefCount<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> share() {\n        return publish().refCount();\n    }\n\n    \/**\n     * Returns a Maybe that completes if this Flowable is empty, signals one item if this Flowable\n     * signals exactly one item or signals an {@code IllegalArgumentException} if this Flowable signals\n     * more than one item.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Maybe that emits the single item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher\n     * emits only a single item, or a default item if the source Publisher emits no items. If the source\n     * Publisher emits more than one item, an {@code IllegalArgumentException} is signalled instead.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code single} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to emit if the source Publisher emits no item\n     * @return a Single that emits the single item emitted by the source Publisher, or a default item if\n     *         the source Publisher is empty\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> single(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by this Flowable, if this Flowable\n     * emits only a single item, otherwise\n     * if this Flowable completes without emitting any items a {@link NoSuchElementException} will be signalled and\n     * if this Flowable emits more than one item, an {@code IllegalArgumentException} will be signalled.\n     * <p>\n     * <img width=\"640\" height=\"205\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, true));\n    }\n\n    \/**\n     * Returns a Flowable that skips the first {@code count} items emitted by the source Publisher and emits\n     * the remainder.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the number of items to skip\n     * @return a Flowable that is identical to the source Publisher except that it does not emit the first\n     *         {@code count} items that the source Publisher emits\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long count) {\n        if (count <= 0L) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkip<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skip} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} elapses and the emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long time, TimeUnit unit) {\n        return skipUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * on a specified {@link Scheduler} elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for the timed skipping<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} on which the timed wait happens\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that drops a specified number of items from the end of the sequence emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.png\" alt=\"\">\n     * <p>\n     * This Subscriber accumulates a queue long enough to store the first {@code count} items. As more items are\n     * received, items are taken from the front of the queue and emitted by the returned Publisher. This causes\n     * such items to be delayed.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of items to drop from the end of the source sequence\n     * @return a Flowable that emits the items emitted by the source Publisher except for the dropped ones\n     *         at the end\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit) {\n        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) {\n        return skipLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use to track the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return skipLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be skipped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        \/\/ the internal buffer holds pairs of (timestamp, value) so double the default buffer size\n        int s = bufferSize << 1;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that skips items emitted by the source Publisher until a second Publisher emits\n     * an item.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param other\n     *            the second Publisher that has to emit an item before the source Publisher's elements begin\n     *            to be mirrored by the resulting Publisher\n     * @return a Flowable that skips items from the source Publisher until the second Publisher emits an\n     *         item, then emits the remaining items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipuntil.html\">ReactiveX operators documentation: SkipUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> skipUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that skips all items emitted by the source Publisher as long as a specified\n     * condition holds true, but emits all further source items as soon as the condition becomes false.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function to test each item emitted from the source Publisher\n     * @return a Flowable that begins emitting items emitted by the source Publisher when the specified\n     *         predicate becomes false\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipwhile.html\">ReactiveX operators documentation: SkipWhile<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));\n    }\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted() {\n        return toList().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order based on a specified comparison function.\n     *\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param sortFunction\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Iterable} before it begins to emit items\n     * emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            an Iterable that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Iterable<? extends T> items) {\n        return concatArray(fromIterable(items), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Publisher} before it begins to emit\n     * items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Publisher} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concatArray(other, this);\n    }\n\n    \/**\n     * Returns a Flowable that emits a specified item before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param value\n     *            the item to emit first\n     * @return a Flowable that emits the specified item before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(T value) {\n        ObjectHelper.requireNonNull(value, \"item is null\");\n        return concatArray(just(value), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the specified items before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWithArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of values to emit first\n     * @return a Flowable that emits the specified items before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWithArray(T... items) {\n        Flowable<T> fromArray = fromArray(items);\n        if (fromArray == empty()) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return concatArray(fromArray, this);\n    }\n\n    \/**\n     * Ensures that the event flow between the upstream and downstream follow\n     * the Reactive-Streams 1.0 specification by honoring the 3 additional rules\n     * (which are omitted in standard operators due to performance reasons).\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns<\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel<\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException)<\/li>\n     * <\/ul>\n     * In addition, if rule \u00a72.12 (onSubscribe must be called at most once) is violated,\n     * the sequence is cancelled an onError(IllegalStateException) is emitted.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code strict} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     * @since 2.0.5 - experimental\n     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    @CheckReturnValue\n    @Deprecated\n    public final Flowable<T> strict() {\n        return this;\n    }\n\n    \/**\n     * Subscribes to a Publisher and ignores {@code onNext} and {@code onComplete} emissions.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe() {\n        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides a callback to handle the items it emits.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext) {\n        return subscribe(onNext, Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error\n     * notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete) {\n        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @param onSubscribe\n     *             the {@code Consumer} that receives the upstream's Subscription\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Consumer<? super Subscription> onSubscribe) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n\n        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);\n\n        subscribe(ls);\n\n        return ls;\n    }\n\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Override\n    public final void subscribe(Subscriber<? super T> s) {\n        if (s instanceof RelaxedSubscriber) {\n            subscribe((RelaxedSubscriber<? super T>)s);\n        } else {\n            ObjectHelper.requireNonNull(s, \"s is null\");\n            subscribe(new StrictSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Establish a connection between this Flowable and the given RelaxedSubscriber and\n     * start streaming events based on the demand of the RelaxedSubscriber.\n     * <p>\n     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n     * <p>\n     * Each {@link Subscription} will work for only a single {@link RelaxedSubscriber}.\n     * <p>\n     * If the same {@link RelaxedSubscriber} instance is subscribed to multiple {@link Flowable}s and\/or the\n     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}\n     * methods manually.\n     * <p>\n     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal\n     * the error via {@link RelaxedSubscriber#onError(Throwable)}.\n     * <p>\n     * This subscribe method relaxes the following Reactive-Streams rules:\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns.\n     *     <b>RelaxedSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.<\/b><\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel.\n     *     <b>Calling request() or cancel() is NOP at this point.<\/b><\/li>\n     * <li>\u00a72.12: onSubscribe must be called at most once on the same instance.\n     *     <b>RelaxedSubscriber reuse is not checked and if happens, it is the responsibility of\n     *     the RelaxedSubscriber to ensure proper serialization of its onXXX methods.<\/b><\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException).\n     *     <b>Non-positive requests signal via RxJavaFlowablePlugins.onError and the stream is not affected.<\/b><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code RelaxedSubscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the RelaxedSubscriber that will consume signals from this Flowable\n     * @since 2.0.7 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final void subscribe(RelaxedSubscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        try {\n            Subscriber<? super T> z = RxJavaFlowablePlugins.onSubscribe(this, s);\n\n            ObjectHelper.requireNonNull(z, \"Plugin returned null Subscriber\");\n\n            subscribeActual(z);\n        } catch (NullPointerException e) { \/\/ NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            \/\/ can't call onError because no way to know if a Subscription has been set or not\n            \/\/ can't call onSubscribe because the call might have set a Subscription already\n            RxJavaCommonPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n\n    \/**\n     * Operator implementations (both source and intermediate) should implement this method that\n     * performs the necessary business logic.\n     * <p>There is no need to call any of the plugin hooks on the current Flowable instance or\n     * the Subscriber.\n     * @param s the incoming Subscriber, never null\n     *\/\n    protected abstract void subscribeActual(Subscriber<? super T> s);\n\n    \/**\n     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given\n     * Subscriber as is.\n     * <p>Usage example:\n     * <pre><code>\n     * Flowable&lt;Integer> source = Flowable.range(1, 10);\n     * CompositeDisposable composite = new CompositeDisposable();\n     *\n     * ResourceSubscriber&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n     *     \/\/ ...\n     * };\n     *\n     * composite.add(source.subscribeWith(rs));\n     * <\/code><\/pre>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code Subscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <E> the type of the Subscriber to use and return\n     * @param subscriber the Subscriber (subclass) to use and return, not null\n     * @return the input {@code subscriber}\n     * @throws NullPointerException if {@code subscriber} is null\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n        subscribe(subscriber);\n        return subscriber;\n    }\n\n    \/**\n     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/subscribeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform subscription actions on\n     * @return the source Publisher modified so that its subscriptions happen on the\n     *         specified {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #observeOn\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or the items of an alternate\n     * Publisher if the source Publisher is empty.\n     * <img width=\"640\" height=\"255\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchifempty.png\" alt=\"\">\n     * <p\/>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, the alternate {@code Publisher} is expected to honor backpressure.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as instead.\n     *  In either case, if violated, a {@code MissingBackpressureException} <em>may<\/em> get\n     *  signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *              the alternate Publisher to subscribe to if the source does not emit any items\n     * @return  a Publisher that emits the items emitted by the source Publisher or the items of an\n     *          alternate Publisher if the source Publisher is empty.\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMap(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, false);\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMapDelayError(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, true);\n    }\n\n    <R> Flowable<R> switchMap0(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize, boolean delayError) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchMap<T, R>(this, mapper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.png\" alt=\"\">\n     * <p>\n     * This method returns a Publisher that will invoke a subscribing {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking\n     * {@link Subscriber#onComplete onComplete}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior in case the first request is smaller than the {@code count}. Otherwise, the source {@code Publisher}\n     *  is consumed in an unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @return a Flowable that emits only the first {@code count} items emitted by the source Publisher, or\n     *         all of the items from the source Publisher if that Publisher emits fewer than {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> take(long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTake<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time runs\n     * out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> take(long time, TimeUnit unit) {\n        return takeUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time (on a\n     * specified Scheduler) runs out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler used for time source\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out,\n     *         according to the specified Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream if the {@code count} is non-zero; ignores\n     *  backpressure if the {@code count} is zero as it doesn't signal any values.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit from the end of the sequence of items emitted by the source\n     *            Publisher\n     * @return a Flowable that emits at most the last {@code count} items emitted by the source Publisher\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n        } else\n        if (count == 1) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastOne<T>(this));\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {\n        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(count, time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit) {\n        return takeLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) {\n        return takeLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return takeLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher, checks the specified predicate\n     * for each item, and then completes when the condition is satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.p.png\" alt=\"\">\n     * <p>\n     * The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition is\n     * evaluated <em>after<\/em> the item is emitted.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstream\n     *  source and the downstream consumer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stopPredicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that first emits items emitted by the source Publisher, checks the specified\n     *         condition after each item, and then completes when the condition is satisfied.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     * @see Flowable#takeWhile(Predicate)\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {\n        ObjectHelper.requireNonNull(stopPredicate, \"stopPredicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher until a second Publisher\n     * emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items\n     *            from the source Publisher\n     * @param <U>\n     *            the type of items emitted by {@code other}\n     * @return a Flowable that emits the items emitted by the source Publisher until such time as {@code other} emits its first item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> takeUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher so long as each item satisfied a\n     * specified condition, and then completes as soon as this condition is not satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that emits the items from the source Publisher so long as each item satisfies the\n     *         condition defined by {@code predicate}, then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\">ReactiveX operators documentation: TakeWhile<\/a>\n     * @see Flowable#takeUntil(Predicate)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param windowDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code windowDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {\n        return throttleFirst(windowDuration, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the windows are managed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param skipDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code skipDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {\n        return sample(intervalDuration, unit);\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the duration is governed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {\n        return sample(intervalDuration, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window, where the time window is governed by a specified\n     * Scheduler.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {\n        return debounce(timeout, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval() {\n        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(Scheduler scheduler) {\n        return timeInterval(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {\n        return timeInterval(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if an item emitted by the source Publisher doesn't arrive within a window of\n     * time after the emission of the previous item, where that period of time is measured by a Publisher that\n     * is a function of the previous item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout3.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source\n     *            Publisher and that determines the timeout window for the subsequent item\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if an item emitted by the source Publisher takes longer to arrive than\n     *         the time window defined by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        return timeout0(null, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but that switches to a fallback Publisher if\n     * an item emitted by the source Publisher doesn't arrive within a window of time after the emission of the\n     * previous item, where that period of time is measured by a Publisher that is a function of the previous\n     * item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout4.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher, for each item emitted by the source Publisher, that\n     *            determines the timeout window for the subsequent item\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to mirroring a fallback Publisher\n     *         if an item emitted by the source Publisher takes longer to arrive than the time window defined\n     *         by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator, Flowable<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(null, itemTimeoutIndicator, other);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher terminates and notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between emitted items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument.\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {\n        return timeout0(timeout, timeUnit, null, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param other\n     *            the fallback Publisher to use in case of a timeout\n     * @return the source Publisher modified to switch to the fallback Publisher in case of a timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration\n     * starting from its predecessor, the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to run the timeout timers on\n     * @param other\n     *            the Publisher to use as the fallback in case of a timeout\n     * @return the source Publisher modified so that it will switch to the fallback Publisher in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the\n     * specified timeout duration starting from its predecessor, the resulting Publisher terminates and\n     * notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the Scheduler to run the timeout timers on\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {\n        return timeout0(timeout, timeUnit, null, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if either the first item emitted by the source Publisher or any subsequent item\n     * doesn't arrive within time windows defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher that determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within\n     *         the time windows specified by the timeout selectors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutIndicator is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but switches to a fallback Publisher if either\n     * the first item emitted by the source Publisher or any subsequent item doesn't arrive within time windows\n     * defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher which determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to the {@code other} Publisher if\n     *         either the first item emitted by the source Publisher or any subsequent item doesn't arrive\n     *         within time windows defined by the timeout selectors\n     * @throws NullPointerException\n     *             if {@code itemTimeoutIndicator} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutSelector is null\");\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, other);\n    }\n\n    private Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,\n            Scheduler scheduler) {\n        ObjectHelper.requireNonNull(timeUnit, \"timeUnit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other));\n    }\n\n    private <U, V> Flowable<T> timeout0(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(itemTimeoutIndicator, \"itemTimeoutIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeout<T, U, V>(this, firstTimeoutIndicator, itemTimeoutIndicator, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp() {\n        return timestamp(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {\n        return timestamp(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp(TimeUnit unit) {\n        return timestamp(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return map(Functions.<T>timestampWith(unit, scheduler));\n    }\n\n    \/**\n     * Calls the specified converter function during assembly time and returns its resulting value.\n     * <p>\n     * This allows fluent conversion to any other type.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The backpressure behavior depends on what happens in the {@code converter} function.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code to} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the resulting object type\n     * @param converter the function that receives the current Flowable instance and returns a value\n     * @return the value returned by the function\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> R to(Function<? super Flowable<T>, R> converter) {\n        try {\n            return ObjectHelper.requireNonNull(converter, \"converter is null\").apply(this);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, ArrayListSupplier.<T>asCallable()));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *         the number of elements expected from the current Flowable\n     * @return a Flowable that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList(final int capacityHint) {\n        ObjectHelper.verifyPositive(capacityHint, \"capacityHint\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the subclass of a collection of Ts\n     * @param collectionSupplier\n     *               the Callable returning the collection (for each individual Subscriber) to be filled in\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> toList(Callable<U> collectionSupplier) {\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, U>(this, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing all items emitted by the source Publisher,\n     * mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return collect(HashMapSupplier.<K, T>asCallable(), Functions.toMapKeySelector(keySelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing values corresponding to items emitted by the\n     * source Publisher, mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain a single entry that\n     * corresponds to the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @param valueSelector\n     *            the function that extracts the value from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(HashMapSupplier.<K, V>asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains keys and values extracted from the items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the Map\n     * @param valueSelector\n     *            the function that extracts the value from the source items to be used as value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Flowable that emits a single item: a Map that contains the mapped items emitted by the\n     *         source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, V>> mapSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of items emitted by the\n     * source Publisher keyed by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from the source items to be used as key in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {\n        Function<T, T> valueSelector = Functions.identity();\n        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of values extracted by a\n     * specified {@code valueSelector} function from items emitted by the source Publisher, keyed by a\n     * specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as key in the HashMap\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as value in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {\n        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from\n     * items emitted by the source Publisher, and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @param collectionFactory\n     *            the function that returns a Collection instance for a particular key to be used in the Map\n     * @return a Single that emits a single item: a Map that contains the collection of mapped items from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, Collection<V>>> mapSupplier,\n            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.requireNonNull(mapSupplier, \"mapSupplier is null\");\n        ObjectHelper.requireNonNull(collectionFactory, \"collectionFactory is null\");\n        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items\n     * emitted by the source Publisher and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Single that emits a single item: a Map that contains a list items mapped from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            Callable<Map<K, Collection<V>>> mapSupplier\n            ) {\n        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList() {\n        return toSortedList(Functions.naturalComparator());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList().map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList(capacityHint).map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Flowable that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Flowable that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(int capacityHint) {\n        return toSortedList(Functions.naturalComparator(), capacityHint);\n    }\n\n    \/**\n     * Modifies the source Publisher so that subscribers will cancel it on a specified\n     * {@link Scheduler}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform cancellation actions on\n     * @return the source Publisher modified so that its cancellations happen on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current window and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows, each containing at most\n     *         {@code count} items from the source Publisher\n     * @throws IllegalArgumentException if either count is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count) {\n        return window(count, count, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip) {\n        return window(count, skip, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {\n        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return window(timespan, timeskip, unit, scheduler, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.verifyPositive(timespan, \"timespan\");\n        ObjectHelper.verifyPositive(timeskip, \"timeskip\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping windows representing items emitted by the\n     *         source Publisher during fixed, consecutive durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) {\n        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count) {\n        return window(timespan, unit, Schedulers.computation(), count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count, boolean restart) {\n        return window(timespan, unit, Schedulers.computation(), count, restart);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows containing items emitted by the\n     *         source Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler) {\n        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count) {\n        return window(timespan, unit, scheduler, count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count, boolean restart) {\n        return window(timespan, unit, scheduler, count, restart, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(\n            long timespan, TimeUnit unit, Scheduler scheduler,\n            long count, boolean restart, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator) {\n        return window(boundaryIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundaryIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator) {\n        return window(openingIndicator, closingIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return window(boundaryIndicatorSupplier, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));\n    }\n\n    \/**\n     * Merges the specified Publisher into this Publisher sequence by using the {@code resultSelector}\n     * function only when the source Publisher (this instance) emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/withLatestFrom.png\" alt=\"\">\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure: the backpressure support\n     *  depends on the upstream and downstream's backpressure behavior. The other Publisher\n     *  is consumed in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator, by default, doesn't run any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param <R> the result type of the combination\n     * @param other\n     *            the other Publisher\n     * @param combiner\n     *            the function to call when this Publisher emits an item and the other Publisher has already\n     *            emitted an item, to generate the item to be emitted by the resulting Publisher\n     * @return a Flowable that merges the specified Publisher into this Publisher by using the\n     *         {@code resultSelector} function only when the source Publisher sequence (this instance) emits an\n     *         item\n     * @since 2.0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> withLatestFrom(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFrom<T, U, R>(this, combiner, other));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> source1, Publisher<T2> source2,\n            Function3<? super T, ? super T1, ? super T2, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3,\n            Function4<? super T, ? super T1, ? super T2, ? super T3, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <T4> the fourth other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param source4 the fourth other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, T4, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3, Publisher<T4> source4,\n            Function5<? super T, ? super T1, ? super T2, ? super T3, ? super T4, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the array of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Publisher<?>[] others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the iterable of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Iterable<? extends Publisher<?>> others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and a specified Iterable sequence.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.i.png\" alt=\"\">\n     * <p>\n     * Note that the {@code other} Iterable is evaluated as items are observed from the source Publisher; it is\n     * not pre-consumed. This allows you to zip infinite streams on either side.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items in the {@code other} Iterable\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the Iterable sequence\n     * @param zipper\n     *            a function that combines the pairs of items from the Publisher and the Iterable to generate\n     *            the items to be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Iterable\n     *         sequence and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return zip(this, other, zipper);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {\n        return zip(this, other, zipper, delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {\n        return zip(this, other, zipper, delayError, bufferSize);\n    }\n\n    \/\/ -------------------------------------------------------------------------\n    \/\/ Fluent test support, super handy and reduces test preparation boilerplate\n    \/\/ -------------------------------------------------------------------------\n    \/**\n     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber consumes this Flowable in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test() { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>();\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount,\n     * optionally cancels it before the subscription and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @param cancel should the TestSubscriber be cancelled before the subscription?\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest, boolean cancel) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        if (cancel) {\n            ts.cancel();\n        }\n        subscribe(ts);\n        return ts;\n    }\n\n}\n","subject":"","message":"Changed minimum value of rx2.buffer-size to 1\n\nBefore the minimum value you could set with the system variable `rx2.buffer-size` was 16. With this commit, that is changed to 1.\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"85557ce424bfb2a4f98c0e68198fb557e17ebbf4","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"3d04b8095f2e7c9c4f79af5cf7df57bf30289d1e","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"67dd594c348b87d8cd481483dbea6c8e304737e4","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"d363b3cdced473939f3762d727a269d188d40206","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"d363b3cdced473939f3762d727a269d188d40206","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"77c22b424d1d6fda5c29b1e9a81f57bd20abe36f","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"d3876d7dfd93d4a7e19b5f50ea1a76936cf0bc7b","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"f363c641bb3f958dcffd8bf9d77374189c9dbe96","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"f363c641bb3f958dcffd8bf9d77374189c9dbe96","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"a089ee232ceb0f64e202873b018d92688fb49dae","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"79fb179507ab459cc9ce1d9e76a10cb7bf53d661","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"a619699a4a697b65b7806ce0a7630502bbc1466c","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"1020e94463516377bd5cbacbf6393a819db2df88","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"1020e94463516377bd5cbacbf6393a819db2df88","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"abb8abe51c84eed8863df9e5d50496f9462f4490","old_file":"src\/test\/java\/org\/javafunk\/funk\/monads\/EitherTest.java","new_file":"src\/test\/java\/org\/javafunk\/funk\/monads\/EitherTest.java","old_contents":"","new_contents":"package org.javafunk.funk.monads;\n\nimport org.junit.Test;\n\nimport java.util.NoSuchElementException;\n\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.assertThat;\n\npublic class EitherTest {\n    @Test\n    public void shouldBeLeftForLeft(){\n        Either<String, Integer> either = Either.left(\"LEFT\");\n\n        assertThat(either.isLeft(), is(true));\n    }\n\n    @Test\n    public void shouldNotBeRightForLeft(){\n        Either<String, Integer> either = Either.left(\"LEFT\");\n\n        assertThat(either.isRight(), is(false));\n    }\n\n    @Test(expected = NoSuchElementException.class)\n    public void shouldThrowNoSuchElementExceptionOnGetRightForLeft(){\n        Either<String, Integer> either = Either.left(\"LEFT\");\n\n        either.getRight();\n    }\n\n    @Test\n    public void shouldReturnLeftValueForGetLeft(){\n        Either<String, Integer> either = Either.right(1);\n\n        assertThat(either.getRight(), is(1));\n    }\n\n    @Test\n    public void shouldNotBeLeftForRight(){\n        Either<String, Integer> either = Either.right(1);\n\n        assertThat(either.isLeft(), is(false));\n    }\n\n    @Test\n    public void shouldBeRightForRight(){\n        Either<String, Integer> either = Either.right(1);\n\n        assertThat(either.isRight(), is(true));\n    }\n\n    @Test(expected = NoSuchElementException.class)\n    public void shouldThrowNoSuchElementExceptionOnGetLeftForRight(){\n        Either<String, Integer> either = Either.right(1);\n\n        either.getLeft();\n    }\n\n    @Test\n    public void shouldReturnRightValueForGetRight(){\n        Either<String, Integer> either = Either.right(1);\n\n        assertThat(either.getRight(), is(1));\n    }\n}\n","subject":"","message":"Introduced a basic Either monad.\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"64aeb2d4dae7baf9fde4c16f409b7edb0e14ebf8","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"6ccff80b095e689086574ee670d96605cc06ed87","old_file":"src\/test\/java\/org\/javafunk\/funk\/LiteralsTest.java","new_file":"src\/test\/java\/org\/javafunk\/funk\/LiteralsTest.java","old_contents":"\/*\n * Copyright (C) 2011-Present Funk committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\/\npackage org.javafunk.funk;\n\nimport com.google.common.collect.HashMultiset;\nimport com.google.common.collect.Multiset;\nimport org.javafunk.funk.builders.*;\nimport org.javafunk.funk.datastructures.tuples.*;\nimport org.javafunk.funk.testclasses.*;\nimport org.junit.Test;\n\nimport java.util.*;\n\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.is;\nimport static org.javafunk.funk.Literals.*;\nimport static org.javafunk.funk.builders.IterableBuilder.iterableBuilder;\nimport static org.javafunk.funk.matchers.IteratorMatchers.isIteratorWithSameElementsAs;\nimport static org.javafunk.funk.testclasses.Age.age;\nimport static org.javafunk.funk.testclasses.Animal.animal;\nimport static org.javafunk.funk.testclasses.Cat.cat;\nimport static org.javafunk.funk.testclasses.Colour.colour;\nimport static org.javafunk.funk.testclasses.Dog.dog;\nimport static org.javafunk.funk.testclasses.Location.location;\nimport static org.javafunk.funk.testclasses.Name.name;\nimport static org.junit.Assert.fail;\n\npublic class LiteralsTest {\n    @Test public void shouldReturnAnEmptyIterable() throws Exception {\n        \/\/ Given\n        Iterable<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        Iterable<Integer> actual = iterable();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Iterable<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(iterableOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingTheSuppliedElements() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n\n        \/\/ When\n        Iterable<Integer> actual = iterableWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Iterable<Integer> actual = iterableFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Iterable<Integer> actual = iterableFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableBuilder() throws Exception {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>();\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(iterableBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterator() throws Exception {\n        \/\/ Given\n        Iterator<Integer> expected = new ArrayList<Integer>().iterator();\n\n        \/\/ When\n        Iterator<Integer> actual = iterator();\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Iterator<Integer> expected = new ArrayList<Integer>().iterator();\n\n        \/\/ Then\n        assertThat(iteratorOf(Integer.class), isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingTheSuppliedElements() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorBuilder() throws Exception {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>();\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(iteratorBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollection() throws Exception {\n        \/\/ Given\n        Collection<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        Collection<Integer> actual = collection();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Collection<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(collectionOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingTheSuppliedElements() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n\n        \/\/ When\n        Collection<Integer> actual = collectionWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Collection<Integer> actual = collectionFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Collection<Integer> actual = collectionFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionBuilder() throws Exception {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>();\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(collectionBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyList() throws Exception {\n        \/\/ Given\n        List<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        List<Integer> actual = list();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        List<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(listOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAListContainingTheSuppliedElements() {\n        \/\/ Given\n        List<Integer> expectedList = asList(5, 10, 15);\n\n        \/\/ When\n        List<Integer> actualList = listWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualList, is(expectedList));\n    }\n\n    @Test public void shouldReturnAListContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        List<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        List<Integer> actual = listFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        List<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        List<Integer> actual = listFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListBuilder() throws Exception {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>();\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(listBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultiset() throws Exception {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create();\n\n        \/\/ When\n        Multiset<Integer> actual = multiset();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create();\n\n        \/\/ Then\n        assertThat(multisetOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetContainingTheSuppliedElements() {\n        \/\/ Given\n        Multiset<Integer> expectedMultiset = HashMultiset.create(asList(5, 10, 15));\n\n        \/\/ When\n        Multiset<Integer> actualMultiset = multisetWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualMultiset, is(expectedMultiset));\n    }\n\n    @Test public void shouldReturnAMultisetContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create(asList(5, 10, 15));\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Multiset<Integer> actual = multisetFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create(asList(5, 10, 15));\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Multiset<Integer> actual = multisetFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetBuilder() throws Exception {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>();\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(multisetBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySet() throws Exception {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>();\n\n        \/\/ When\n        Set<Integer> actual = set();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>();\n\n        \/\/ Then\n        assertThat(setOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnASetContainingTheSuppliedElements() {\n        \/\/ Given\n        Set<Integer> expectedSet = new HashSet<Integer>(asList(5, 10, 15));\n\n        \/\/ When\n        Set<Integer> actualSet = setWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualSet, is(expectedSet));\n    }\n\n    @Test public void shouldReturnASetContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>(asList(5, 10, 15));\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Set<Integer> actual = setFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>(asList(5, 10, 15));\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Set<Integer> actual = setFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetBuilder() throws Exception {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>();\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(setBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMap() throws Exception {\n        \/\/ Given\n        Map<String, Integer> expected = new HashMap<String, Integer>();\n\n        \/\/ When\n        Map<String, Integer> actual = map();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Map<String, Integer> expected = new HashMap<String, Integer>();\n\n        \/\/ Then\n        assertThat(mapOf(String.class, Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingTheSuppliedMapEntries() {\n        \/\/ Given\n        Map<Integer, Boolean> expectedMap = new HashMap<Integer, Boolean>();\n        expectedMap.put(1, true);\n        expectedMap.put(2, false);\n\n        \/\/ When\n        Map<Integer, Boolean> actualMap = mapWith(mapEntryFor(1, true), mapEntryFor(2, false));\n\n        \/\/ Then\n        assertThat(actualMap, is(expectedMap));\n    }\n\n    @Test public void shouldReturnAMapContainingTheSuppliedTuples() throws Exception {\n        \/\/ Given\n        Map<Integer, Boolean> expectedMap = new HashMap<Integer, Boolean>();\n        expectedMap.put(1, true);\n        expectedMap.put(2, false);\n        expectedMap.put(3, true);\n\n        \/\/ When\n        Map<Integer, Boolean> actualMap = mapWith(tuple(1, true), tuple(2, false), tuple(3, true));\n\n        \/\/ Then\n        assertThat(actualMap, is(expectedMap));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedIterableOfMapEntryInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, false);\n        Iterable<Map.Entry<Integer, Boolean>> elements = listWith(mapEntryFor(1, false), mapEntryFor(2, false));\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedIterableOfTupleInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, false);\n        Iterable<? extends Pair<Integer, Boolean>> tuples = iterableWith(tuple(1, false), tuple(2, false));\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedArrayOfMapEntryInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, true);\n        @SuppressWarnings(\"unchecked\") Map.Entry<Integer, Boolean>[] elements = new Map.Entry[]{\n                mapEntryFor(1, false),\n                mapEntryFor(2, true)};\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedArrayOfTupleInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, true);\n        @SuppressWarnings(\"unchecked\") Pair<Integer, Boolean>[] tuples = new Pair[]{\n                tuple(1, false),\n                tuple(2, true)};\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapBuilder() throws Exception {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>();\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapBuilderWithKeysAndValuesOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>();\n\n        \/\/ Then\n        assertThat(mapBuilderOf(String.class, Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>().with(\"five\", 5, \"ten\", 10);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(\"five\", 5, \"ten\", 10);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedMapEntryInstances() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>()\n                .with(\"five\", 5, \"ten\", 10);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(mapEntryFor(\"five\", 5), mapEntryFor(\"ten\", 10));\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedTupleInstances() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>()\n                .with(\"five\", 5, \"ten\", 10, \"fifteen\", 15);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(tuple(\"five\", 5), tuple(\"ten\", 10), tuple(\"fifteen\", 15));\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllMapEntryInstancesInTheSuppliedIterable() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        Iterable<Map.Entry<Integer, Boolean>> elements = iterableWith(\n                mapEntryFor(5, true), mapEntryFor(10, false));\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllTupleInstancesInTheSuppliedIterable() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        Iterable<? extends Pair<Integer, Boolean>> tuples = iterableWith(\n                tuple(5, true), tuple(10, false));\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllMapEntryInstancesInTheSuppliedArray() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        @SuppressWarnings(\"unchecked\") Map.Entry<Integer, Boolean>[] elements = new Map.Entry[]{\n                mapEntryFor(5, true),\n                mapEntryFor(10, false)\n        };\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllTupleInstancesInTheSuppliedArray() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        @SuppressWarnings(\"unchecked\") Pair<Integer, Boolean>[] tuples = new Pair[]{\n                tuple(5, true),\n                tuple(10, false)\n        };\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapEntryWithTheSpecifiedKeyAndValue() throws Exception {\n        \/\/ Given\n        String key = \"key\";\n        Integer value = 36;\n\n        \/\/ When\n        Map.Entry<String, Integer> mapEntry = mapEntryFor(key, value);\n\n        \/\/ Then\n        assertThat(mapEntry.getKey(), is(key));\n        assertThat(mapEntry.getValue(), is(value));\n    }\n\n    @Test public void shouldReturnAMapEntryWithKeyAndValueTakenFromTheSpecifiedTuple() throws Exception {\n        \/\/ Given\n        Pair<String, String> keyValuePair = tuple(\"key\", \"value\");\n\n        \/\/ When\n        Map.Entry<String, String> mapEntry = mapEntryFor(keyValuePair);\n\n        \/\/ Then\n        assertThat(mapEntry.getKey(), is(\"key\"));\n        assertThat(mapEntry.getValue(), is(\"value\"));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Integer[] expected = new Integer[]{};\n\n        \/\/ When\n        Integer[] actual = arrayOf(Integer.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingTheSuppliedElements() {\n        \/\/ Given\n        String first = \"first\";\n        String second = \"second\";\n        String[] expected = new String[]{first, second};\n\n        \/\/ When\n        String[] actual = arrayWith(first, second);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterable<Name> elements = iterableWith(name(\"Tim\"), name(\"Jeremy\"), name(\"Fred\"));\n        Name[] expected = new Name[]{name(\"Tim\"), name(\"Jeremy\"), name(\"Fred\")};\n\n        \/\/ When\n        Name[] actual = arrayFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfTheSuppliedIterableIsEmpty() throws Exception {\n        \/\/ Given\n        Iterable<Integer> iterable = iterable();\n\n        try {\n            \/\/ When\n            arrayFrom(iterable);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct empty array without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfIterableContainsInstancesOfDifferentConcreteTypes() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Iterable<Animal> input = iterableWith(animal1, animal2, animal3);\n\n        try {\n            \/\/ When\n            arrayFrom(input);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct array containing instances of different classes without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedIterableOfTheSuppliedType() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Iterable<Animal> input = iterableWith(animal1, animal2, animal3);\n        Animal[] expected = new Animal[]{animal1, animal2, animal3};\n\n        \/\/ When\n        Animal[] actual = arrayFrom(input, Animal.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Integer[] elements = new Integer[]{5, 10, 15};\n        Integer[] expected = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Integer[] array = arrayFrom(elements);\n\n        \/\/ Then\n        assertThat(array, is(expected));\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfTheSuppliedArrayIsEmpty() throws Exception {\n        \/\/ Given\n        Integer[] array = new Integer[]{};\n\n        try {\n            \/\/ When\n            arrayFrom(array);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct empty array without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfArrayContainsInstancesOfDifferentConcreteTypes() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Animal[] input = new Animal[]{animal1, animal2, animal3};\n\n        try {\n            \/\/ When\n            arrayFrom(input);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct array containing instances of different classes without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedArrayOfTheSuppliedType() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Animal[] input = new Animal[]{animal1, animal2, animal3};\n        Animal[] expected = new Animal[]{animal1, animal2, animal3};\n\n        \/\/ When\n        Animal[] actual = arrayFrom(input, Animal.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayBuilder() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>();\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayBuilderOverElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>(Integer.class);\n\n        \/\/ Then\n        assertThat(arrayBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = listWith(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderOverTheSpecifiedElementTypeContainingAllElementsInTheSuppliedIterable() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>(Integer.class).with(5, 10, 15);\n        Iterable<Integer> elements = listWith(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements, Integer.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASingleContainingTheSuppliedElement() {\n        \/\/ Given\n        Single<Integer> expectedSingle = new Single<Integer>(5);\n\n        \/\/ When\n        Single<Integer> actualSingle = tuple(5);\n\n        \/\/ Then\n        assertThat(actualSingle, is(expectedSingle));\n    }\n\n    @Test public void shouldReturnAPairContainingTheSuppliedElements() {\n        \/\/ Given\n        Pair<Integer, String> expectedPair = new Pair<Integer, String>(5, \"Five\");\n\n        \/\/ When\n        Pair<Integer, String> actualPair = tuple(5, \"Five\");\n\n        \/\/ Then\n        assertThat(actualPair, is(expectedPair));\n    }\n\n    @Test public void shouldReturnATripleContainingTheSuppliedElements() {\n        \/\/ Given\n        Triple<Integer, String, Boolean> expectedTriple =\n                new Triple<Integer, String, Boolean>(5, \"Five\", true);\n\n        \/\/ When\n        Triple<Integer, String, Boolean> actualTriple = tuple(5, \"Five\", true);\n\n        \/\/ Then\n        assertThat(actualTriple, is(expectedTriple));\n    }\n\n    @Test public void shouldReturnAQuadrupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Quadruple<Integer, String, Boolean, Double> expectedQuadruple =\n                new Quadruple<Integer, String, Boolean, Double>(5, \"Five\", true, 1.6);\n\n        \/\/ When\n        Quadruple<Integer, String, Boolean, Double> actualQuadruple = tuple(5, \"Five\", true, 1.6);\n\n        \/\/ Then\n        assertThat(actualQuadruple, is(expectedQuadruple));\n    }\n\n    @Test public void shouldReturnAQuintupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Quintuple<Integer, String, Boolean, Double, Long> expectedQuintuple =\n                new Quintuple<Integer, String, Boolean, Double, Long>(5, \"Five\", true, 1.6, 26L);\n\n        \/\/ When\n        Quintuple<Integer, String, Boolean, Double, Long> actualQuintuple = tuple(5, \"Five\", true, 1.6, 26L);\n\n        \/\/ Then\n        assertThat(actualQuintuple, is(expectedQuintuple));\n    }\n\n    @Test public void shouldReturnASextupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Sextuple<Integer, String, Boolean, Double, Long, Name> expectedSextuple =\n                new Sextuple<Integer, String, Boolean, Double, Long, Name>(5, \"Five\", true, 1.6, 26L, name(\"fred\"));\n\n        \/\/ When\n        Sextuple<Integer, String, Boolean, Double, Long, Name> actualSextuple = tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"));\n\n        \/\/ Then\n        assertThat(actualSextuple, is(expectedSextuple));\n    }\n\n    @Test public void shouldReturnASeptupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Septuple<Integer, String, Boolean, Double, Long, Name, Colour> expectedSeptuple =\n                new Septuple<Integer, String, Boolean, Double, Long, Name, Colour>(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"));\n\n        \/\/ When\n        Septuple<Integer, String, Boolean, Double, Long, Name, Colour> actualSeptuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"));\n\n        \/\/ Then\n        assertThat(actualSeptuple, is(expectedSeptuple));\n    }\n\n    @Test public void shouldReturnAnOctupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age> expectedOctuple =\n                new Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age>(\n                        5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25));\n\n        \/\/ When\n        Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age> actualOctuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25));\n\n        \/\/ Then\n        assertThat(actualOctuple, is(expectedOctuple));\n    }\n\n    @Test public void shouldReturnANonupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location> expectedNonuple =\n                new Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location>(\n                        5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25), location(\"London\"));\n\n        \/\/ When\n        Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location> actualNonuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25), location(\"London\"));\n\n        \/\/ Then\n        assertThat(actualNonuple, is(expectedNonuple));\n    }\n}\n","new_contents":"\/*\n * Copyright (C) 2011-Present Funk committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\/\npackage org.javafunk.funk;\n\nimport com.google.common.collect.HashMultiset;\nimport com.google.common.collect.Multiset;\nimport org.javafunk.funk.builders.*;\nimport org.javafunk.funk.datastructures.tuples.*;\nimport org.javafunk.funk.testclasses.*;\nimport org.junit.Test;\n\nimport java.util.*;\n\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.is;\nimport static org.javafunk.funk.Literals.*;\nimport static org.javafunk.funk.builders.IterableBuilder.iterableBuilder;\nimport static org.javafunk.funk.matchers.IteratorMatchers.isIteratorWithSameElementsAs;\nimport static org.javafunk.funk.testclasses.Age.age;\nimport static org.javafunk.funk.testclasses.Animal.animal;\nimport static org.javafunk.funk.testclasses.Cat.cat;\nimport static org.javafunk.funk.testclasses.Colour.colour;\nimport static org.javafunk.funk.testclasses.Dog.dog;\nimport static org.javafunk.funk.testclasses.Location.location;\nimport static org.javafunk.funk.testclasses.Name.name;\nimport static org.junit.Assert.fail;\n\npublic class LiteralsTest {\n    @Test public void shouldReturnAnEmptyIterable() throws Exception {\n        \/\/ Given\n        Iterable<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        Iterable<Integer> actual = iterable();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Iterable<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(iterableOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingTheSuppliedElements() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n\n        \/\/ When\n        Iterable<Integer> actual = iterableWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Iterable<Integer> actual = iterableFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Iterable<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Iterable<Integer> actual = iterableFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableBuilder() throws Exception {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>();\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterableBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(iterableBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIterableBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        IterableBuilder<Integer> expected = new IterableBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        IterableBuilder<Integer> actual = iterableBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIterator() throws Exception {\n        \/\/ Given\n        Iterator<Integer> expected = new ArrayList<Integer>().iterator();\n\n        \/\/ When\n        Iterator<Integer> actual = iterator();\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Iterator<Integer> expected = new ArrayList<Integer>().iterator();\n\n        \/\/ Then\n        assertThat(iteratorOf(Integer.class), isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingTheSuppliedElements() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Iterator<Integer> expected = asList(5, 10, 15).iterator();\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Iterator<Integer> actual = iteratorFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, isIteratorWithSameElementsAs(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorBuilder() throws Exception {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>();\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyIteratorBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(iteratorBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnIteratorBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        IteratorBuilder<Integer> expected = new IteratorBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        IteratorBuilder<Integer> actual = iteratorBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollection() throws Exception {\n        \/\/ Given\n        Collection<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        Collection<Integer> actual = collection();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Collection<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(collectionOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingTheSuppliedElements() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n\n        \/\/ When\n        Collection<Integer> actual = collectionWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Collection<Integer> actual = collectionFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Collection<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Collection<Integer> actual = collectionFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionBuilder() throws Exception {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>();\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyCollectionBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(collectionBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnCollectionBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        CollectionBuilder<Integer> expected = new CollectionBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        CollectionBuilder<Integer> actual = collectionBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyList() throws Exception {\n        \/\/ Given\n        List<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ When\n        List<Integer> actual = list();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        List<Integer> expected = new ArrayList<Integer>();\n\n        \/\/ Then\n        assertThat(listOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAListContainingTheSuppliedElements() {\n        \/\/ Given\n        List<Integer> expectedList = asList(5, 10, 15);\n\n        \/\/ When\n        List<Integer> actualList = listWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualList, is(expectedList));\n    }\n\n    @Test public void shouldReturnAListContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        List<Integer> expected = asList(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        List<Integer> actual = listFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        List<Integer> expected = asList(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        List<Integer> actual = listFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListBuilder() throws Exception {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>();\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyListBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(listBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAListBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        ListBuilder<Integer> expected = new ListBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        ListBuilder<Integer> actual = listBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultiset() throws Exception {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create();\n\n        \/\/ When\n        Multiset<Integer> actual = multiset();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create();\n\n        \/\/ Then\n        assertThat(multisetOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetContainingTheSuppliedElements() {\n        \/\/ Given\n        Multiset<Integer> expectedMultiset = HashMultiset.create(asList(5, 10, 15));\n\n        \/\/ When\n        Multiset<Integer> actualMultiset = multisetWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualMultiset, is(expectedMultiset));\n    }\n\n    @Test public void shouldReturnAMultisetContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create(asList(5, 10, 15));\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Multiset<Integer> actual = multisetFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Multiset<Integer> expected = HashMultiset.create(asList(5, 10, 15));\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Multiset<Integer> actual = multisetFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetBuilder() throws Exception {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>();\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMultisetBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(multisetBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMultisetBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        MultisetBuilder<Integer> expected = new MultisetBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        MultisetBuilder<Integer> actual = multisetBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySet() throws Exception {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>();\n\n        \/\/ When\n        Set<Integer> actual = set();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>();\n\n        \/\/ Then\n        assertThat(setOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnASetContainingTheSuppliedElements() {\n        \/\/ Given\n        Set<Integer> expectedSet = new HashSet<Integer>(asList(5, 10, 15));\n\n        \/\/ When\n        Set<Integer> actualSet = setWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actualSet, is(expectedSet));\n    }\n\n    @Test public void shouldReturnASetContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>(asList(5, 10, 15));\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        Set<Integer> actual = setFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Set<Integer> expected = new HashSet<Integer>(asList(5, 10, 15));\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Set<Integer> actual = setFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetBuilder() throws Exception {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>();\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptySetBuilderWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>();\n\n        \/\/ Then\n        assertThat(setBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = asList(5, 10, 15);\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASetBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        SetBuilder<Integer> expected = new SetBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        SetBuilder<Integer> actual = setBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMap() throws Exception {\n        \/\/ Given\n        Map<String, Integer> expected = new HashMap<String, Integer>();\n\n        \/\/ When\n        Map<String, Integer> actual = map();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Map<String, Integer> expected = new HashMap<String, Integer>();\n\n        \/\/ Then\n        assertThat(mapOf(String.class, Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingTheSuppliedMapEntries() {\n        \/\/ Given\n        Map<Integer, Boolean> expectedMap = new HashMap<Integer, Boolean>();\n        expectedMap.put(1, true);\n        expectedMap.put(2, false);\n\n        \/\/ When\n        Map<Integer, Boolean> actualMap = mapWith(mapEntryFor(1, true), mapEntryFor(2, false));\n\n        \/\/ Then\n        assertThat(actualMap, is(expectedMap));\n    }\n\n    @Test public void shouldReturnAMapContainingTheSuppliedTuples() throws Exception {\n        \/\/ Given\n        Map<Integer, Boolean> expectedMap = new HashMap<Integer, Boolean>();\n        expectedMap.put(1, true);\n        expectedMap.put(2, false);\n        expectedMap.put(3, true);\n\n        \/\/ When\n        Map<Integer, Boolean> actualMap = mapWith(tuple(1, true), tuple(2, false), tuple(3, true));\n\n        \/\/ Then\n        assertThat(actualMap, is(expectedMap));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedIterableOfMapEntryInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, false);\n        Iterable<Map.Entry<Integer, Boolean>> elements = listWith(mapEntryFor(1, false), mapEntryFor(2, false));\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedIterableOfTupleInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, false);\n        Iterable<? extends Pair<Integer, Boolean>> tuples = iterableWith(tuple(1, false), tuple(2, false));\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedArrayOfMapEntryInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, true);\n        @SuppressWarnings(\"unchecked\") Map.Entry<Integer, Boolean>[] elements = new Map.Entry[]{\n                mapEntryFor(1, false),\n                mapEntryFor(2, true)};\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapContainingAllElementsInTheSuppliedArrayOfTupleInstances() {\n        \/\/ Given\n        Map<Integer, Boolean> expected = new HashMap<Integer, Boolean>();\n        expected.put(1, false);\n        expected.put(2, true);\n        @SuppressWarnings(\"unchecked\") Pair<Integer, Boolean>[] tuples = new Pair[]{\n                tuple(1, false),\n                tuple(2, true)};\n\n        \/\/ When\n        Map<Integer, Boolean> actual = mapFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapBuilder() throws Exception {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>();\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyMapBuilderWithKeysAndValuesOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>();\n\n        \/\/ Then\n        assertThat(mapBuilderOf(String.class, Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>().with(\"five\", 5, \"ten\", 10);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(\"five\", 5, \"ten\", 10);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedMapEntryInstances() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>()\n                .with(\"five\", 5, \"ten\", 10);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(mapEntryFor(\"five\", 5), mapEntryFor(\"ten\", 10));\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderWithTheSuppliedTupleInstances() {\n        \/\/ Given\n        MapBuilder<String, Integer> expected = new MapBuilder<String, Integer>()\n                .with(\"five\", 5, \"ten\", 10, \"fifteen\", 15);\n\n        \/\/ When\n        MapBuilder<String, Integer> actual = mapBuilderWith(tuple(\"five\", 5), tuple(\"ten\", 10), tuple(\"fifteen\", 15));\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllMapEntryInstancesInTheSuppliedIterable() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        Iterable<Map.Entry<Integer, Boolean>> elements = iterableWith(\n                mapEntryFor(5, true), mapEntryFor(10, false));\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllTupleInstancesInTheSuppliedIterable() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        Iterable<? extends Pair<Integer, Boolean>> tuples = iterableWith(\n                tuple(5, true), tuple(10, false));\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllMapEntryInstancesInTheSuppliedArray() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        @SuppressWarnings(\"unchecked\") Map.Entry<Integer, Boolean>[] elements = new Map.Entry[]{\n                mapEntryFor(5, true),\n                mapEntryFor(10, false)\n        };\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromEntries(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapBuilderContainingAllTupleInstancesInTheSuppliedArray() {\n        \/\/ Given\n        MapBuilder<Integer, Boolean> expected = new MapBuilder<Integer, Boolean>().with(5, true, 10, false);\n        @SuppressWarnings(\"unchecked\") Pair<Integer, Boolean>[] tuples = new Pair[]{\n                tuple(5, true),\n                tuple(10, false)\n        };\n\n        \/\/ When\n        MapBuilder<Integer, Boolean> actual = mapBuilderFromTuples(tuples);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAMapEntryWithTheSpecifiedKeyAndValue() throws Exception {\n        \/\/ Given\n        String key = \"key\";\n        Integer value = 36;\n\n        \/\/ When\n        Map.Entry<String, Integer> mapEntry = mapEntryFor(key, value);\n\n        \/\/ Then\n        assertThat(mapEntry.getKey(), is(key));\n        assertThat(mapEntry.getValue(), is(value));\n    }\n\n    @Test public void shouldReturnAMapEntryWithKeyAndValueTakenFromTheSpecifiedTuple() throws Exception {\n        \/\/ Given\n        Pair<String, String> keyValuePair = tuple(\"key\", \"value\");\n\n        \/\/ When\n        Map.Entry<String, String> mapEntry = mapEntryFor(keyValuePair);\n\n        \/\/ Then\n        assertThat(mapEntry.getKey(), is(\"key\"));\n        assertThat(mapEntry.getValue(), is(\"value\"));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayWithElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        Integer[] expected = new Integer[]{};\n\n        \/\/ When\n        Integer[] actual = arrayOf(Integer.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingTheSuppliedElements() {\n        \/\/ Given\n        String first = \"first\";\n        String second = \"second\";\n        String[] expected = new String[]{first, second};\n\n        \/\/ When\n        String[] actual = arrayWith(first, second);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        Iterable<Name> elements = iterableWith(name(\"Tim\"), name(\"Jeremy\"), name(\"Fred\"));\n        Name[] expected = new Name[]{name(\"Tim\"), name(\"Jeremy\"), name(\"Fred\")};\n\n        \/\/ When\n        Name[] actual = arrayFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfTheSuppliedIterableIsEmpty() throws Exception {\n        \/\/ Given\n        Iterable<Integer> iterable = iterable();\n\n        try {\n            \/\/ When\n            arrayFrom(iterable);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct empty array without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfIterableContainsInstancesOfDifferentConcreteTypes() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Iterable<Animal> input = iterableWith(animal1, animal2, animal3);\n\n        try {\n            \/\/ When\n            arrayFrom(input);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct array containing instances of different classes without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedIterableOfTheSuppliedType() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Iterable<Animal> input = iterableWith(animal1, animal2, animal3);\n        Animal[] expected = new Animal[]{animal1, animal2, animal3};\n\n        \/\/ When\n        Animal[] actual = arrayFrom(input, Animal.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        Integer[] elements = new Integer[]{5, 10, 15};\n        Integer[] expected = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        Integer[] array = arrayFrom(elements);\n\n        \/\/ Then\n        assertThat(array, is(expected));\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfTheSuppliedArrayIsEmpty() throws Exception {\n        \/\/ Given\n        Integer[] array = new Integer[]{};\n\n        try {\n            \/\/ When\n            arrayFrom(array);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct empty array without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldThrowIllegalArgumentExceptionIfArrayContainsInstancesOfDifferentConcreteTypes() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Animal[] input = new Animal[]{animal1, animal2, animal3};\n\n        try {\n            \/\/ When\n            arrayFrom(input);\n            fail(\"Expected IllegalArgumentException to be thrown but nothing was.\");\n        } catch (IllegalArgumentException exception) {\n            \/\/ Then\n            assertThat(exception.getMessage(),\n                    containsString(\"Cannot construct array containing instances of different classes without knowing desired element class.\"));\n        }\n    }\n\n    @Test public void shouldReturnAnArrayContainingAllElementsInTheSuppliedArrayOfTheSuppliedType() throws Exception {\n        \/\/ Given\n        Dog animal1 = dog(colour(\"Brown\"), name(\"Fido\"));\n        Cat animal2 = cat(colour(\"White\"), name(\"Fluff\"));\n        Animal animal3 = animal(colour(\"Green\"), name(\"Fishy\"));\n        Animal[] input = new Animal[]{animal1, animal2, animal3};\n        Animal[] expected = new Animal[]{animal1, animal2, animal3};\n\n        \/\/ When\n        Animal[] actual = arrayFrom(input, Animal.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayBuilder() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>();\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilder();\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnEmptyArrayBuilderOverElementsOfTheSpecifiedType() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>(Integer.class);\n\n        \/\/ Then\n        assertThat(arrayBuilderOf(Integer.class), is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderWithTheSuppliedElements() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderWith(5, 10, 15);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderContainingAllElementsInTheSuppliedIterable() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n        Iterable<Integer> elements = listWith(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderOverTheSpecifiedElementTypeContainingAllElementsInTheSuppliedIterable() throws Exception {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>(Integer.class).with(5, 10, 15);\n        Iterable<Integer> elements = listWith(5, 10, 15);\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements, Integer.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderContainingAllElementsInTheSuppliedArray() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>().with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnAnArrayBuilderContainingAllElementsInTheSuppliedArrayOverTheSpecifiedType() {\n        \/\/ Given\n        ArrayBuilder<Integer> expected = new ArrayBuilder<Integer>(Integer.class).with(5, 10, 15);\n        Integer[] elements = new Integer[]{5, 10, 15};\n\n        \/\/ When\n        ArrayBuilder<Integer> actual = arrayBuilderFrom(elements, Integer.class);\n\n        \/\/ Then\n        assertThat(actual, is(expected));\n    }\n\n    @Test public void shouldReturnASingleContainingTheSuppliedElement() {\n        \/\/ Given\n        Single<Integer> expectedSingle = new Single<Integer>(5);\n\n        \/\/ When\n        Single<Integer> actualSingle = tuple(5);\n\n        \/\/ Then\n        assertThat(actualSingle, is(expectedSingle));\n    }\n\n    @Test public void shouldReturnAPairContainingTheSuppliedElements() {\n        \/\/ Given\n        Pair<Integer, String> expectedPair = new Pair<Integer, String>(5, \"Five\");\n\n        \/\/ When\n        Pair<Integer, String> actualPair = tuple(5, \"Five\");\n\n        \/\/ Then\n        assertThat(actualPair, is(expectedPair));\n    }\n\n    @Test public void shouldReturnATripleContainingTheSuppliedElements() {\n        \/\/ Given\n        Triple<Integer, String, Boolean> expectedTriple =\n                new Triple<Integer, String, Boolean>(5, \"Five\", true);\n\n        \/\/ When\n        Triple<Integer, String, Boolean> actualTriple = tuple(5, \"Five\", true);\n\n        \/\/ Then\n        assertThat(actualTriple, is(expectedTriple));\n    }\n\n    @Test public void shouldReturnAQuadrupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Quadruple<Integer, String, Boolean, Double> expectedQuadruple =\n                new Quadruple<Integer, String, Boolean, Double>(5, \"Five\", true, 1.6);\n\n        \/\/ When\n        Quadruple<Integer, String, Boolean, Double> actualQuadruple = tuple(5, \"Five\", true, 1.6);\n\n        \/\/ Then\n        assertThat(actualQuadruple, is(expectedQuadruple));\n    }\n\n    @Test public void shouldReturnAQuintupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Quintuple<Integer, String, Boolean, Double, Long> expectedQuintuple =\n                new Quintuple<Integer, String, Boolean, Double, Long>(5, \"Five\", true, 1.6, 26L);\n\n        \/\/ When\n        Quintuple<Integer, String, Boolean, Double, Long> actualQuintuple = tuple(5, \"Five\", true, 1.6, 26L);\n\n        \/\/ Then\n        assertThat(actualQuintuple, is(expectedQuintuple));\n    }\n\n    @Test public void shouldReturnASextupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Sextuple<Integer, String, Boolean, Double, Long, Name> expectedSextuple =\n                new Sextuple<Integer, String, Boolean, Double, Long, Name>(5, \"Five\", true, 1.6, 26L, name(\"fred\"));\n\n        \/\/ When\n        Sextuple<Integer, String, Boolean, Double, Long, Name> actualSextuple = tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"));\n\n        \/\/ Then\n        assertThat(actualSextuple, is(expectedSextuple));\n    }\n\n    @Test public void shouldReturnASeptupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Septuple<Integer, String, Boolean, Double, Long, Name, Colour> expectedSeptuple =\n                new Septuple<Integer, String, Boolean, Double, Long, Name, Colour>(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"));\n\n        \/\/ When\n        Septuple<Integer, String, Boolean, Double, Long, Name, Colour> actualSeptuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"));\n\n        \/\/ Then\n        assertThat(actualSeptuple, is(expectedSeptuple));\n    }\n\n    @Test public void shouldReturnAnOctupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age> expectedOctuple =\n                new Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age>(\n                        5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25));\n\n        \/\/ When\n        Octuple<Integer, String, Boolean, Double, Long, Name, Colour, Age> actualOctuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25));\n\n        \/\/ Then\n        assertThat(actualOctuple, is(expectedOctuple));\n    }\n\n    @Test public void shouldReturnANonupleContainingTheSuppliedElements() {\n        \/\/ Given\n        Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location> expectedNonuple =\n                new Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location>(\n                        5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25), location(\"London\"));\n\n        \/\/ When\n        Nonuple<Integer, String, Boolean, Double, Long, Name, Colour, Age, Location> actualNonuple =\n                tuple(5, \"Five\", true, 1.6, 26L, name(\"fred\"), colour(\"red\"), age(25), location(\"London\"));\n\n        \/\/ Then\n        assertThat(actualNonuple, is(expectedNonuple));\n    }\n}\n","subject":"","message":"Adding arrayBuilderFrom(E[], Class<E>).\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"8fb568748e24c2b855dbe146d6c912fe47aee588","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"d198c950c682da61f31c061c2e6d16ac336b099f","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"40136aee2dcd2a4e32e97665df8ce21be9ff81f3","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"c4fedd0c9a0b38af06abebc8ccde9d3c1c4e5726","old_file":"src\/main\/java\/org\/javafunk\/funk\/Literals.java","new_file":"src\/main\/java\/org\/javafunk\/funk\/Literals.java","old_contents":"\/*\n * Copyright (C) 2011-Present Funk committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\/\npackage org.javafunk.funk;\n\nimport com.google.common.collect.Multiset;\nimport org.javafunk.funk.builders.*;\nimport org.javafunk.funk.datastructures.tuples.*;\n\nimport java.util.*;\n\nimport static java.util.Arrays.asList;\n\npublic class Literals {\n    private Literals() {}\n\n    public static <E> Iterable<E> iterable() {\n        return new IterableBuilder<E>().build();\n    }\n\n    public static <E> Iterable<E> iterableOf(Class<E> elementClass) {\n        return new IterableBuilder<E>().build();\n    }\n\n    public static <E> Iterable<E> iterableFrom(Iterable<? extends E> elements) {\n        return new IterableBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Iterable<E> iterableFrom(E[] elementArray) {\n        return new IterableBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilder() {\n        return new IterableBuilder<E>();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderOf(Class<E> elementClass) {\n        return new IterableBuilder<E>();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderFrom(Iterable<? extends E> elements) {\n        return new IterableBuilder<E>().with(elements);\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderFrom(E[] elementArray) {\n        return new IterableBuilder<E>().with(elementArray);\n    }\n\n    public static <E> Iterator<E> iterator() {\n        return new IteratorBuilder<E>().build();\n    }\n\n    public static <E> Iterator<E> iteratorOf(Class<E> elementClass) {\n        return new IteratorBuilder<E>().build();\n    }\n\n    public static <E> Iterator<E> iteratorFrom(Iterable<? extends E> elements) {\n        return new IteratorBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Iterator<E> iteratorFrom(E[] elementArray) {\n        return new IteratorBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilder() {\n        return new IteratorBuilder<E>();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderOf(Class<E> elementClass) {\n        return new IteratorBuilder<E>();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderFrom(Iterable<? extends E> elements) {\n        return new IteratorBuilder<E>().with(elements);\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderFrom(E[] elementArray) {\n        return new IteratorBuilder<E>().with(elementArray);\n    }\n\n    public static <E> Collection<E> collection() {\n        return new CollectionBuilder<E>().build();\n    }\n\n    public static <E> Collection<E> collectionOf(Class<E> elementClass) {\n        return new CollectionBuilder<E>().build();\n    }\n\n    public static <E> Collection<E> collectionFrom(Iterable<? extends E> elements) {\n        return new CollectionBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Collection<E> collectionFrom(E[] elementArray) {\n        return new CollectionBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilder() {\n        return new CollectionBuilder<E>();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderOf(Class<E> elementClass) {\n        return new CollectionBuilder<E>();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderFrom(Iterable<? extends E> elements) {\n        return new CollectionBuilder<E>().with(elements);\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderFrom(E[] elementArray) {\n        return new CollectionBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns an empty mutable {@code List} instance.\n     *\n     * <p>This form of literal is most suited to direct assignment to a variable\n     * since in this case, the type {@code E} is inferred from the variable\n     * declaration. For example:\n     * <blockquote>\n     * <pre>\n     *   List&lt;String&gt; strings = list();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param <E> The type of the elements contained in the {@code List}.\n     * @return A {@code List} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> List<E> list() {\n        return new ListBuilder<E>().build();\n    }\n\n    \/**\n     * Returns an empty mutable {@code List} instance over the type\n     * of the supplied {@code Class}.\n     *\n     * <p>This form of literal is most suited to inline usage such as when passing an\n     * empty list as a parameter in a method call since it reads more clearly than\n     * {@link #list()}. For example, compare the following:\n     * <blockquote>\n     * <pre>\n     *   public class Calculation {\n     *       public Calculation(Type type, List&lt;Integer&gt; values) {\n     *           ...\n     *       }\n     *\n     *       ...\n     *   }\n     *\n     *   Calculation sum1 = new Calculation(Type.SUM, Literals.&lt;Integer&gt;list());\n     *   Calculation sum2 = new Calculation(Type.SUM, listOf(Integer.class));\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code List}\n     * @param <E>          The type of the elements contained in the {@code List}.\n     * @return A {@code List} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> List<E> listOf(Class<E> elementClass) {\n        return new ListBuilder<E>().build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * {@code List} is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>This form of literal is useful when a number of lazy operations have been\n     * performed resulting in an {@code Iterable} where a collection implementing\n     * the {@code List} contract is required. For example:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Person&gt; people = Literals.listWith(firstPerson, secondPerson, thirdPerson);\n     *   Iterable&lt;Address&gt; addresses = Lazily.map(people, toAddress());\n     *   Iterable&lt;StreetName&gt; streetNames = Lazily.map(addresses, toStreetName());\n     *   Iterable&lt;StreetName&gt; avenueStreetNames = Lazily.filter(streetNames, whereIsAvenue());\n     *   List&lt;StreetName&gt; listOfAvenues = Literals.listFrom(avenueStreetNames);\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which a {@code List} should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned {@code List}.\n     * @return A {@code List} over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     *\/\n    public static <E> List<E> listFrom(Iterable<? extends E> elements) {\n        return new ListBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting {@code List}\n     * is the same as the order of the elements in the array.\n     *\n     * <p>For example, the following:\n     * <blockquote>\n     * <pre>\n     *   String[] strings = new String[]{\"one\", \"two\", \"three\"};\n     *   List&lt;String&gt; listOfStrings = Literals.listFrom(strings);\n     * <\/pre>\n     * <\/blockquote>\n     * is equivalent to:\n     * <blockquote>\n     * <pre>\n     *   List&ltString&gt; listOfStrings = Literals.listWith(\"one\", \"two\", \"three\");\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementArray An array of elements from which a {@code List} should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned {@code List}.\n     * @return A {@code List} over the type {@code E} containing all elements from the\n     *         supplied array in the same order as the supplied array.\n     *\/\n    public static <E> List<E> listFrom(E[] elementArray) {\n        return new ListBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   An element from which to construct a {@code List}.\n     * @param <E> The type of the element contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> List<E> listWith(E e) {\n        return listFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2) {\n        return listFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3) {\n        return listFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4) {\n        return listFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param e9  The ninth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param e9  The ninth element from which to construct a {@code List}.\n     * @param e10 The tenth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * <p>Note that this literal uses a generic varargs parameter as the last argument in the\n     * argument list and as such will cause unchecked cast warnings. Explicit argument\n     * lists for up to ten arguments have been provided for convenience. In order to avoid\n     * the unchecked cast warnings, a {@link ListBuilder} can be used instead.<\/p>\n     *\n     * @param e1    The first element from which to construct a {@code List}.\n     * @param e2    The second element from which to construct a {@code List}.\n     * @param e3    The third element from which to construct a {@code List}.\n     * @param e4    The fourth element from which to construct a {@code List}.\n     * @param e5    The fifth element from which to construct a {@code List}.\n     * @param e6    The sixth element from which to construct a {@code List}.\n     * @param e7    The seventh element from which to construct a {@code List}.\n     * @param e8    The eighth element from which to construct a {@code List}.\n     * @param e9    The ninth element from which to construct a {@code List}.\n     * @param e10   The tenth element from which to construct a {@code List}.\n     * @param e11on The remaining elements from which to construct a {@code List}.\n     * @param <E>   The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} as follows:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.&lt;Integer&gt;listBuilder()\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 4, 5, 6);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param <E> The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilder() {\n        return new ListBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over the type of the supplied {@code Class}\n     * containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} as follows:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = listBuilderOf(Integer.class)\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 4, 5, 6);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ListBuilder}\n     * @param <E>          The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing no\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderOf(Class<E> elementClass) {\n        return new ListBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied {@code Iterable}.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   List&lt;Integer&gt; list = listBuilderFrom(firstCollection)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ListBuilder} should be initialised.\n     * @param <E>      The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ListBuilder<E> listBuilderFrom(Iterable<? extends E> elements) {\n        return new ListBuilder<E>().with(elements);\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied array.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   List&lt;Integer&gt; list = listBuilderFrom(firstArray)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the\n     *                     {@code ListBuilder} should be initialised.\n     * @param <E>          The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ListBuilder<E> listBuilderFrom(E[] elementArray) {\n        return new ListBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   The element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         element.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e) {\n        return listBuilderFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2) {\n        return listBuilderFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3) {\n        return listBuilderFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param e9  The ninth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param e9  The ninth element to be added to the {@code ListBuilder}.\n     * @param e10 The tenth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that this literal uses a generic varargs parameter as the last argument in the\n     * argument list and as such will cause unchecked cast warnings. Explicit argument\n     * lists for up to ten arguments have been provided for convenience. In order to avoid\n     * the unchecked cast warnings, a {@link ListBuilder} instance can be used directly with\n     * multiple method calls accumulating the builder contents.<\/p>\n     *\n     * @param e1    The first element to be added to the {@code ListBuilder}.\n     * @param e2    The second element to be added to the {@code ListBuilder}.\n     * @param e3    The third element to be added to the {@code ListBuilder}.\n     * @param e4    The fourth element to be added to the {@code ListBuilder}.\n     * @param e5    The fifth element to be added to the {@code ListBuilder}.\n     * @param e6    The sixth element to be added to the {@code ListBuilder}.\n     * @param e7    The seventh element to be added to the {@code ListBuilder}.\n     * @param e8    The eighth element to be added to the {@code ListBuilder}.\n     * @param e9    The ninth element to be added to the {@code ListBuilder}.\n     * @param e10   The tenth element to be added to the {@code ListBuilder}.\n     * @param e11on The remaining elements to be added to the {@code ListBuilder}. The elements\n     *              will be added to the {@code ListBuilder} in the order they are defined in the\n     *              argument list.\n     * @param <E>   The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on));\n    }\n\n    \/**\n     * Returns an empty mutable {@code Set} instance.\n     *\n     * <p>This form of literal is most suited to direct assignment to a variable\n     * since in this case, the type {@code E} is inferred from the variable\n     * declaration. For example:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;String&gt; strings = set();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param <E> The type of the elements contained in the {@code Set}.\n     * @return A {@code Set} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> Set<E> set() {\n        return new SetBuilder<E>().build();\n    }\n\n    \/**\n     * Returns an empty mutable {@code Set} instance over the type\n     * of the supplied {@code Class}.\n     *\n     * <p>This form of literal is most suited to inline usage such as when passing an\n     * empty set as a parameter in a method call since it reads more clearly than\n     * {@link #set()}. For example, compare the following:\n     * <blockquote>\n     * <pre>\n     *   public class OrderRepository {\n     *       public void save(Customer customer, Set&lt;LineItem&gt; lineItems) {\n     *           ...\n     *       }\n     *\n     *       ...\n     *   }\n     *\n     *   orderRepository.save(customer, Literals.&lt;LineItem&gt;set());\n     *   orderRepository.save(customer, setOf(LineItem.class));\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code Set}.\n     * @param <E>          The type of the elements contained in the {@code List}.\n     * @return A {@code Set} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> Set<E> setOf(Class<E> elementClass) {\n        return new SetBuilder<E>().build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. Due to the nature of a {@code Set}, any\n     * duplicate elements in the supplied {@code Iterable} will be removed.\n     *\n     * <p>This form of literal is useful when a number of lazy operations have been\n     * performed resulting in an {@code Iterable} where a collection implementing\n     * the {@code Set} contract is required. For example:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Person&gt; people = Literals.setWith(firstPerson, secondPerson, thirdPerson);\n     *   Iterable&lt;Address&gt; addresses = Lazily.map(people, toAddress());\n     *   Iterable&lt;StreetName&gt; streetNames = Lazily.map(addresses, toStreetName());\n     *   Iterable&lt;StreetName&gt; avenueStreetNames = Lazily.filter(streetNames, whereIsAvenue());\n     *   Set&lt;StreetName&gt; relevantAvenues = Literals.setFrom(avenueStreetNames);\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which a {@code Set} should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned {@code Set}.\n     * @return A {@code Set} over the type {@code E} containing all unique elements from the\n     *         supplied {@code Iterable}.\n     *\/\n    public static <E> Set<E> setFrom(Iterable<? extends E> elements) {\n        return new SetBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing all elements\n     * from the supplied array. Due to the nature of a {@code Set}, any\n     * duplicate elements in the supplied {@code Iterable} will be removed.\n     *\n     * <p>For example, the following:\n     * <blockquote>\n     * <pre>\n     *   String[] strings = new String[]{\"one\", \"two\", \"two\", \"three\"};\n     *   Set&lt;String&gt; setOfStrings = Literals.setFrom(strings);\n     * <\/pre>\n     * <\/blockquote>\n     * is equivalent to:\n     * <blockquote>\n     * <pre>\n     *   Set&ltString&gt; listOfStrings = Literals.setWith(\"one\", \"two\", \"three\");\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementArray An array of elements from which a {@code Set} should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned {@code Set}.\n     * @return A {@code Set} over the type {@code E} containing all unique elements from the\n     *         supplied array.\n     *\/\n    public static <E> Set<E> setFrom(E[] elementArray) {\n        return new SetBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   An element from which to construct a {@code Set}.\n     * @param <E> The type of the element contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> Set<E> setWith(E e) {\n        return setFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2) {\n        return setFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3) {\n        return setFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4) {\n        return setFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param e9  The ninth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param e9  The ninth element from which to construct a {@code Set}.\n     * @param e10 The tenth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1    The first element from which to construct a {@code Set}.\n     * @param e2    The second element from which to construct a {@code Set}.\n     * @param e3    The third element from which to construct a {@code Set}.\n     * @param e4    The fourth element from which to construct a {@code Set}.\n     * @param e5    The fifth element from which to construct a {@code Set}.\n     * @param e6    The sixth element from which to construct a {@code Set}.\n     * @param e7    The seventh element from which to construct a {@code Set}.\n     * @param e8    The eighth element from which to construct a {@code Set}.\n     * @param e9    The ninth element from which to construct a {@code Set}.\n     * @param e10   The tenth element from which to construct a {@code Set}.\n     * @param e11on The remaining elements from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11on) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build();\n    }\n\n    public static <E> SetBuilder<E> setBuilder() {\n        return new SetBuilder<E>();\n    }\n\n    public static <E> SetBuilder<E> setBuilderOf(Class<E> elementClass) {\n        return new SetBuilder<E>();\n    }\n\n    public static <E> SetBuilder<E> setBuilderFrom(Iterable<? extends E> elements) {\n        return new SetBuilder<E>().with(elements);\n    }\n\n    public static <E> SetBuilder<E> setBuilderFrom(E[] elementArray) {\n        return new SetBuilder<E>().with(elementArray);\n    }\n\n    public static <E> Multiset<E> multiset() {\n        return new MultisetBuilder<E>().build();\n    }\n\n    public static <E> Multiset<E> multisetOf(Class<E> elementClass) {\n        return new MultisetBuilder<E>().build();\n    }\n\n    public static <E> Multiset<E> multisetFrom(Iterable<? extends E> elements) {\n        return new MultisetBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Multiset<E> multisetFrom(E[] elementArray) {\n        return new MultisetBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilder() {\n        return new MultisetBuilder<E>();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderOf(Class<E> elementClass) {\n        return new MultisetBuilder<E>();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderFrom(Iterable<? extends E> elements) {\n        return new MultisetBuilder<E>().with(elements);\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderFrom(E[] elementArray) {\n        return new MultisetBuilder<E>().with(elementArray);\n    }\n\n    public static <K, V> Map<K, V> map() {\n        return new MapBuilder<K, V>().build();\n    }\n\n    public static <K, V> Map<K, V> mapOf(Class<K> keyClass, Class<V> valueClass) {\n        return new MapBuilder<K, V>().build();\n    }\n\n    public static <K, V> Map<K, V> mapFromEntries(Iterable<? extends Map.Entry<K, V>> elements) {\n        return new MapBuilder<K, V>().with(elements).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromEntries(Map.Entry<K, V>[] elementArray) {\n        return new MapBuilder<K, V>().with(elementArray).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromTuples(Iterable<? extends Pair<K, V>> elements) {\n        return new MapBuilder<K, V>().withPairs(elements).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromTuples(Pair<K, V>[] elementArray) {\n        return new MapBuilder<K, V>().withPairs(elementArray).build();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilder() {\n        return new MapBuilder<K, V>();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderOf(Class<K> keyClass, Class<V> valueClass) {\n        return new MapBuilder<K, V>();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromEntries(Iterable<? extends Map.Entry<K, V>> entries) {\n        return new MapBuilder<K, V>().with(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromEntries(Map.Entry<K, V>[] entries) {\n        return new MapBuilder<K, V>().with(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromTuples(Iterable<? extends Pair<K, V>> entries) {\n        return new MapBuilder<K, V>().withPairs(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromTuples(Pair<K, V>[] entries) {\n        return new MapBuilder<K, V>().withPairs(entries);\n    }\n\n    public static <K, V> Map.Entry<K, V> mapEntryFor(K key, V value) {\n        return new AbstractMap.SimpleEntry<K, V>(key, value);\n    }\n\n    public static <K, V> Map.Entry<K, V> mapEntryFor(Pair<K, V> pair) {\n        return new AbstractMap.SimpleEntry<K, V>(pair.first(), pair.second());\n    }\n\n    \/**\n     * Returns an empty array instance over the type {@code E}.\n     *\n     * @param <E> The type of the elements that would be contained by this array\n     *            if it contained any.\n     * @return An array instance over the type {@code E} containing no elements.\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E[] arrayOf(Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * array is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>The supplied {@code Iterable} must contain at least one element so that\n     * the type E can be correctly inferred when constructing the array. In the\n     * case that the {@code Iterable} is empty, an {@code IllegalArgumentException}\n     * will be thrown.<\/p>\n     *\n     * <p>The elements in the supplied {@code Iterable} must all be of the same\n     * concrete type so that the type E can be inferred deterministically when\n     * constructing the array. In the case that the {@code Iterable} contains\n     * elements of different concrete types, an {@code IllegalArgumentException}\n     * will be thrown. If an array containing multiple concrete types of some\n     * supertype is required, use the {@link #arrayFrom(Iterable, Class)}\n     * variant.<\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which an array should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     * @throws IllegalArgumentException if the supplied {@code Iterable} contains no\n     *                                  elements or contains elements of different\n     *                                  concrete types.\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E[] arrayFrom(Iterable<E> elements) {\n        return new ArrayBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * array is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>Unlike {@link #arrayFrom(Iterable)}, this variant accepts empty\n     * {@code Iterable}s and {@code Iterable}s containing instances of different\n     * concrete types and so should be used in preference of {@link #arrayFrom(Iterable)}\n     * if such {@code Iterable}s are expected.<\/p>\n     *\n     * <h4>Example Usage:<\/h4>\n     * Assume that we have the following instances:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *   Iterable&lt;Employee&gt; employees = iterableWith(partTimeEmployee, fullTimeEmployee, hourlyEmployee);\n     * <\/pre>\n     * <\/blockquote>\n     * If we attempt to construct an array directly from the {@code Iterable}, an\n     * {@code IllegalArgumentException} will be thrown:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees); \/\/ => IllegalArgumentException\n     * <\/pre>\n     * <\/blockquote>\n     * However using this variant, we obtain an array of {@code Employee} instances. The following\n     * two arrays are equivalent:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees, Employee.class);\n     *   Employee[] employeeArray = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     *\n     * @param elements     An {@code Iterable} of elements from which an array should be\n     *                     constructed.\n     * @param elementClass A {@code Class} representing the required type {@code E} of\n     *                     the resultant array.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     *\/\n    public static <E> E[] arrayFrom(Iterable<? extends E> elements, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elements).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting\n     * array is the same as the order of elements in the supplied array.\n     *\n     * <p>The supplied array must contain at least one element so that the type E\n     * can be correctly inferred when constructing the array to return. In the\n     * case that the array is empty, an {@code IllegalArgumentException}\n     * will be thrown.<\/p>\n     *\n     * <p>The elements in the supplied array must all be of the same\n     * concrete type so that the type E can be inferred deterministically when\n     * constructing the array. In the case that the array contains\n     * elements of different concrete types, an {@code IllegalArgumentException}\n     * will be thrown. If an array containing multiple concrete types of some\n     * supertype is required, use the {@link #arrayFrom(Object[], Class)}\n     * variant.<\/p>\n     *\n     * @param elementArray An array of elements from which an array should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied array in the same order as the supplied array.\n     * @throws IllegalArgumentException if the supplied {@code Iterable} contains no\n     *                                  elements or contains elements of different\n     *                                  concrete types.\n     *\/\n    public static <E> E[] arrayFrom(E[] elementArray) {\n        return new ArrayBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting\n     * array is the same as the order of elements in the supplied array.\n     *\n     * <p>Unlike {@link #arrayFrom(Object[])}, this variant accepts empty\n     * arrays and arrays containing instances of different concrete types and\n     * so should be used in preference of {@link #arrayFrom(Object[])}\n     * if such arrays are expected.<\/p>\n     *\n     * <h4>Example Usage:<\/h4>\n     * Assume that we have the following instances:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *   Employee[] employees = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     * If we attempt to construct an array directly from the array, an\n     * {@code IllegalArgumentException} will be thrown:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees); \/\/ => IllegalArgumentException\n     * <\/pre>\n     * <\/blockquote>\n     * However using this variant, we obtain an array of {@code Employee} instances. The following\n     * two arrays are equivalent:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees, Employee.class);\n     *   Employee[] employeeArray = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     *\n     * @param elementArray An array of elements from which an array should be constructed.\n     * @param elementClass A {@code Class} representing the required type {@code E} of\n     *                     the resultant array.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied array in the same order.\n     *\/\n    public static <E> E[] arrayFrom(E[] elementArray, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elementArray).build();\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied element.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e   An element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e) {\n        return arrayFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2) {\n        return arrayFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3) {\n        return arrayFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param e9  The ninth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param e9  The ninth element from which to construct an array.\n     * @param e10 The tenth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1    The first element from which to construct an array.\n     * @param e2    The second element from which to construct an array.\n     * @param e3    The third element from which to construct an array.\n     * @param e4    The fourth element from which to construct an array.\n     * @param e5    The fifth element from which to construct an array.\n     * @param e6    The sixth element from which to construct an array.\n     * @param e7    The seventh element from which to construct an array.\n     * @param e8    The eighth element from which to construct an array.\n     * @param e9    The ninth element from which to construct an array.\n     * @param e10   The tenth element from which to construct an array.\n     * @param e11on The remaining elements from which to construct an array.\n     * @param <E>   The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return arrayFrom(iterableBuilderWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10).and(e11on).build());\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} containing no elements. When asked to\n     * build an array, the element class will be inferred from the added elements\n     * which means empty arrays and mixed concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = Literals.&lt;Integer&gt;arrayBuilder()\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 4, 5, 6}\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param <E> The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilder() {\n        return new ArrayBuilder<E>();\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * containing no elements. When asked to build an array, the supplied element\n     * class will be used allowing empty arrays and mixed concrete type arrays to\n     * be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = arrayBuilderOf(Integer.class)\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 4, 5, 6}\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderOf(Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied {@code Iterable}. When asked to build an array, the\n     * element class will be inferred from the added elements which means empty arrays\n     * and mixed concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   Integer[] array = arrayBuilderFrom(firstCollection)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ArrayBuilder} should be initialised.\n     * @param <E>      The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(Iterable<E> elements) {\n        return new ArrayBuilder<E>().with(elements);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * initialised with the elements contained in the supplied {@code Iterable}.\n     * When asked to build an array, the supplied element class will be used allowing\n     * empty arrays and mixed concrete type arrays to be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   Integer[] array = arrayBuilderFrom(firstCollection, Integer.class)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ArrayBuilder} should be initialised.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @param <E>      The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(Iterable<? extends E> elements, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elements);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied array. When asked to build an array, the element class\n     * will be inferred from the added elements which means empty arrays and mixed\n     * concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   Integer[] array = arrayBuilderFrom(firstArray)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the {@code ArrayBuilder}\n     *                     should be initialised.\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(E[] elementArray) {\n        return new ArrayBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * initialised with the elements contained in the supplied array. When asked to\n     * build an array, the supplied element class will be used allowing empty arrays\n     * and mixed concrete type arrays to be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   Integer[] array = arrayBuilderFrom(firstArray, Integer.class)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the\n     *                     {@code ArrayBuilder} should be initialised.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied array.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(E[] elementArray, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elementArray);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the\n     * supplied element.\n     *\n     * @param e   The element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         element.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e) {\n        return arrayBuilderFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2) {\n        return arrayBuilderFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9  The ninth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9  The ninth element to be added to the {@code ArrayBuilder}.\n     * @param e10 The tenth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1    The first element to be added to the {@code ArrayBuilder}.\n     * @param e2    The second element to be added to the {@code ArrayBuilder}.\n     * @param e3    The third element to be added to the {@code ArrayBuilder}.\n     * @param e4    The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5    The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6    The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7    The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8    The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9    The ninth element to be added to the {@code ArrayBuilder}.\n     * @param e10   The tenth element to be added to the {@code ArrayBuilder}.\n     * @param e11on The remaining elements to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return arrayBuilderFrom(iterableBuilderWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10).and(e11on).build());\n    }\n\n    public static <R> Single<R> tuple(R first) {\n        return new Single<R>(first);\n    }\n\n    public static <R, S> Pair<R, S> tuple(R first, S second) {\n        return new Pair<R, S>(first, second);\n    }\n\n    public static <R, S, T> Triple<R, S, T> tuple(R first, S second, T third) {\n        return new Triple<R, S, T>(first, second, third);\n    }\n\n    public static <R, S, T, U> Quadruple<R, S, T, U> tuple(R first, S second, T third, U fourth) {\n        return new Quadruple<R, S, T, U>(first, second, third, fourth);\n    }\n\n    public static <R, S, T, U, V> Quintuple<R, S, T, U, V> tuple(R first, S second, T third, U fourth, V fifth) {\n        return new Quintuple<R, S, T, U, V>(first, second, third, fourth, fifth);\n    }\n\n    public static <R, S, T, U, V, W> Sextuple<R, S, T, U, V, W> tuple(R first, S second, T third, U fourth, V fifth, W sixth) {\n        return new Sextuple<R, S, T, U, V, W>(first, second, third, fourth, fifth, sixth);\n    }\n\n    public static <R, S, T, U, V, W, X> Septuple<R, S, T, U, V, W, X> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh) {\n        return new Septuple<R, S, T, U, V, W, X>(first, second, third, fourth, fifth, sixth, seventh);\n    }\n\n    public static <R, S, T, U, V, W, X, Y> Octuple<R, S, T, U, V, W, X, Y> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh, Y eighth) {\n        return new Octuple<R, S, T, U, V, W, X, Y>(first, second, third, fourth, fifth, sixth, seventh, eighth);\n    }\n\n    public static <R, S, T, U, V, W, X, Y, Z> Nonuple<R, S, T, U, V, W, X, Y, Z> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh, Y eighth, Z ninth) {\n        return new Nonuple<R, S, T, U, V, W, X, Y, Z>(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth);\n    }\n\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e) { return iterableFrom(asList(e)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2) { return iterableFrom(asList(e1, e2)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3) { return iterableFrom(asList(e1, e2, e3)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4) { return iterableFrom(asList(e1, e2, e3, e4)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5) { return iterableFrom(asList(e1, e2, e3, e4, e5)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iterableBuilderFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build(); }\n\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e) { return iterableBuilderFrom(iterableWith(e)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2) { return iterableBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3) { return iterableBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Iterator<E> iteratorWith(E e) { return iteratorFrom(iterableWith(e)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2) { return iteratorFrom(iterableWith(e1, e2)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3) { return iteratorFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4) { return iteratorFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e) { return iteratorBuilderFrom(iterableWith(e)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2) { return iteratorBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3) { return iteratorBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Collection<E> collectionWith(E e) { return collectionFrom(iterableWith(e)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2) { return collectionFrom(iterableWith(e1, e2)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3) { return collectionFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4) { return collectionFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e) { return collectionBuilderFrom(iterableWith(e)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2) { return collectionBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3) { return collectionBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> SetBuilder<E> setBuilderWith(E e) { return setBuilderFrom(iterableWith(e)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2) { return setBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3) { return setBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4) { return setBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11on) { return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Multiset<E> multisetWith(E e) { return multisetFrom(iterableWith(e)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2) { return multisetFrom(iterableWith(e1, e2)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3) { return multisetFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4) { return multisetFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e) { return multisetBuilderFrom(iterableWith(e)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2) { return multisetBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3) { return multisetBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <K, V> Map<K, V> mapWith(K k1, V v1) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9), mapEntryFor(k10, v10)).build(); }\n\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1) { return mapFromEntries(iterableWith(e1)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2) { return mapFromEntries(iterableWith(e1, e2)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3) { return mapFromEntries(iterableWith(e1, e2, e3)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4) { return mapFromEntries(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10, Map.Entry<K, V>... e11on) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).and(e11on).build(); }\n\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1) { return mapFromTuples(iterableWith(e1)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2) { return mapFromTuples(iterableWith(e1, e2)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3) { return mapFromTuples(iterableWith(e1, e2, e3)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4) { return mapFromTuples(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10, Pair<K, V>... e11on) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).andPairs(e11on).build(); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9), mapEntryFor(k10, v10)); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1) { return mapBuilderFromEntries(iterableWith(e1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2) { return mapBuilderFromEntries(iterableWith(e1, e2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3) { return mapBuilderFromEntries(iterableWith(e1, e2, e3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10, Map.Entry<K, V>... e11on) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).and(e11on); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1) { return mapBuilderFromTuples(iterableWith(e1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2) { return mapBuilderFromTuples(iterableWith(e1, e2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3) { return mapBuilderFromTuples(iterableWith(e1, e2, e3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10, Pair<K, V>... e11on) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).andPairs(e11on); }\n}\n","new_contents":"\/*\n * Copyright (C) 2011-Present Funk committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\/\npackage org.javafunk.funk;\n\nimport com.google.common.collect.Multiset;\nimport org.javafunk.funk.builders.*;\nimport org.javafunk.funk.datastructures.tuples.*;\n\nimport java.util.*;\n\nimport static java.util.Arrays.asList;\n\npublic class Literals {\n    private Literals() {}\n\n    public static <E> Iterable<E> iterable() {\n        return new IterableBuilder<E>().build();\n    }\n\n    public static <E> Iterable<E> iterableOf(Class<E> elementClass) {\n        return new IterableBuilder<E>().build();\n    }\n\n    public static <E> Iterable<E> iterableFrom(Iterable<? extends E> elements) {\n        return new IterableBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Iterable<E> iterableFrom(E[] elementArray) {\n        return new IterableBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilder() {\n        return new IterableBuilder<E>();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderOf(Class<E> elementClass) {\n        return new IterableBuilder<E>();\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderFrom(Iterable<? extends E> elements) {\n        return new IterableBuilder<E>().with(elements);\n    }\n\n    public static <E> IterableBuilder<E> iterableBuilderFrom(E[] elementArray) {\n        return new IterableBuilder<E>().with(elementArray);\n    }\n\n    public static <E> Iterator<E> iterator() {\n        return new IteratorBuilder<E>().build();\n    }\n\n    public static <E> Iterator<E> iteratorOf(Class<E> elementClass) {\n        return new IteratorBuilder<E>().build();\n    }\n\n    public static <E> Iterator<E> iteratorFrom(Iterable<? extends E> elements) {\n        return new IteratorBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Iterator<E> iteratorFrom(E[] elementArray) {\n        return new IteratorBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilder() {\n        return new IteratorBuilder<E>();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderOf(Class<E> elementClass) {\n        return new IteratorBuilder<E>();\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderFrom(Iterable<? extends E> elements) {\n        return new IteratorBuilder<E>().with(elements);\n    }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderFrom(E[] elementArray) {\n        return new IteratorBuilder<E>().with(elementArray);\n    }\n\n    public static <E> Collection<E> collection() {\n        return new CollectionBuilder<E>().build();\n    }\n\n    public static <E> Collection<E> collectionOf(Class<E> elementClass) {\n        return new CollectionBuilder<E>().build();\n    }\n\n    public static <E> Collection<E> collectionFrom(Iterable<? extends E> elements) {\n        return new CollectionBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Collection<E> collectionFrom(E[] elementArray) {\n        return new CollectionBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilder() {\n        return new CollectionBuilder<E>();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderOf(Class<E> elementClass) {\n        return new CollectionBuilder<E>();\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderFrom(Iterable<? extends E> elements) {\n        return new CollectionBuilder<E>().with(elements);\n    }\n\n    public static <E> CollectionBuilder<E> collectionBuilderFrom(E[] elementArray) {\n        return new CollectionBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns an empty mutable {@code List} instance.\n     *\n     * <p>This form of literal is most suited to direct assignment to a variable\n     * since in this case, the type {@code E} is inferred from the variable\n     * declaration. For example:\n     * <blockquote>\n     * <pre>\n     *   List&lt;String&gt; strings = list();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param <E> The type of the elements contained in the {@code List}.\n     * @return A {@code List} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> List<E> list() {\n        return new ListBuilder<E>().build();\n    }\n\n    \/**\n     * Returns an empty mutable {@code List} instance over the type\n     * of the supplied {@code Class}.\n     *\n     * <p>This form of literal is most suited to inline usage such as when passing an\n     * empty list as a parameter in a method call since it reads more clearly than\n     * {@link #list()}. For example, compare the following:\n     * <blockquote>\n     * <pre>\n     *   public class Calculation {\n     *       public Calculation(Type type, List&lt;Integer&gt; values) {\n     *           ...\n     *       }\n     *\n     *       ...\n     *   }\n     *\n     *   Calculation sum1 = new Calculation(Type.SUM, Literals.&lt;Integer&gt;list());\n     *   Calculation sum2 = new Calculation(Type.SUM, listOf(Integer.class));\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code List}\n     * @param <E>          The type of the elements contained in the {@code List}.\n     * @return A {@code List} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> List<E> listOf(Class<E> elementClass) {\n        return new ListBuilder<E>().build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * {@code List} is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>This form of literal is useful when a number of lazy operations have been\n     * performed resulting in an {@code Iterable} where a collection implementing\n     * the {@code List} contract is required. For example:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Person&gt; people = Literals.listWith(firstPerson, secondPerson, thirdPerson);\n     *   Iterable&lt;Address&gt; addresses = Lazily.map(people, toAddress());\n     *   Iterable&lt;StreetName&gt; streetNames = Lazily.map(addresses, toStreetName());\n     *   Iterable&lt;StreetName&gt; avenueStreetNames = Lazily.filter(streetNames, whereIsAvenue());\n     *   List&lt;StreetName&gt; listOfAvenues = Literals.listFrom(avenueStreetNames);\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which a {@code List} should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned {@code List}.\n     * @return A {@code List} over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     *\/\n    public static <E> List<E> listFrom(Iterable<? extends E> elements) {\n        return new ListBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting {@code List}\n     * is the same as the order of the elements in the array.\n     *\n     * <p>For example, the following:\n     * <blockquote>\n     * <pre>\n     *   String[] strings = new String[]{\"one\", \"two\", \"three\"};\n     *   List&lt;String&gt; listOfStrings = Literals.listFrom(strings);\n     * <\/pre>\n     * <\/blockquote>\n     * is equivalent to:\n     * <blockquote>\n     * <pre>\n     *   List&ltString&gt; listOfStrings = Literals.listWith(\"one\", \"two\", \"three\");\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementArray An array of elements from which a {@code List} should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned {@code List}.\n     * @return A {@code List} over the type {@code E} containing all elements from the\n     *         supplied array in the same order as the supplied array.\n     *\/\n    public static <E> List<E> listFrom(E[] elementArray) {\n        return new ListBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   An element from which to construct a {@code List}.\n     * @param <E> The type of the element contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> List<E> listWith(E e) {\n        return listFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2) {\n        return listFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3) {\n        return listFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4) {\n        return listFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param e9  The ninth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * @param e1  The first element from which to construct a {@code List}.\n     * @param e2  The second element from which to construct a {@code List}.\n     * @param e3  The third element from which to construct a {@code List}.\n     * @param e4  The fourth element from which to construct a {@code List}.\n     * @param e5  The fifth element from which to construct a {@code List}.\n     * @param e6  The sixth element from which to construct a {@code List}.\n     * @param e7  The seventh element from which to construct a {@code List}.\n     * @param e8  The eighth element from which to construct a {@code List}.\n     * @param e9  The ninth element from which to construct a {@code List}.\n     * @param e10 The tenth element from which to construct a {@code List}.\n     * @param <E> The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return listFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code List} instance over the type {@code E} containing the supplied elements.\n     * The order of the resultant {@code List} is the same as the order of the elements in the\n     * argument list.\n     *\n     * <p>Note that this literal uses a generic varargs parameter as the last argument in the\n     * argument list and as such will cause unchecked cast warnings. Explicit argument\n     * lists for up to ten arguments have been provided for convenience. In order to avoid\n     * the unchecked cast warnings, a {@link ListBuilder} can be used instead.<\/p>\n     *\n     * @param e1    The first element from which to construct a {@code List}.\n     * @param e2    The second element from which to construct a {@code List}.\n     * @param e3    The third element from which to construct a {@code List}.\n     * @param e4    The fourth element from which to construct a {@code List}.\n     * @param e5    The fifth element from which to construct a {@code List}.\n     * @param e6    The sixth element from which to construct a {@code List}.\n     * @param e7    The seventh element from which to construct a {@code List}.\n     * @param e8    The eighth element from which to construct a {@code List}.\n     * @param e9    The ninth element from which to construct a {@code List}.\n     * @param e10   The tenth element from which to construct a {@code List}.\n     * @param e11on The remaining elements from which to construct a {@code List}.\n     * @param <E>   The type of the elements contained in the returned {@code List}.\n     * @return A {@code List} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> List<E> listWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} as follows:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.&lt;Integer&gt;listBuilder()\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 4, 5, 6);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param <E> The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilder() {\n        return new ListBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over the type of the supplied {@code Class}\n     * containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} as follows:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = listBuilderOf(Integer.class)\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 4, 5, 6);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ListBuilder}\n     * @param <E>          The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing no\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderOf(Class<E> elementClass) {\n        return new ListBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied {@code Iterable}.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   List&lt;Integer&gt; list = listBuilderFrom(firstCollection)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ListBuilder} should be initialised.\n     * @param <E>      The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ListBuilder<E> listBuilderFrom(Iterable<? extends E> elements) {\n        return new ListBuilder<E>().with(elements);\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied array.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code ListBuilder} can be used to assemble a {@code List} from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   List&lt;Integer&gt; list = listBuilderFrom(firstArray)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   List&lt;Integer&gt; list = Literals.listWith(1, 2, 3, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ListBuilder} is that the list can be built up from\n     * individual objects, arrays or existing iterables. See {@link ListBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the\n     *                     {@code ListBuilder} should be initialised.\n     * @param <E>          The type of the elements contained in the {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ListBuilder<E> listBuilderFrom(E[] elementArray) {\n        return new ListBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   The element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         element.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e) {\n        return listBuilderFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2) {\n        return listBuilderFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3) {\n        return listBuilderFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param e9  The ninth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * @param e1  The first element to be added to the {@code ListBuilder}.\n     * @param e2  The second element to be added to the {@code ListBuilder}.\n     * @param e3  The third element to be added to the {@code ListBuilder}.\n     * @param e4  The fourth element to be added to the {@code ListBuilder}.\n     * @param e5  The fifth element to be added to the {@code ListBuilder}.\n     * @param e6  The sixth element to be added to the {@code ListBuilder}.\n     * @param e7  The seventh element to be added to the {@code ListBuilder}.\n     * @param e8  The eighth element to be added to the {@code ListBuilder}.\n     * @param e9  The ninth element to be added to the {@code ListBuilder}.\n     * @param e10 The tenth element to be added to the {@code ListBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code ListBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ListBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that this literal uses a generic varargs parameter as the last argument in the\n     * argument list and as such will cause unchecked cast warnings. Explicit argument\n     * lists for up to ten arguments have been provided for convenience. In order to avoid\n     * the unchecked cast warnings, a {@link ListBuilder} instance can be used directly with\n     * multiple method calls accumulating the builder contents.<\/p>\n     *\n     * @param e1    The first element to be added to the {@code ListBuilder}.\n     * @param e2    The second element to be added to the {@code ListBuilder}.\n     * @param e3    The third element to be added to the {@code ListBuilder}.\n     * @param e4    The fourth element to be added to the {@code ListBuilder}.\n     * @param e5    The fifth element to be added to the {@code ListBuilder}.\n     * @param e6    The sixth element to be added to the {@code ListBuilder}.\n     * @param e7    The seventh element to be added to the {@code ListBuilder}.\n     * @param e8    The eighth element to be added to the {@code ListBuilder}.\n     * @param e9    The ninth element to be added to the {@code ListBuilder}.\n     * @param e10   The tenth element to be added to the {@code ListBuilder}.\n     * @param e11on The remaining elements to be added to the {@code ListBuilder}. The elements\n     *              will be added to the {@code ListBuilder} in the order they are defined in the\n     *              argument list.\n     * @param <E>   The type of the elements contained in the returned {@code ListBuilder}.\n     * @return A {@code ListBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ListBuilder<E> listBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return listBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on));\n    }\n\n    \/**\n     * Returns an empty mutable {@code Set} instance.\n     *\n     * <p>This form of literal is most suited to direct assignment to a variable\n     * since in this case, the type {@code E} is inferred from the variable\n     * declaration. For example:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;String&gt; strings = set();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param <E> The type of the elements contained in the {@code Set}.\n     * @return A {@code Set} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> Set<E> set() {\n        return new SetBuilder<E>().build();\n    }\n\n    \/**\n     * Returns an empty mutable {@code Set} instance over the type\n     * of the supplied {@code Class}.\n     *\n     * <p>This form of literal is most suited to inline usage such as when passing an\n     * empty set as a parameter in a method call since it reads more clearly than\n     * {@link #set()}. For example, compare the following:\n     * <blockquote>\n     * <pre>\n     *   public class OrderRepository {\n     *       public void save(Customer customer, Set&lt;LineItem&gt; lineItems) {\n     *           ...\n     *       }\n     *\n     *       ...\n     *   }\n     *\n     *   orderRepository.save(customer, Literals.&lt;LineItem&gt;set());\n     *   orderRepository.save(customer, setOf(LineItem.class));\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code Set}.\n     * @param <E>          The type of the elements contained in the {@code List}.\n     * @return A {@code Set} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> Set<E> setOf(Class<E> elementClass) {\n        return new SetBuilder<E>().build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. Due to the nature of a {@code Set}, any\n     * duplicate elements in the supplied {@code Iterable} will be removed.\n     *\n     * <p>This form of literal is useful when a number of lazy operations have been\n     * performed resulting in an {@code Iterable} where a collection implementing\n     * the {@code Set} contract is required. For example:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Person&gt; people = Literals.setWith(firstPerson, secondPerson, thirdPerson);\n     *   Iterable&lt;Address&gt; addresses = Lazily.map(people, toAddress());\n     *   Iterable&lt;StreetName&gt; streetNames = Lazily.map(addresses, toStreetName());\n     *   Iterable&lt;StreetName&gt; avenueStreetNames = Lazily.filter(streetNames, whereIsAvenue());\n     *   Set&lt;StreetName&gt; relevantAvenues = Literals.setFrom(avenueStreetNames);\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which a {@code Set} should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned {@code Set}.\n     * @return A {@code Set} over the type {@code E} containing all unique elements from the\n     *         supplied {@code Iterable}.\n     *\/\n    public static <E> Set<E> setFrom(Iterable<? extends E> elements) {\n        return new SetBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing all elements\n     * from the supplied array. Due to the nature of a {@code Set}, any\n     * duplicate elements in the supplied {@code Iterable} will be removed.\n     *\n     * <p>For example, the following:\n     * <blockquote>\n     * <pre>\n     *   String[] strings = new String[]{\"one\", \"two\", \"two\", \"three\"};\n     *   Set&lt;String&gt; setOfStrings = Literals.setFrom(strings);\n     * <\/pre>\n     * <\/blockquote>\n     * is equivalent to:\n     * <blockquote>\n     * <pre>\n     *   Set&ltString&gt; listOfStrings = Literals.setWith(\"one\", \"two\", \"three\");\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param elementArray An array of elements from which a {@code Set} should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned {@code Set}.\n     * @return A {@code Set} over the type {@code E} containing all unique elements from the\n     *         supplied array.\n     *\/\n    public static <E> Set<E> setFrom(E[] elementArray) {\n        return new SetBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied element.\n     *\n     * @param e   An element from which to construct a {@code Set}.\n     * @param <E> The type of the element contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> Set<E> setWith(E e) {\n        return setFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2) {\n        return setFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3) {\n        return setFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4) {\n        return setFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param e9  The ninth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1  The first element from which to construct a {@code Set}.\n     * @param e2  The second element from which to construct a {@code Set}.\n     * @param e3  The third element from which to construct a {@code Set}.\n     * @param e4  The fourth element from which to construct a {@code Set}.\n     * @param e5  The fifth element from which to construct a {@code Set}.\n     * @param e6  The sixth element from which to construct a {@code Set}.\n     * @param e7  The seventh element from which to construct a {@code Set}.\n     * @param e8  The eighth element from which to construct a {@code Set}.\n     * @param e9  The ninth element from which to construct a {@code Set}.\n     * @param e10 The tenth element from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return setFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code Set} instance over the type {@code E} containing the supplied elements.\n     * Due to the nature of a {@code Set}, any supplied duplicate elements will be removed.\n     *\n     * @param e1    The first element from which to construct a {@code Set}.\n     * @param e2    The second element from which to construct a {@code Set}.\n     * @param e3    The third element from which to construct a {@code Set}.\n     * @param e4    The fourth element from which to construct a {@code Set}.\n     * @param e5    The fifth element from which to construct a {@code Set}.\n     * @param e6    The sixth element from which to construct a {@code Set}.\n     * @param e7    The seventh element from which to construct a {@code Set}.\n     * @param e8    The eighth element from which to construct a {@code Set}.\n     * @param e9    The ninth element from which to construct a {@code Set}.\n     * @param e10   The tenth element from which to construct a {@code Set}.\n     * @param e11on The remaining elements from which to construct a {@code Set}.\n     * @param <E> The type of the elements contained in the returned {@code Set}.\n     * @return A {@code Set} instance over type {@code E} containing the supplied elements.\n     *\/\n    public static <E> Set<E> setWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11on) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build();\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code SetBuilder} can be used to assemble a {@code Set} as follows:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Double&gt; set = Literals.&lt;Double&gt;setBuilder()\n     *           .with(1.56, 2.33, 3.1)\n     *           .and(4.04, 5.3, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Double&gt; set = Literals.setWith(4.04, 2.33, 3.1, 5.3, 6, 1.56);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code SetBuilder} is that the set can be built up from\n     * individual objects, arrays or existing iterables. See {@link SetBuilder} for\n     * further details.\n     *\n     * @param <E> The type of the elements contained in the {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilder() {\n        return new SetBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} over the type of the supplied {@code Class}\n     * containing no elements.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code SetBuilder} can be used to assemble a {@code Set} as follows:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Integer&gt; set = setBuilderOf(Integer.class)\n     *           .with(1, 1, 2)\n     *           .and(4, 5, 5)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Integer&gt; set = Literals.setWith(1, 1, 2, 4, 5, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code SetBuilder} is that the set can be built up from\n     * individual objects, arrays or existing iterables. See {@link SetBuilder} for\n     * further details.\n     *\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code SetBuilder}\n     * @param <E>          The type of the elements contained in the {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over the type {@code E} containing no\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderOf(Class<E> elementClass) {\n        return new SetBuilder<E>();\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied {@code Iterable}.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code SetBuilder} can be used to assemble a {@code Set} from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   Set&lt;Integer&gt; set = setBuilderFrom(firstCollection)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Integer&gt; set = Literals.setWith(1, 2, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code SetBuilder} is that the set can be built up from\n     * individual objects, arrays or existing iterables. See {@link SetBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code SetBuilder} should be initialised.\n     * @param <E>      The type of the elements contained in the {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> SetBuilder<E> setBuilderFrom(Iterable<? extends E> elements) {\n        return new SetBuilder<E>().with(elements);\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied array.\n     *\n     * <h4>Example Usage:<\/h4>\n     * A {@code SetBuilder} can be used to assemble a {@code Set} from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   Set&lt;Integer&gt; set = setBuilderFrom(firstArray)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Set&lt;Integer&gt; set = Literals.setWith(1, 2, 3, 4, 5);\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code SetBuilder} is that the set can be built up from\n     * individual objects, arrays or existing iterables. See {@link SetBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the\n     *                     {@code SetBuilder} should be initialised.\n     * @param <E>          The type of the elements contained in the {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> SetBuilder<E> setBuilderFrom(E[] elementArray) {\n        return new SetBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * element.\n     *\n     * @param e   The element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         element.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e) {\n        return setBuilderFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2) {\n        return setBuilderFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3) {\n        return setBuilderFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param e6  The sixth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param e6  The sixth element to be added to the {@code SetBuilder}.\n     * @param e7  The seventh element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param e6  The sixth element to be added to the {@code SetBuilder}.\n     * @param e7  The seventh element to be added to the {@code SetBuilder}.\n     * @param e8  The eighth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param e6  The sixth element to be added to the {@code SetBuilder}.\n     * @param e7  The seventh element to be added to the {@code SetBuilder}.\n     * @param e8  The eighth element to be added to the {@code SetBuilder}.\n     * @param e9  The ninth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1  The first element to be added to the {@code SetBuilder}.\n     * @param e2  The second element to be added to the {@code SetBuilder}.\n     * @param e3  The third element to be added to the {@code SetBuilder}.\n     * @param e4  The fourth element to be added to the {@code SetBuilder}.\n     * @param e5  The fifth element to be added to the {@code SetBuilder}.\n     * @param e6  The sixth element to be added to the {@code SetBuilder}.\n     * @param e7  The seventh element to be added to the {@code SetBuilder}.\n     * @param e8  The eighth element to be added to the {@code SetBuilder}.\n     * @param e9  The ninth element to be added to the {@code SetBuilder}.\n     * @param e10 The tenth element to be added to the {@code SetBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns a {@code SetBuilder} instance over the type {@code E} containing the supplied\n     * elements. Due to the nature of a {@code Set}, any supplied duplicate elements will be\n     * removed.\n     *\n     * @param e1    The first element to be added to the {@code SetBuilder}.\n     * @param e2    The second element to be added to the {@code SetBuilder}.\n     * @param e3    The third element to be added to the {@code SetBuilder}.\n     * @param e4    The fourth element to be added to the {@code SetBuilder}.\n     * @param e5    The fifth element to be added to the {@code SetBuilder}.\n     * @param e6    The sixth element to be added to the {@code SetBuilder}.\n     * @param e7    The seventh element to be added to the {@code SetBuilder}.\n     * @param e8    The eighth element to be added to the {@code SetBuilder}.\n     * @param e9    The ninth element to be added to the {@code SetBuilder}.\n     * @param e10   The tenth element to be added to the {@code SetBuilder}.\n     * @param e11on The remaining elements to be added to the {@code SetBuilder}.\n     * @param <E>   The type of the elements contained in the returned {@code SetBuilder}.\n     * @return A {@code SetBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> SetBuilder<E> setBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11on) {\n        return setBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on));\n    }\n\n    public static <E> Multiset<E> multiset() {\n        return new MultisetBuilder<E>().build();\n    }\n\n    public static <E> Multiset<E> multisetOf(Class<E> elementClass) {\n        return new MultisetBuilder<E>().build();\n    }\n\n    public static <E> Multiset<E> multisetFrom(Iterable<? extends E> elements) {\n        return new MultisetBuilder<E>().with(elements).build();\n    }\n\n    public static <E> Multiset<E> multisetFrom(E[] elementArray) {\n        return new MultisetBuilder<E>().with(elementArray).build();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilder() {\n        return new MultisetBuilder<E>();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderOf(Class<E> elementClass) {\n        return new MultisetBuilder<E>();\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderFrom(Iterable<? extends E> elements) {\n        return new MultisetBuilder<E>().with(elements);\n    }\n\n    public static <E> MultisetBuilder<E> multisetBuilderFrom(E[] elementArray) {\n        return new MultisetBuilder<E>().with(elementArray);\n    }\n\n    public static <K, V> Map<K, V> map() {\n        return new MapBuilder<K, V>().build();\n    }\n\n    public static <K, V> Map<K, V> mapOf(Class<K> keyClass, Class<V> valueClass) {\n        return new MapBuilder<K, V>().build();\n    }\n\n    public static <K, V> Map<K, V> mapFromEntries(Iterable<? extends Map.Entry<K, V>> elements) {\n        return new MapBuilder<K, V>().with(elements).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromEntries(Map.Entry<K, V>[] elementArray) {\n        return new MapBuilder<K, V>().with(elementArray).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromTuples(Iterable<? extends Pair<K, V>> elements) {\n        return new MapBuilder<K, V>().withPairs(elements).build();\n    }\n\n    public static <K, V> Map<K, V> mapFromTuples(Pair<K, V>[] elementArray) {\n        return new MapBuilder<K, V>().withPairs(elementArray).build();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilder() {\n        return new MapBuilder<K, V>();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderOf(Class<K> keyClass, Class<V> valueClass) {\n        return new MapBuilder<K, V>();\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromEntries(Iterable<? extends Map.Entry<K, V>> entries) {\n        return new MapBuilder<K, V>().with(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromEntries(Map.Entry<K, V>[] entries) {\n        return new MapBuilder<K, V>().with(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromTuples(Iterable<? extends Pair<K, V>> entries) {\n        return new MapBuilder<K, V>().withPairs(entries);\n    }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderFromTuples(Pair<K, V>[] entries) {\n        return new MapBuilder<K, V>().withPairs(entries);\n    }\n\n    public static <K, V> Map.Entry<K, V> mapEntryFor(K key, V value) {\n        return new AbstractMap.SimpleEntry<K, V>(key, value);\n    }\n\n    public static <K, V> Map.Entry<K, V> mapEntryFor(Pair<K, V> pair) {\n        return new AbstractMap.SimpleEntry<K, V>(pair.first(), pair.second());\n    }\n\n    \/**\n     * Returns an empty array instance over the type {@code E}.\n     *\n     * @param <E> The type of the elements that would be contained by this array\n     *            if it contained any.\n     * @return An array instance over the type {@code E} containing no elements.\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E[] arrayOf(Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * array is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>The supplied {@code Iterable} must contain at least one element so that\n     * the type E can be correctly inferred when constructing the array. In the\n     * case that the {@code Iterable} is empty, an {@code IllegalArgumentException}\n     * will be thrown.<\/p>\n     *\n     * <p>The elements in the supplied {@code Iterable} must all be of the same\n     * concrete type so that the type E can be inferred deterministically when\n     * constructing the array. In the case that the {@code Iterable} contains\n     * elements of different concrete types, an {@code IllegalArgumentException}\n     * will be thrown. If an array containing multiple concrete types of some\n     * supertype is required, use the {@link #arrayFrom(Iterable, Class)}\n     * variant.<\/p>\n     *\n     * @param elements An {@code Iterable} of elements from which an array should be\n     *                 constructed.\n     * @param <E>      The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     * @throws IllegalArgumentException if the supplied {@code Iterable} contains no\n     *                                  elements or contains elements of different\n     *                                  concrete types.\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E[] arrayFrom(Iterable<E> elements) {\n        return new ArrayBuilder<E>().with(elements).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied {@code Iterable}. The order of the elements in the resulting\n     * array is determined by the order in which they are yielded from the\n     * {@code Iterable}.\n     *\n     * <p>Unlike {@link #arrayFrom(Iterable)}, this variant accepts empty\n     * {@code Iterable}s and {@code Iterable}s containing instances of different\n     * concrete types and so should be used in preference of {@link #arrayFrom(Iterable)}\n     * if such {@code Iterable}s are expected.<\/p>\n     *\n     * <h4>Example Usage:<\/h4>\n     * Assume that we have the following instances:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *   Iterable&lt;Employee&gt; employees = iterableWith(partTimeEmployee, fullTimeEmployee, hourlyEmployee);\n     * <\/pre>\n     * <\/blockquote>\n     * If we attempt to construct an array directly from the {@code Iterable}, an\n     * {@code IllegalArgumentException} will be thrown:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees); \/\/ => IllegalArgumentException\n     * <\/pre>\n     * <\/blockquote>\n     * However using this variant, we obtain an array of {@code Employee} instances. The following\n     * two arrays are equivalent:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees, Employee.class);\n     *   Employee[] employeeArray = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     *\n     * @param elements     An {@code Iterable} of elements from which an array should be\n     *                     constructed.\n     * @param elementClass A {@code Class} representing the required type {@code E} of\n     *                     the resultant array.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied {@code Iterable} in the order they are yielded.\n     *\/\n    public static <E> E[] arrayFrom(Iterable<? extends E> elements, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elements).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting\n     * array is the same as the order of elements in the supplied array.\n     *\n     * <p>The supplied array must contain at least one element so that the type E\n     * can be correctly inferred when constructing the array to return. In the\n     * case that the array is empty, an {@code IllegalArgumentException}\n     * will be thrown.<\/p>\n     *\n     * <p>The elements in the supplied array must all be of the same\n     * concrete type so that the type E can be inferred deterministically when\n     * constructing the array. In the case that the array contains\n     * elements of different concrete types, an {@code IllegalArgumentException}\n     * will be thrown. If an array containing multiple concrete types of some\n     * supertype is required, use the {@link #arrayFrom(Object[], Class)}\n     * variant.<\/p>\n     *\n     * @param elementArray An array of elements from which an array should be\n     *                     constructed.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied array in the same order as the supplied array.\n     * @throws IllegalArgumentException if the supplied {@code Iterable} contains no\n     *                                  elements or contains elements of different\n     *                                  concrete types.\n     *\/\n    public static <E> E[] arrayFrom(E[] elementArray) {\n        return new ArrayBuilder<E>().with(elementArray).build();\n    }\n\n    \/**\n     * Returns an array instance over the type {@code E} containing all elements\n     * from the supplied array. The order of the elements in the resulting\n     * array is the same as the order of elements in the supplied array.\n     *\n     * <p>Unlike {@link #arrayFrom(Object[])}, this variant accepts empty\n     * arrays and arrays containing instances of different concrete types and\n     * so should be used in preference of {@link #arrayFrom(Object[])}\n     * if such arrays are expected.<\/p>\n     *\n     * <h4>Example Usage:<\/h4>\n     * Assume that we have the following instances:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *   Employee[] employees = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     * If we attempt to construct an array directly from the array, an\n     * {@code IllegalArgumentException} will be thrown:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees); \/\/ => IllegalArgumentException\n     * <\/pre>\n     * <\/blockquote>\n     * However using this variant, we obtain an array of {@code Employee} instances. The following\n     * two arrays are equivalent:\n     * <blockquote>\n     * <pre>\n     *   Employee[] employeeArray = Literals.arrayFrom(employees, Employee.class);\n     *   Employee[] employeeArray = new Employee[]{partTimeEmployee, fullTimeEmployee, hourlyEmployee};\n     * <\/pre>\n     * <\/blockquote>\n     *\n     * @param elementArray An array of elements from which an array should be constructed.\n     * @param elementClass A {@code Class} representing the required type {@code E} of\n     *                     the resultant array.\n     * @param <E>          The type of the elements to be contained in the returned array.\n     * @return An array over the type {@code E} containing all elements from the\n     *         supplied array in the same order.\n     *\/\n    public static <E> E[] arrayFrom(E[] elementArray, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elementArray).build();\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied element.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e   An element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e) {\n        return arrayFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2) {\n        return arrayFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3) {\n        return arrayFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param e9  The ninth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1  The first element from which to construct an array.\n     * @param e2  The second element from which to construct an array.\n     * @param e3  The third element from which to construct an array.\n     * @param e4  The fourth element from which to construct an array.\n     * @param e5  The fifth element from which to construct an array.\n     * @param e6  The sixth element from which to construct an array.\n     * @param e7  The seventh element from which to construct an array.\n     * @param e8  The eighth element from which to construct an array.\n     * @param e9  The ninth element from which to construct an array.\n     * @param e10 The tenth element from which to construct an array.\n     * @param <E> The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return arrayFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns an array over the type {@code E} containing the supplied elements.\n     *\n     * <p>The {@code arrayWith} literals are useful in cases such as when an API\n     * is written to accept arrays of objects as arguments where a varargs style\n     * is more appropriate.<\/p>\n     *\n     * @param e1    The first element from which to construct an array.\n     * @param e2    The second element from which to construct an array.\n     * @param e3    The third element from which to construct an array.\n     * @param e4    The fourth element from which to construct an array.\n     * @param e5    The fifth element from which to construct an array.\n     * @param e6    The sixth element from which to construct an array.\n     * @param e7    The seventh element from which to construct an array.\n     * @param e8    The eighth element from which to construct an array.\n     * @param e9    The ninth element from which to construct an array.\n     * @param e10   The tenth element from which to construct an array.\n     * @param e11on The remaining elements from which to construct an array.\n     * @param <E>   The type of the element contained in the returned array.\n     * @return An array instance over type {@code E} containing the supplied element.\n     *\/\n    public static <E> E[] arrayWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return arrayFrom(iterableBuilderWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10).and(e11on).build());\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} containing no elements. When asked to\n     * build an array, the element class will be inferred from the added elements\n     * which means empty arrays and mixed concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = Literals.&lt;Integer&gt;arrayBuilder()\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 4, 5, 6}\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param <E> The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilder() {\n        return new ArrayBuilder<E>();\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * containing no elements. When asked to build an array, the supplied element\n     * class will be used allowing empty arrays and mixed concrete type arrays to\n     * be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = arrayBuilderOf(Integer.class)\n     *           .with(1, 2, 3)\n     *           .and(4, 5, 6)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 4, 5, 6}\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing no elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderOf(Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied {@code Iterable}. When asked to build an array, the\n     * element class will be inferred from the added elements which means empty arrays\n     * and mixed concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   Integer[] array = arrayBuilderFrom(firstCollection)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ArrayBuilder} should be initialised.\n     * @param <E>      The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(Iterable<E> elements) {\n        return new ArrayBuilder<E>().with(elements);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * initialised with the elements contained in the supplied {@code Iterable}.\n     * When asked to build an array, the supplied element class will be used allowing\n     * empty arrays and mixed concrete type arrays to be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * {@code Collection} instances as follows:\n     * <blockquote>\n     * <pre>\n     *   Collection&lt;Integer&gt; firstCollection = Literals.collectionWith(1, 2, 3);\n     *   Collection&lt;Integer&gt; secondCollection = Literals.collectionWith(3, 4, 5);\n     *   Integer[] array = arrayBuilderFrom(firstCollection, Integer.class)\n     *           .with(secondCollection)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elements An {@code Iterable} containing elements with which the\n     *                 {@code ArrayBuilder} should be initialised.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @param <E>      The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(Iterable<? extends E> elements, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elements);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over type {@code E} initialised with the elements\n     * contained in the supplied array. When asked to build an array, the element class\n     * will be inferred from the added elements which means empty arrays and mixed\n     * concrete type arrays cannot be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   Integer[] array = arrayBuilderFrom(firstArray)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the {@code ArrayBuilder}\n     *                     should be initialised.\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied {@code Iterable}.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(E[] elementArray) {\n        return new ArrayBuilder<E>().with(elementArray);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} over the type of the supplied {@code Class}\n     * initialised with the elements contained in the supplied array. When asked to\n     * build an array, the supplied element class will be used allowing empty arrays\n     * and mixed concrete type arrays to be constructed.\n     *\n     * <h4>Example Usage:<\/h4>\n     * An {@code ArrayBuilder} can be used to assemble an array from two existing\n     * arrays as follows:\n     * <blockquote>\n     * <pre>\n     *   Integer[] firstArray = new Integer[]{1, 2, 3};\n     *   Integer[] secondArray = new Integer[]{3, 4, 5};\n     *   Integer[] array = arrayBuilderFrom(firstArray, Integer.class)\n     *           .with(secondArray)\n     *           .build()\n     * <\/pre>\n     * <\/blockquote>\n     * This is equivalent to the following:\n     * <blockquote>\n     * <pre>\n     *   Integer[] array = new Integer[]{1, 2, 3, 3, 4, 5};\n     * <\/pre>\n     * <\/blockquote>\n     * The advantage of the {@code ArrayBuilder} is that the array can be built up from\n     * individual objects, iterables or existing arrays. See {@link ArrayBuilder} for\n     * further details.\n     *\n     * @param elementArray An array containing elements with which the\n     *                     {@code ArrayBuilder} should be initialised.\n     * @param elementClass A {@code Class} representing the type of elements\n     *                     contained in this {@code ArrayBuilder} and the type represented\n     *                     by the built array.\n     * @param <E>          The type of the elements contained in the {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over the type {@code E} containing\n     *         the elements from the supplied array.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderFrom(E[] elementArray, Class<E> elementClass) {\n        return new ArrayBuilder<E>(elementClass).with(elementArray);\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the\n     * supplied element.\n     *\n     * @param e   The element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         element.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e) {\n        return arrayBuilderFrom(iterableWith(e));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2) {\n        return arrayBuilderFrom(iterableWith(e1, e2));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9  The ninth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1  The first element to be added to the {@code ArrayBuilder}.\n     * @param e2  The second element to be added to the {@code ArrayBuilder}.\n     * @param e3  The third element to be added to the {@code ArrayBuilder}.\n     * @param e4  The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5  The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6  The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7  The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8  The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9  The ninth element to be added to the {@code ArrayBuilder}.\n     * @param e10 The tenth element to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n        return arrayBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));\n    }\n\n    \/**\n     * Returns an {@code ArrayBuilder} instance over the type {@code E} containing the supplied\n     * elements. The supplied elements are added to the {@code ArrayBuilder} instance in the same\n     * order as they are defined in the argument list.\n     *\n     * <p>Note that due to type erasure, the supplied elements must all be of the same concrete\n     * type otherwise the array cannot be instantiated. If an array needs to be constructed\n     * from elements of different concrete types, use an {@code ArrayBuilder} directly, passing\n     * in the class of the elements to be contained in the resulting array. For example:\n     * <blockquote>\n     * <pre>\n     *   PartTimeEmployee partTimeEmployee = new PartTimeEmployee(\"Designer\", \"John\");\n     *   FullTimeEmployee fullTimeEmployee = new FullTimeEmployee(\"Manufacturer\", \"Fred\");\n     *   HourlyEmployee hourlyEmployee = new HourlyEmployee(\"Materials Consultant\", \"Andy\");\n     *\n     *   Employee[] employees = arrayBuilderOf(Employee.class)\n     *          .with(partTimeEmployee, fullTimeEmployee, hourlyEmployee)\n     *          .build();\n     * <\/pre>\n     * <\/blockquote>\n     * <\/p>\n     *\n     * @param e1    The first element to be added to the {@code ArrayBuilder}.\n     * @param e2    The second element to be added to the {@code ArrayBuilder}.\n     * @param e3    The third element to be added to the {@code ArrayBuilder}.\n     * @param e4    The fourth element to be added to the {@code ArrayBuilder}.\n     * @param e5    The fifth element to be added to the {@code ArrayBuilder}.\n     * @param e6    The sixth element to be added to the {@code ArrayBuilder}.\n     * @param e7    The seventh element to be added to the {@code ArrayBuilder}.\n     * @param e8    The eighth element to be added to the {@code ArrayBuilder}.\n     * @param e9    The ninth element to be added to the {@code ArrayBuilder}.\n     * @param e10   The tenth element to be added to the {@code ArrayBuilder}.\n     * @param e11on The remaining elements to be added to the {@code ArrayBuilder}.\n     * @param <E> The type of the elements contained in the returned {@code ArrayBuilder}.\n     * @return An {@code ArrayBuilder} instance over type {@code E} containing the supplied\n     *         elements.\n     *\/\n    public static <E> ArrayBuilder<E> arrayBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) {\n        return arrayBuilderFrom(iterableBuilderWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10).and(e11on).build());\n    }\n\n    public static <R> Single<R> tuple(R first) {\n        return new Single<R>(first);\n    }\n\n    public static <R, S> Pair<R, S> tuple(R first, S second) {\n        return new Pair<R, S>(first, second);\n    }\n\n    public static <R, S, T> Triple<R, S, T> tuple(R first, S second, T third) {\n        return new Triple<R, S, T>(first, second, third);\n    }\n\n    public static <R, S, T, U> Quadruple<R, S, T, U> tuple(R first, S second, T third, U fourth) {\n        return new Quadruple<R, S, T, U>(first, second, third, fourth);\n    }\n\n    public static <R, S, T, U, V> Quintuple<R, S, T, U, V> tuple(R first, S second, T third, U fourth, V fifth) {\n        return new Quintuple<R, S, T, U, V>(first, second, third, fourth, fifth);\n    }\n\n    public static <R, S, T, U, V, W> Sextuple<R, S, T, U, V, W> tuple(R first, S second, T third, U fourth, V fifth, W sixth) {\n        return new Sextuple<R, S, T, U, V, W>(first, second, third, fourth, fifth, sixth);\n    }\n\n    public static <R, S, T, U, V, W, X> Septuple<R, S, T, U, V, W, X> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh) {\n        return new Septuple<R, S, T, U, V, W, X>(first, second, third, fourth, fifth, sixth, seventh);\n    }\n\n    public static <R, S, T, U, V, W, X, Y> Octuple<R, S, T, U, V, W, X, Y> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh, Y eighth) {\n        return new Octuple<R, S, T, U, V, W, X, Y>(first, second, third, fourth, fifth, sixth, seventh, eighth);\n    }\n\n    public static <R, S, T, U, V, W, X, Y, Z> Nonuple<R, S, T, U, V, W, X, Y, Z> tuple(R first, S second, T third, U fourth, V fifth, W sixth, X seventh, Y eighth, Z ninth) {\n        return new Nonuple<R, S, T, U, V, W, X, Y, Z>(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth);\n    }\n\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e) { return iterableFrom(asList(e)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2) { return iterableFrom(asList(e1, e2)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3) { return iterableFrom(asList(e1, e2, e3)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4) { return iterableFrom(asList(e1, e2, e3, e4)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5) { return iterableFrom(asList(e1, e2, e3, e4, e5)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iterableFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    @SuppressWarnings(\"unchecked\") public static <E> Iterable<E> iterableWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iterableBuilderFrom(asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(asList(e11on)).build(); }\n\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e) { return iterableBuilderFrom(iterableWith(e)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2) { return iterableBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3) { return iterableBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> IterableBuilder<E> iterableBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iterableBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Iterator<E> iteratorWith(E e) { return iteratorFrom(iterableWith(e)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2) { return iteratorFrom(iterableWith(e1, e2)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3) { return iteratorFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4) { return iteratorFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iteratorFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Iterator<E> iteratorWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e) { return iteratorBuilderFrom(iterableWith(e)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2) { return iteratorBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3) { return iteratorBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> IteratorBuilder<E> iteratorBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return iteratorBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Collection<E> collectionWith(E e) { return collectionFrom(iterableWith(e)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2) { return collectionFrom(iterableWith(e1, e2)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3) { return collectionFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4) { return collectionFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return collectionFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Collection<E> collectionWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e) { return collectionBuilderFrom(iterableWith(e)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2) { return collectionBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3) { return collectionBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> CollectionBuilder<E> collectionBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return collectionBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <E> Multiset<E> multisetWith(E e) { return multisetFrom(iterableWith(e)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2) { return multisetFrom(iterableWith(e1, e2)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3) { return multisetFrom(iterableWith(e1, e2, e3)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4) { return multisetFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return multisetFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> Multiset<E> multisetWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on).build(); }\n\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e) { return multisetBuilderFrom(iterableWith(e)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2) { return multisetBuilderFrom(iterableWith(e1, e2)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3) { return multisetBuilderFrom(iterableWith(e1, e2, e3)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <E> MultisetBuilder<E> multisetBuilderWith(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E... e11on) { return multisetBuilderFrom(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).with(e11on); }\n\n    public static <K, V> Map<K, V> mapWith(K k1, V v1) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9)).build(); }\n    public static <K, V> Map<K, V> mapWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9), mapEntryFor(k10, v10)).build(); }\n\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1) { return mapFromEntries(iterableWith(e1)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2) { return mapFromEntries(iterableWith(e1, e2)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3) { return mapFromEntries(iterableWith(e1, e2, e3)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4) { return mapFromEntries(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10) { return mapFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> Map<K, V> mapWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10, Map.Entry<K, V>... e11on) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).and(e11on).build(); }\n\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1) { return mapFromTuples(iterableWith(e1)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2) { return mapFromTuples(iterableWith(e1, e2)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3) { return mapFromTuples(iterableWith(e1, e2, e3)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4) { return mapFromTuples(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10) { return mapFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> Map<K, V> mapWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10, Pair<K, V>... e11on) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).andPairs(e11on).build(); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) { return new MapBuilder<K, V>().with(mapEntryFor(k1, v1), mapEntryFor(k2, v2), mapEntryFor(k3, v3), mapEntryFor(k4, v4), mapEntryFor(k5, v5), mapEntryFor(k6, v6), mapEntryFor(k7, v7), mapEntryFor(k8, v8), mapEntryFor(k9, v9), mapEntryFor(k10, v10)); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1) { return mapBuilderFromEntries(iterableWith(e1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2) { return mapBuilderFromEntries(iterableWith(e1, e2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3) { return mapBuilderFromEntries(iterableWith(e1, e2, e3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Map.Entry<K, V> e1, Map.Entry<K, V> e2, Map.Entry<K, V> e3, Map.Entry<K, V> e4, Map.Entry<K, V> e5, Map.Entry<K, V> e6, Map.Entry<K, V> e7, Map.Entry<K, V> e8, Map.Entry<K, V> e9, Map.Entry<K, V> e10, Map.Entry<K, V>... e11on) { return mapBuilderFromEntries(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).and(e11on); }\n\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1) { return mapBuilderFromTuples(iterableWith(e1)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2) { return mapBuilderFromTuples(iterableWith(e1, e2)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3) { return mapBuilderFromTuples(iterableWith(e1, e2, e3)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)); }\n    public static <K, V> MapBuilder<K, V> mapBuilderWith(Pair<K, V> e1, Pair<K, V> e2, Pair<K, V> e3, Pair<K, V> e4, Pair<K, V> e5, Pair<K, V> e6, Pair<K, V> e7, Pair<K, V> e8, Pair<K, V> e9, Pair<K, V> e10, Pair<K, V>... e11on) { return mapBuilderFromTuples(iterableWith(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10)).andPairs(e11on); }\n}\n","subject":"","message":"Adding Javadoc to all set builder literals.\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"funk","url":"https:\/\/github.com\/javafunk\/funk","stars":33,"test_cases":{},"commit":"f5b0375db1c7cf3b7f1cfa3b03405ebb7b3347fe","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"bae87f9a9bc5307ad6bcc5c7468dbe8a394583fc","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"ab5b0be8d84d8aae062c2f270cacb2baec1c5462","old_file":"everrest-bean-validation\/src\/test\/java\/org\/everrest\/validation\/TestValidation.java","new_file":"everrest-bean-validation\/src\/test\/java\/org\/everrest\/validation\/TestValidation.java","old_contents":"","new_contents":"package org.everrest.validation;\r\n\r\nimport static java.lang.annotation.ElementType.METHOD;\r\nimport static java.lang.annotation.ElementType.PARAMETER;\r\nimport static java.lang.annotation.ElementType.TYPE;\r\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.Serializable;\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.Target;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Type;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.validation.Constraint;\r\nimport javax.validation.ConstraintValidator;\r\nimport javax.validation.ConstraintValidatorContext;\r\nimport javax.validation.Payload;\r\nimport javax.validation.Valid;\r\nimport javax.validation.constraints.NotNull;\r\nimport javax.validation.constraints.Pattern;\r\nimport javax.validation.constraints.Size;\r\nimport javax.validation.constraintvalidation.SupportedValidationTarget;\r\nimport javax.validation.constraintvalidation.ValidationTarget;\r\nimport javax.ws.rs.Consumes;\r\nimport javax.ws.rs.CookieParam;\r\nimport javax.ws.rs.FormParam;\r\nimport javax.ws.rs.GET;\r\nimport javax.ws.rs.HeaderParam;\r\nimport javax.ws.rs.MatrixParam;\r\nimport javax.ws.rs.POST;\r\nimport javax.ws.rs.Path;\r\nimport javax.ws.rs.PathParam;\r\nimport javax.ws.rs.Produces;\r\nimport javax.ws.rs.QueryParam;\r\nimport javax.ws.rs.WebApplicationException;\r\nimport javax.ws.rs.core.Cookie;\r\nimport javax.ws.rs.core.HttpHeaders;\r\nimport javax.ws.rs.core.MediaType;\r\nimport javax.ws.rs.core.MultivaluedMap;\r\nimport javax.ws.rs.ext.MessageBodyReader;\r\nimport javax.ws.rs.ext.MessageBodyWriter;\r\nimport javax.ws.rs.ext.Provider;\r\n\r\nimport junit.framework.Assert;\r\n\r\nimport org.junit.Test;\r\n\r\n\r\npublic class TestValidation\r\n{\r\n\r\n   @Path(\"\/\")\r\n   public static class TestResourceWithValidField\r\n   {\r\n      @Size(min=2, max=4)\r\n      private String s = \"abc\";\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   @Path(\"\/\")\r\n   public static class TestResourceWithInvalidField\r\n   {\r\n      @Size(min=2, max=4)\r\n      private String s = \"abcde\";\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\")\r\n   public static class TestResourceWithProperty\r\n   {\r\n      private String s;\r\n\r\n      @POST\r\n      @Path(\"{unused}\")\r\n      public void post()\r\n      {\r\n      }\r\n\r\n      @Size(min=2, max=4)  \r\n      public String getS()\r\n      {\r\n         return s;\r\n      }\r\n\r\n      @PathParam(\"s\") \r\n      public void setS(String s)\r\n      {\r\n         this.s = s;\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\/{t}\")\r\n   public static class TestResourceWithFieldAndProperty\r\n   {\r\n      @Size(min=2, max=4)\r\n      @PathParam(\"s\")\r\n      private String s;\r\n\r\n      private String t;\r\n\r\n      @Size(min=3, max=5)  \r\n      public String getT()\r\n      {\r\n         return t;\r\n      }\r\n\r\n      @PathParam(\"t\") \r\n      public void setT(String t)\r\n      {\r\n         this.t = t;\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   public static class TestClassValidator implements ConstraintValidator<TestClassConstraint, TestResourceWithClassConstraint>\r\n   {\r\n      int length;\r\n\r\n      public void initialize(TestClassConstraint constraintAnnotation)\r\n      {\r\n         length = constraintAnnotation.value();\r\n      }\r\n\r\n      public boolean isValid(TestResourceWithClassConstraint value, ConstraintValidatorContext context)\r\n      {\r\n         return value.s.length() + value.t.length() >= length;\r\n      }\r\n\r\n   }\r\n\r\n   @Documented\r\n   @Constraint(validatedBy = TestClassValidator.class)\r\n   @Target({TYPE})\r\n   @Retention(RUNTIME)\r\n   public @interface TestClassConstraint {\r\n      String message() default \"Concatenation of s and t must have length > {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      int value();\r\n   }\r\n\r\n   @Path(\"\/{s}\/{t}\")\r\n   @TestClassConstraint(5)\r\n   public static class TestResourceWithClassConstraint\r\n   {\r\n      @NotNull String s;\r\n      @NotNull String t;\r\n\r\n      public TestResourceWithClassConstraint(@PathParam(\"s\") String s, @PathParam(\"t\") String t)\r\n      {\r\n         this.s = s;\r\n         this.t = t;  \r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n\r\n      public String toString()\r\n      {\r\n         return \"TestResourceWithClassConstraint(\\\"\" + s + \"\\\", \\\"\" + t + \"\\\")\";\r\n      }\r\n   }\r\n\r\n   public static class A\r\n   {\r\n      @Size(min=4) String s1;\r\n      @Size(min=5) String s2;\r\n\r\n      public A(String s1, String s2)\r\n      {\r\n         this.s1 = s1;\r\n         this.s2 = s2;\r\n      }\r\n      public void setS2(String s)\r\n      {\r\n         this.s2 = s;\r\n      }\r\n      public String getS2()\r\n      {\r\n         return s2;\r\n      }\r\n   }\r\n\r\n   public static class B\r\n   {\r\n      @Valid A a;\r\n\r\n      public B(A a) {this.a = a;}\r\n   }\r\n\r\n   @Path(\"\/{s}\/{t}\")\r\n   public static class TestResourceWithGraph\r\n   {\r\n      @Valid B b;\r\n\r\n      public TestResourceWithGraph(@PathParam(\"s\") String s, @PathParam(\"t\") String t)\r\n      {\r\n         b = new B(new A(s, t));\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   public static class OneString\r\n   {\r\n      @Size(min=5) String s;\r\n\r\n      public OneString(String s)\r\n      {\r\n         this.s = s;\r\n      }\r\n      public String getS()\r\n      {\r\n         return s;\r\n      }\r\n      public void setString(String s)\r\n      {\r\n         this.s = s;\r\n      }\r\n   }\r\n\r\n   public static class ArrayOfStrings\r\n   {\r\n      @Valid OneString[] strings;\r\n\r\n      public ArrayOfStrings(String s)\r\n      {\r\n         strings = new OneString[]{new OneString(s)};\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\")\r\n   public static class TestResourceWithArray\r\n   {\r\n      @Valid ArrayOfStrings aos;\r\n\r\n\r\n      public TestResourceWithArray(@PathParam(\"s\") String s)\r\n      {\r\n         aos = new ArrayOfStrings(s);\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   public static class ListOfStrings\r\n   {\r\n      @Valid List<OneString> strings;\r\n\r\n      public ListOfStrings(String s)\r\n      {\r\n         strings = new ArrayList<OneString>();\r\n         strings.add(new OneString(s));\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\")\r\n   public static class TestResourceWithList\r\n   {\r\n      @Valid ListOfStrings los;\r\n\r\n      public TestResourceWithList(@PathParam(\"s\") String s)\r\n      {\r\n         los = new ListOfStrings(s);\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   public static class MapOfStrings\r\n   {\r\n      @Valid Map<String,OneString> strings;\r\n\r\n      public MapOfStrings(String s)\r\n      {\r\n         strings = new HashMap<String,OneString>();\r\n         strings.put(s, new OneString(s));\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\")\r\n   public static class TestResourceWithMap\r\n   {\r\n      @Valid MapOfStrings mos;\r\n\r\n      public TestResourceWithMap(@PathParam(\"s\") String s)\r\n      {\r\n         mos = new MapOfStrings(s);\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   public static class ListOfArrayOfStrings\r\n   {\r\n      @Valid List<ArrayOfStrings> list;\r\n\r\n      public ListOfArrayOfStrings(String s)\r\n      {\r\n         list = new ArrayList<ArrayOfStrings>();\r\n         list.add(new ArrayOfStrings(s));\r\n      }\r\n   }\r\n\r\n   public static class MapOfListOfArrayOfStrings\r\n   {\r\n      @Valid Map<String, ListOfArrayOfStrings> map;\r\n\r\n      public MapOfListOfArrayOfStrings(String s)\r\n      {\r\n         map = new HashMap<String, ListOfArrayOfStrings>();\r\n         map.put(s, new ListOfArrayOfStrings(s));\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\")\r\n   public static class TestResourceWithMapOfListOfArrayOfStrings\r\n   {\r\n      @Valid MapOfListOfArrayOfStrings mlas;\r\n\r\n      public TestResourceWithMapOfListOfArrayOfStrings(@PathParam(\"s\") String s)\r\n      {\r\n         mlas = new MapOfListOfArrayOfStrings(s);\r\n      }\r\n\r\n      @POST\r\n      public void post()\r\n      {\r\n      }\r\n   }\r\n\r\n   @FooConstraint(min=1,max=3)\r\n   public static class Foo implements Serializable\r\n   {\r\n      private static final long serialVersionUID = -1068336400309384949L;\r\n      private String s;\r\n\r\n      public Foo(String s)\r\n      {\r\n         this.s = s;\r\n      }\r\n      public String toString()\r\n      {\r\n         return \"Foo[\" + s + \"]\";\r\n      }\r\n      public boolean equals(Object o)\r\n      {\r\n         if (o == null || !(o instanceof Foo))\r\n         {\r\n            return false;\r\n         }\r\n         return this.s.equals(Foo.class.cast(o).s);\r\n      }\r\n   }\r\n\r\n   public static class FooValidator implements ConstraintValidator<FooConstraint, Foo>\r\n   {\r\n      int min;\r\n      int max;\r\n\r\n      public void initialize(FooConstraint constraintAnnotation)\r\n      {\r\n         min = constraintAnnotation.min();\r\n         max = constraintAnnotation.max();\r\n      }\r\n      public boolean isValid(Foo value, ConstraintValidatorContext context)\r\n      {\r\n         return min <= value.s.length() && value.s.length() <= max;\r\n      }\r\n   }\r\n\r\n   @Documented\r\n   @Constraint(validatedBy = FooValidator.class)\r\n   @Target({TYPE,PARAMETER,METHOD})\r\n   @Retention(RUNTIME)\r\n   public @interface FooConstraint {\r\n      String message() default \"s must have length: {min} <= length <= {max}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      int min();\r\n      int max();\r\n   }\r\n\r\n   @Provider\r\n   @Produces(\"application\/foo\")\r\n   @Consumes(\"application\/foo\")\r\n   public static class FooReaderWriter implements MessageBodyReader<Foo>, MessageBodyWriter<Foo>\r\n   {\r\n      public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)\r\n      {\r\n         return Foo.class.equals(type);\r\n      }\r\n      public long getSize(Foo t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)\r\n      {\r\n         return -1;\r\n      }\r\n      public void writeTo(Foo t, Class<?> type, Type genericType,\r\n            Annotation[] annotations, MediaType mediaType,\r\n            MultivaluedMap<String, Object> httpHeaders,\r\n            OutputStream entityStream) throws IOException,\r\n            WebApplicationException\r\n      {\r\n    \t  byte[] b = t.s.getBytes();\r\n    \t  entityStream.write(b.length);\r\n    \t  entityStream.write(t.s.getBytes());\r\n    \t  entityStream.flush();\r\n      }\r\n      public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)\r\n      {\r\n         return Foo.class.equals(type);\r\n      }\r\n      public Foo readFrom(Class<Foo> type, Type genericType,\r\n            Annotation[] annotations, MediaType mediaType,\r\n            MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException\r\n      {\r\n    \t  int length = entityStream.read();\r\n    \t  byte[] b = new byte[length]; \r\n    \t  entityStream.read(b);\r\n    \t  String s = new String(b);\r\n    \t  return new Foo(s);\r\n      }\r\n   }\r\n\r\n   @Path(\"\/\")\r\n   public static class TestResourceWithParameters\r\n   {  \r\n      @POST\r\n      @Path(\"\/native\")\r\n      public void postNative(@Valid Foo foo)\r\n      {\r\n      }\r\n\r\n      @POST\r\n      @Path(\"\/imposed\")\r\n      public void postImposed(@FooConstraint(min=3,max=5) Foo foo)\r\n      {\r\n      }\r\n\r\n      @POST\r\n      @Path(\"nativeAndImposed\")\r\n      public void postNativeAndImposed(@Valid @FooConstraint(min=3,max=5) Foo foo)\r\n      {\r\n      }\r\n      \r\n      @POST\r\n      @Path(\"other\/{p}\")\r\n      public void postOther(@Size(min=2,max=3) @PathParam(\"p\")   String p,\r\n    \t\t                @Size(min=2,max=3) @MatrixParam(\"m\") String m,\r\n    \t\t                @Size(min=2,max=3) @QueryParam(\"q\")  String q,\r\n    \t\t                @Size(min=2,max=3) @FormParam(\"f\")   String f,\r\n    \t\t                @Size(min=2,max=3) @HeaderParam(\"h\") String h,\r\n    \t\t                @Size(min=2,max=3) @CookieParam(\"c\") String c\r\n    \t\t                )\r\n      {\r\n      }\r\n   }\r\n\r\n   @Path(\"\/\")\r\n   public static class TestResourceWithReturnValues\r\n   {  \r\n      @POST\r\n      @Path(\"\/native\")\r\n      @Valid\r\n      public Foo postNative(Foo foo)\r\n      {\r\n         return foo;\r\n      }\r\n\r\n      @POST\r\n      @Path(\"\/imposed\")\r\n      @FooConstraint(min=3,max=5)\r\n      public Foo postImposed(Foo foo)\r\n      {\r\n         return foo;\r\n      }\r\n      \r\n      @POST\r\n      @Path(\"nativeAndImposed\")\r\n      @Valid\r\n      @FooConstraint(min=3,max=5)\r\n      public Foo postNativeAndImposed(Foo foo)\r\n      {\r\n         return foo;\r\n      }\r\n   }\r\n   \r\n   public static class TestClassValidator2 implements ConstraintValidator<TestClassConstraint2, TestResourceWithAllFivePotentialViolations>\r\n   {\r\n      int length;\r\n\r\n      public void initialize(TestClassConstraint2 constraintAnnotation)\r\n      {\r\n         length = constraintAnnotation.value();\r\n      }\r\n\r\n      public boolean isValid(TestResourceWithAllFivePotentialViolations value, ConstraintValidatorContext context)\r\n      {\r\n         return value.s.length() + value.t.length() >= length;\r\n      }\r\n\r\n   }\r\n\r\n   @Documented\r\n   @Constraint(validatedBy = TestClassValidator2.class)\r\n   @Target({TYPE})\r\n   @Retention(RUNTIME)\r\n   public @interface TestClassConstraint2 {\r\n      String message() default \"Concatenation of s and t must have length > {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      int value();\r\n   }\r\n   \r\n   @Path(\"\/{s}\/{t}\")\r\n   @TestClassConstraint2(5)\r\n   public static class TestResourceWithAllFivePotentialViolations\r\n   {\r\n      @Size(min=2, max=4)\r\n      @PathParam(\"s\")\r\n      private String s;\r\n\r\n      private String t;\r\n\r\n      @Size(min=3, max=5)  \r\n      public String getT()\r\n      {\r\n         return t;\r\n      }\r\n\r\n      @PathParam(\"t\") \r\n      public void setT(String t)\r\n      {\r\n         this.t = t;\r\n      }\r\n\r\n      @POST\r\n      @Path(\"{unused}\/{unused}\")\r\n      @FooConstraint(min=4,max=5)\r\n      public Foo post( @FooConstraint(min=3,max=5) Foo foo)\r\n      {\r\n         return foo;\r\n      }\r\n   }\r\n   \r\n   @Documented\r\n   @Constraint(validatedBy = TestClassValidatorSubInheritance.class)\r\n   @Target({TYPE})\r\n   @Retention(RUNTIME)\r\n   public @interface TestClassInheritanceSubConstraint {\r\n      String message() default \"u must have value {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      String value();\r\n   }\r\n   \r\n   @Documented\r\n   @Constraint(validatedBy = TestClassValidatorSuperInheritance.class)\r\n   @Target({TYPE})\r\n   @Retention(RUNTIME)\r\n   public @interface TestClassInheritanceSuperConstraint {\r\n      String message() default \"t must have length > {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      int value();\r\n   }\r\n   \r\n   public static class TestClassValidatorSubInheritance implements ConstraintValidator<TestClassInheritanceSubConstraint, InterfaceTestSub>\r\n   {\r\n      String pattern;\r\n\r\n      public void initialize(TestClassInheritanceSubConstraint constraintAnnotation)\r\n      {\r\n         pattern = constraintAnnotation.value();\r\n      }\r\n\r\n      public boolean isValid(InterfaceTestSub value, ConstraintValidatorContext context)\r\n      {\r\n         System.out.println(this + \"u: \" + value.u);\r\n         System.out.println(\"pattern: \" + pattern + \", matches: \" + value.u.matches(pattern));\r\n         return value.u.matches(pattern);\r\n      }\r\n   }\r\n   \r\n   public static class TestClassValidatorSuperInheritance implements ConstraintValidator<TestClassInheritanceSuperConstraint, InterfaceTestSuper>\r\n   {\r\n      int length;\r\n\r\n      public void initialize(TestClassInheritanceSuperConstraint constraintAnnotation)\r\n      {\r\n         length = constraintAnnotation.value();\r\n      }\r\n\r\n      public boolean isValid(InterfaceTestSuper value, ConstraintValidatorContext context)\r\n      {\r\n         System.out.println(this + \" t: \" + value.t);\r\n         return value.t.length() >= length;\r\n      }\r\n   }\r\n   \r\n   @Path(\"\/\")\r\n   public interface InterfaceTest\r\n   {\r\n      @Path(\"\/inherit\")\r\n      @POST\r\n      @Size(min=2,max=3) String postInherit(@Size(min=2,max=4) String s);\r\n      \r\n      @Path(\"\/override\")\r\n      @POST\r\n      @Size(min=2,max=3) String postOverride(@Size(min=2,max=4) String s);\r\n   }\r\n   \r\n   @Path(\"\/\")\r\n   @TestClassInheritanceSuperConstraint(3)\r\n   public static class InterfaceTestSuper implements InterfaceTest\r\n   {\r\n\/\/      @PathParam(\"t\")\r\n      static String t;\r\n      \r\n\t   public String postInherit(String s)\r\n\t   {\r\n\t\t   return s;\r\n\t   }\r\n\t   public String postOverride(String s)\r\n\t   {\r\n\t\t   return s;\r\n\t   }\r\n\t   public String concat()\r\n\t   {\r\n\t      return t + t;\r\n\t   }\r\n   }\r\n   \r\n   @Path(\"\/\")\r\n   @TestClassInheritanceSubConstraint(\"[a-c]+\")\r\n   public static class InterfaceTestSub extends InterfaceTestSuper\r\n   {\r\n\/\/      @PathParam(\"u\")\r\n      static String u;\r\n      \r\n\t   @Pattern(regexp=\"[a-c]+\") public String postOverride(String s)\r\n\t   {\r\n\t\t   return s;\r\n\t   }\r\n   }\r\n   \r\n   @Path(\"\/\")\r\n   public static class TestResourceWithSubLocators\r\n   {  \r\n      @Path(\"validField\")\r\n      public TestResourceWithValidField validField()\r\n      {\r\n         return new TestResourceWithValidField();\r\n      }\r\n      \r\n      @Path(\"invalidField\")\r\n      public TestResourceWithInvalidField invalidField()\r\n      {\r\n         return new TestResourceWithInvalidField();\r\n      }\r\n      \r\n      @Path(\"property\/{s}\")\r\n      public TestResourceWithProperty property(@PathParam(\"s\") String s)\r\n      {\r\n         TestResourceWithProperty subResource = new TestResourceWithProperty();\r\n         subResource.setS(s);\r\n         return subResource;\r\n      }\r\n      \r\n      @Path(\"locator\")\r\n      public SubResource sub()\r\n      {\r\n         System.out.println(\"return new SubResource()\");\r\n         return new SubResource();\r\n      }\r\n      \r\n      @Path(\"everything\/{s}\/{t}\")\r\n      public TestResourceWithAllFivePotentialViolations everything(@PathParam(\"s\") String s, @PathParam(\"t\") String t)\r\n      {\r\n         TestResourceWithAllFivePotentialViolations subresource = new TestResourceWithAllFivePotentialViolations();\r\n         try\r\n         {\r\n            Field field = TestResourceWithAllFivePotentialViolations.class.getDeclaredField(\"s\");\r\n            field.setAccessible(true);\r\n            field.set(subresource, s);\r\n            subresource.setT(t);\r\n            return subresource;\r\n         }\r\n         catch (Exception e)\r\n         {\r\n            throw new WebApplicationException(e);\r\n         }\r\n      }\r\n      \r\n      @Path(\"\")\r\n      public static class SubResource\r\n      {\r\n         @Path(\"sublocator\/{s}\")\r\n         public SubSubResource sub(@PathParam(\"s\") String s)\r\n         {\r\n            SubSubResource ssr = new SubSubResource();\r\n            ssr.setS(s);\r\n            System.out.println(\"returning new SubSubResource()\");\r\n            return ssr;\r\n         }\r\n      }\r\n      \r\n      @Path(\"\")\r\n      public static class SubSubResource\r\n      {\r\n         @Size(min=2,max=3) String s;\r\n         \r\n         public SubSubResource()\r\n         {\r\n         }\r\n         \r\n         public void setS(String s)\r\n         {\r\n            this.s = s;\r\n         }\r\n         \r\n         @POST\r\n         public void subSub()\r\n         {\r\n         }\r\n      }\r\n   }\r\n   \r\n\r\n   \r\n   @Documented\r\n   @Constraint(validatedBy = CrossParameterValidator.class)\r\n   @Target({METHOD})\r\n   @Retention(RUNTIME)\r\n   public @interface CrossParameterConstraint\r\n   {\r\n      String message() default \"Parameters must total <= {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      int value();\r\n   }\r\n   \r\n   @SupportedValidationTarget(ValidationTarget.PARAMETERS)\r\n   public static class CrossParameterValidator implements ConstraintValidator<CrossParameterConstraint, Object[]>\r\n   {\r\n      private CrossParameterConstraint constraintAnnotation;\r\n      \r\n      @Override\r\n      public void initialize(CrossParameterConstraint constraintAnnotation)\r\n      {\r\n         this.constraintAnnotation = constraintAnnotation;\r\n      }\r\n      @Override\r\n      public boolean isValid(Object[] value, ConstraintValidatorContext context)\r\n      {\r\n         int sum = 0;\r\n         \r\n         for (int i = 0; i < value.length; i++)\r\n         {\r\n            if (!(value[i] instanceof Integer))\r\n            {\r\n               return false;\r\n            }\r\n            sum += Integer.class.cast(value[i]);\r\n         }\r\n         return sum <= constraintAnnotation.value();\r\n      }\r\n   }\r\n\r\n   @Path(\"\/{s}\/{t}\")\r\n   public static class TestSubResourceWithCrossParameterConstraint\r\n   {\r\n      @POST\r\n      @CrossParameterConstraint(7)\r\n      public void test(@PathParam(\"s\") int s, @PathParam(\"t\") int t)\r\n      {\r\n      }\r\n   }\r\n   \r\n\r\n   @Path(\"proxy\")\r\n   public static interface TestProxyInterface\r\n   {\r\n      @GET\r\n      @Produces(\"text\/plain\")\r\n      @Size(min=2, max=4)\r\n      public String g();\r\n      \r\n      @POST\r\n      @Path(\"{s}\")\r\n      public void s(@PathParam(\"s\") String s);\r\n   }\r\n   \r\n   @Path(\"proxy\")\r\n   public static class TestProxyResource implements TestProxyInterface\r\n   {\r\n      static private String s;\r\n      \r\n      @GET\r\n      @Produces(\"text\/plain\")\r\n      @Size(min=2, max=4)\r\n      public String g()\r\n      {\r\n         return s;\r\n      }\r\n\r\n      @POST\r\n      @Path(\"{s}\")\r\n      public void s(@PathParam(\"s\") String s)\r\n      {\r\n         TestProxyResource.s = s;\r\n      }\r\n   }\r\n   \r\n  interface OtherGroup {}\r\n   \r\n   @Documented\r\n   @Constraint(validatedBy = TestClassValidator.class)\r\n   @Target({TYPE})\r\n   @Retention(RUNTIME)\r\n   public @interface OtherGroupConstraint\r\n   {\r\n      String message() default \"Concatenation of s and t must have length > {value}\";\r\n      Class<?>[] groups() default {};\r\n      Class<? extends Payload>[] payload() default {};\r\n      String value() default \"\";\r\n   }\r\n   \r\n   public static class OtherGroupValidator<T> implements ConstraintValidator<OtherGroupConstraint, T>\r\n   {\r\n      public void initialize(OtherGroupConstraint constraintAnnotation)\r\n      {\r\n      }\r\n      \r\n      @Override\r\n      public boolean isValid(T value, ConstraintValidatorContext context)\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n   \r\n   @Path(\"\/\")\r\n   @OtherGroupConstraint(groups=OtherGroup.class)\r\n   public static class TestResourceWithOtherGroups\r\n   {\r\n      @Size(min=2, groups=OtherGroup.class)\r\n      String s = \"abc\";\r\n      \r\n      String t;\r\n      \r\n      @POST\r\n      @Path(\"test\/{t}\/{u}\")\r\n      @Size(min=2, groups={OtherGroup.class})\r\n      public String test(@Size(min=2, groups=OtherGroup.class) @PathParam(\"u\") String u)\r\n      {\r\n         return u;\r\n      }\r\n      \r\n      @PathParam(\"t\")\r\n      public void setT(String t)\r\n      {\r\n         this.t = t;\r\n      }\r\n      \r\n      @Size(min=2, groups=OtherGroup.class)\r\n      public String getT()\r\n      {\r\n         return t;\r\n      }\r\n   }\r\n   \r\n\/\/   public static void before(Class<?> resourceClass) throws Exception\r\n\/\/   {\r\n\/\/      after();\r\n\/\/      deployment = EmbeddedContainer.start();\r\n\/\/      dispatcher = deployment.getDispatcher();\r\n\/\/      deployment.getRegistry().addPerRequestResource(resourceClass);\r\n\/\/   }\r\n\/\/\r\n\/\/   public static void beforeFoo(Class<?> resourceClass) throws Exception\r\n\/\/   {\r\n\/\/      before(resourceClass);\r\n\/\/      deployment.getProviderFactory().registerProvider(FooReaderWriter.class);\r\n\/\/      deployment.getProviderFactory().registerProvider(FooReaderWriter.class);\r\n\/\/   }\r\n\/\/\r\n\/\/   public static void beforeFooAsynch(Class<?> resourceClass) throws Exception\r\n\/\/   {\r\n\/\/      ResteasyDeployment deployment = new ResteasyDeployment();\r\n\/\/      deployment.setAsyncJobServiceEnabled(true);\r\n\/\/      EmbeddedContainer.start(deployment);\r\n\/\/      dispatcher = deployment.getDispatcher();\r\n\/\/      dispatcher.getRegistry().addPerRequestResource(resourceClass);\r\n\/\/      deployment.getProviderFactory().registerProvider(FooReaderWriter.class);\r\n\/\/      deployment.getProviderFactory().registerProvider(FooReaderWriter.class);\r\n\/\/   }\r\n\/\/\r\n\/\/   public static void after() throws Exception\r\n\/\/   {\r\n\/\/      EmbeddedContainer.stop();\r\n\/\/      dispatcher = null;\r\n\/\/      deployment = null;\r\n\/\/   }\r\n\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testFieldValid() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithValidField.class);\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testFieldInvalid() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithInvalidField.class);\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity(String.class);\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      System.out.println(\"cv: \" + cv);\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"abcde\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testPropertyValid() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithProperty.class);\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abc\/unused\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testPropertyInvalid() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithProperty.class);\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcdef\/unused\"));\r\n\/\/      ClientResponse<?> response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 1, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"abcdef\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testFieldAndProperty() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithFieldAndProperty.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abc\/wxyz\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/a\/uvwxyz\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 1, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"a\", cv.getValue());\r\n\/\/      cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 3 and 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"uvwxyz\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testClassConstraint() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithClassConstraint.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abc\/xyz\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/a\/b\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 1, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getClassViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"Concatenation of s and t must have length > 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"TestResourceWithClassConstraint(\\\"a\\\", \\\"b\\\")\", cv.getValue());\r\n\/\/      System.out.println(cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testGraph() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithGraph.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcd\/vwxyz\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\/xyz\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 2, 0, 0, 0, 0);\r\n\/\/\r\n\/\/      Iterator<ResteasyConstraintViolation> it = r.getFieldViolations().iterator();\r\n\/\/      ResteasyConstraintViolation cv1 = it.next();\r\n\/\/      ResteasyConstraintViolation cv2 = it.next();\r\n\/\/      if (cv1.getValue().equals(\"xyz\"))\r\n\/\/      {\r\n\/\/         ResteasyConstraintViolation tmp = cv1;\r\n\/\/         cv1 = cv2;\r\n\/\/         cv2 = tmp;\r\n\/\/      }\r\n\/\/      Assert.assertTrue(cv1.getMessage().startsWith(\"size must be between 4 and\"));\r\n\/\/      Assert.assertEquals(\"abc\", cv1.getValue());\r\n\/\/      Assert.assertTrue(cv2.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/      Assert.assertEquals(\"xyz\", cv2.getValue());\r\n\/\/\r\n\/\/\/\/      ResteasyConstraintViolation cv = e.getFieldViolations().iterator().next();\r\n\/\/\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 4 and\"));\r\n\/\/\/\/      Assert.assertEquals(\"abc\", cv.getValue());\r\n\/\/\/\/      cv = e.getPropertyViolations().iterator().next();\r\n\/\/\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/\/\/      Assert.assertEquals(\"xyz\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testArray() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithArray.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcde\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/      Assert.assertEquals(\"abc\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testList() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithList.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcde\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/      Assert.assertEquals(\"abc\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testMap() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithMap.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcde\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/      Assert.assertEquals(\"abc\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testMapOfListOfArrayOfStrings() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithMapOfListOfArrayOfStrings.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abcde\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      System.out.println(\"exception: \" + r);\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().startsWith(\"size must be between 5 and\"));\r\n\/\/      Assert.assertEquals(\"abc\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testParameters() throws Exception\r\n\/\/   {\r\n\/\/      beforeFoo(TestResourceWithParameters.class);\r\n\/\/\r\n\/\/      \/\/ Valid native constraint\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/native\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"a\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Valid imposed constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/imposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcde\"));\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Valid native and imposed constraints.\r\n\/\/      request = new ClientRequest(generateURL(\"\/nativeAndImposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abc\"));\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid native constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/native\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 1, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getParameterViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().equals(\"s must have length: 1 <= length <= 3\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Invalid imposed constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/imposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity();\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 1, 0);\r\n\/\/      cv = r.getParameterViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().equals(\"s must have length: 3 <= length <= 5\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Invalid native and imposed constraints\r\n\/\/      request = new ClientRequest(generateURL(\"\/nativeAndImposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity();\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 2, 0);\r\n\/\/      Iterator<ResteasyConstraintViolation> it = r.getParameterViolations().iterator();\r\n\/\/      ResteasyConstraintViolation cv1 = it.next();\r\n\/\/      ResteasyConstraintViolation cv2 = it.next();\r\n\/\/      if (cv1.toString().indexOf('1') < 0)\r\n\/\/      {\r\n\/\/         ResteasyConstraintViolation temp = cv1;\r\n\/\/         cv1 = cv2;\r\n\/\/         cv2 = temp;\r\n\/\/      }\r\n\/\/      Assert.assertTrue(cv1.getMessage().equals(\"s must have length: 1 <= length <= 3\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv1.getValue());\r\n\/\/      Assert.assertTrue(cv2.getMessage().equals(\"s must have length: 3 <= length <= 5\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv2.getValue());\r\n\/\/\r\n\/\/      \/\/ Valid other parameters\r\n\/\/      String url = generateURL(\"\/other\/ppp\"); \/\/ path param\r\n\/\/      url += \";m=mmm\";                        \/\/ matrix param\r\n\/\/      url += \"?q=qqq\";                        \/\/ query param\r\n\/\/      request = new ClientRequest(url);\r\n\/\/      request.formParameter(\"f\", \"fff\");      \/\/ form param\r\n\/\/      request.header(\"h\", \"hhh\");             \/\/ header param\r\n\/\/      request.cookie(new Cookie(\"c\", \"ccc\")); \/\/ cookie param\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid other parameters\r\n\/\/      url = generateURL(\"\/other\/pppp\");        \/\/ path param\r\n\/\/      url += \";m=mmmm\";                        \/\/ matrix param\r\n\/\/      url += \"?q=qqqq\";                        \/\/ query param\r\n\/\/      request = new ClientRequest(url);\r\n\/\/      request.formParameter(\"f\", \"ffff\");      \/\/ form param\r\n\/\/      request.header(\"h\", \"hhhh\");             \/\/ header param\r\n\/\/      request.cookie(new Cookie(\"c\", \"cccc\")); \/\/ cookie param\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity();\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 6, 0);\r\n\/\/      List<String> list = getMessages(r);\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; pppp\"));\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; mmmm\"));\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; qqqq\"));\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; ffff\"));\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; hhhh\"));\r\n\/\/      Assert.assertTrue(list.contains(\"size must be between 2 and 3; cccc\"));\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testReturnValues() throws Exception\r\n\/\/   {\r\n\/\/      beforeFoo(TestResourceWithReturnValues.class);\r\n\/\/\r\n\/\/      \/\/ Valid native constraint\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/native\"));\r\n\/\/      Foo foo = new Foo(\"a\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      ClientResponse<?> response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Assert.assertEquals(foo, response.getEntity());\r\n\/\/\r\n\/\/      \/\/ Valid imposed constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/imposed\"));\r\n\/\/      foo = new Foo(\"abcde\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Assert.assertEquals(foo, response.getEntity());\r\n\/\/\r\n\/\/      \/\/ Valid native and imposed constraints.\r\n\/\/      request = new ClientRequest(generateURL(\"\/nativeAndImposed\"));\r\n\/\/      foo = new Foo(\"abc\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Assert.assertEquals(foo, response.getEntity());\r\n\/\/\r\n\/\/      \/\/ Invalid native constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/native\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(500, response.getStatus());\r\n\/\/      Object entity = response.getEntity(String.class);\r\n\/\/      System.out.println(\"entity: \" + entity);\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 0, 1);\r\n\/\/      ResteasyConstraintViolation cv = r.getReturnValueViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().equals(\"s must have length: 1 <= length <= 3\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Invalid imposed constraint\r\n\/\/      request = new ClientRequest(generateURL(\"\/imposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(500, response.getStatus());\r\n\/\/      entity = response.getEntity(String.class);\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 0, 1);\r\n\/\/      cv = r.getReturnValueViolations().iterator().next();\r\n\/\/      Assert.assertTrue(cv.getMessage().equals(\"s must have length: 3 <= length <= 5\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Invalid native and imposed constraints\r\n\/\/      request = new ClientRequest(generateURL(\"\/nativeAndImposed\"));\r\n\/\/      request.body(\"application\/foo\", new Foo(\"abcdef\"));\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(500, response.getStatus());\r\n\/\/      entity = response.getEntity(String.class);\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 0, 2);\r\n\/\/      Iterator<ResteasyConstraintViolation> it = r.getReturnValueViolations().iterator();\r\n\/\/      ResteasyConstraintViolation cv1 = it.next();\r\n\/\/      ResteasyConstraintViolation cv2 = it.next();\r\n\/\/      if (cv1.toString().indexOf('1') < 0)\r\n\/\/      {\r\n\/\/         ResteasyConstraintViolation temp = cv1;\r\n\/\/         cv1 = cv2;\r\n\/\/         cv2 = temp;\r\n\/\/      }\r\n\/\/      Assert.assertTrue(cv1.getMessage().equals(\"s must have length: 1 <= length <= 3\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv1.getValue());\r\n\/\/      Assert.assertTrue(cv2.getMessage().equals(\"s must have length: 3 <= length <= 5\"));\r\n\/\/      Assert.assertEquals(\"Foo[abcdef]\", cv2.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testViolationsBeforeReturnValue() throws Exception\r\n\/\/   {\r\n\/\/      beforeFoo(TestResourceWithAllFivePotentialViolations.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/abc\/wxyz\/unused\/unused\"));\r\n\/\/      Foo foo = new Foo(\"pqrs\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      ClientResponse<?> response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Assert.assertEquals(foo, response.getEntity());\r\n\/\/\r\n\/\/      \/\/ Invalid: Should have 1 each of field, property, class, and parameter violations,\r\n\/\/      \/\/          and no return value violations.\r\n\/\/      request = new ClientRequest(generateURL(\"\/a\/z\/unused\/unused\"));\r\n\/\/      foo = new Foo(\"p\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity(String.class);\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 1, 1, 1, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"a\", cv.getValue());\r\n\/\/      cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 3 and 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"z\", cv.getValue());\r\n\/\/      cv = r.getClassViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"Concatenation of s and t must have length > 5\", cv.getMessage());\r\n\/\/      Assert.assertTrue(cv.getValue().startsWith(\"org.everrest.validation.TestValidation$TestResourceWithAllFivePotentialViolations@\"));\r\n\/\/      cv = r.getParameterViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"s must have length: 3 <= length <= 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"Foo[p]\", cv.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testInheritence() throws Exception\r\n\/\/   {\r\n\/\/      before(InterfaceTestSub.class);\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Valid - inherited annotations\r\n\/\/         InterfaceTestSuper.t = \"aaa\";\r\n\/\/         InterfaceTestSub.u = \"bbb\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/inherit\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"ccc\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         Assert.assertEquals(200, response.getStatus());\r\n\/\/         Assert.assertEquals(\"ccc\", response.getEntity());\r\n\/\/      }\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Valid - overridden annotations\r\n\/\/         InterfaceTestSuper.t = \"aaa\";\r\n\/\/         InterfaceTestSub.u = \"bbb\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/override\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"ccc\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         Assert.assertEquals(200, response.getStatus());\r\n\/\/         Assert.assertEquals(\"ccc\", response.getEntity());\r\n\/\/      }\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Invalid - inherited class, parameter annotations\r\n\/\/         InterfaceTestSuper.t = \"a\";\r\n\/\/         InterfaceTestSub.u = \"d\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/inherit\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"e\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         System.out.println(\"status: \" + response.getStatus());\r\n\/\/         Assert.assertEquals(400, response.getStatus());\r\n\/\/         Object entity = response.getEntity();\r\n\/\/         ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/         countViolations(r, 0, 0, 2, 1, 0);\r\n\/\/      }\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Invalid - overridden class, parameter annotations\r\n\/\/         InterfaceTestSuper.t = \"a\";\r\n\/\/         InterfaceTestSub.u = \"d\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/override\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"e\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         System.out.println(\"status: \" + response.getStatus());\r\n\/\/         Assert.assertEquals(400, response.getStatus());\r\n\/\/         Object entity = response.getEntity();\r\n\/\/         ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/         countViolations(r, 0, 0, 2, 1, 0);\r\n\/\/      }\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Invalid - inherited return value annotations\r\n\/\/         InterfaceTestSuper.t = \"aaa\";\r\n\/\/         InterfaceTestSub.u = \"bbb\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/inherit\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"eeee\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         System.out.println(\"status: \" + response.getStatus());\r\n\/\/         Assert.assertEquals(500, response.getStatus());\r\n\/\/         Object entity = response.getEntity();\r\n\/\/         ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/         countViolations(r, 0, 0, 0, 0, 1);\r\n\/\/      }\r\n\/\/\r\n\/\/      {\r\n\/\/         \/\/ Invalid - overridden return value annotations\r\n\/\/         InterfaceTestSuper.t = \"aaa\";\r\n\/\/         InterfaceTestSub.u = \"bbb\";\r\n\/\/         ClientRequest request = new ClientRequest(generateURL(\"\/override\"));\r\n\/\/         request.body(MediaType.TEXT_PLAIN_TYPE, \"eeee\");\r\n\/\/         ClientResponse<?> response = request.post(String.class);\r\n\/\/         System.out.println(\"status: \" + response.getStatus());\r\n\/\/         Assert.assertEquals(500, response.getStatus());\r\n\/\/         Object entity = response.getEntity();\r\n\/\/         ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/         countViolations(r, 0, 0, 0, 0, 2);\r\n\/\/      }\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testLocators() throws Exception\r\n\/\/   {\r\n\/\/      beforeFoo(TestResourceWithSubLocators.class);\r\n\/\/\r\n\/\/      \/\/ Sub-resource locator returns resource with valid field.\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/validField\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Sub-resource locator returns resource with invalid field.\r\n\/\/      request = new ClientRequest(generateURL(\"\/invalidField\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"abcde\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Sub-resource locator returns resource with valid property.\r\n\/\/      \/\/ Note: The resource TestResourceWithProperty has a @PathParam annotation used by a setter,\r\n\/\/      \/\/       but it is not used when TestResourceWithProperty is used a sub-resource.  Hence \"unused\".\r\n\/\/      request = new ClientRequest(generateURL(\"\/property\/abc\/unused\"));\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Sub-resource locator returns resource with invalid property.\r\n\/\/      request = new ClientRequest(generateURL(\"\/property\/abcdef\/unused\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity();\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 1, 0, 0, 0);\r\n\/\/      cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"abcdef\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      request = new ClientRequest(generateURL(\"\/everything\/abc\/wxyz\/unused\/unused\"));\r\n\/\/      Foo foo = new Foo(\"pqrs\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Assert.assertEquals(foo, response.getEntity());\r\n\/\/\r\n\/\/      \/\/ Invalid: Should have 1 each of field, property, class, and parameter violations,and no return value violations.\r\n\/\/      \/\/ Note: expect warning because TestResourceWithAllFivePotentialViolations is being used a sub-resource and it has an injectible field:\r\n\/\/      \/\/       WARN org.jboss.resteasy.core.ResourceLocator - Field s of subresource org.everrest.validation.TestValidation$TestResourceWithAllFivePotentialViolations will not be injected according to spec\r\n\/\/      request = new ClientRequest(generateURL(\"\/everything\/a\/z\/unused\/unused\"));\r\n\/\/      foo = new Foo(\"p\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity(String.class);\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 1, 1, 1, 0);\r\n\/\/      cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"a\", cv.getValue());\r\n\/\/      cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 3 and 5\", cv.getMessage());\r\n\/\/      cv = r.getClassViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"Concatenation of s and t must have length > 5\", cv.getMessage());\r\n\/\/      Assert.assertTrue(cv.getValue().startsWith(\"org.everrest.validation.TestValidation$TestResourceWithAllFivePotentialViolations@\"));\r\n\/\/\r\n\/\/      \/\/ Sub-sub-resource locator returns resource with valid property.\r\n\/\/      request = new ClientRequest(generateURL(\"\/locator\/sublocator\/abc\"));\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Sub-resource locator returns resource with invalid property.\r\n\/\/      request = new ClientRequest(generateURL(\"\/locator\/sublocator\/abcdef\"));\r\n\/\/      response = request.post(String.class);\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      entity = response.getEntity(String.class);\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 0, 0, 0, 0);\r\n\/\/      cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 3\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"abcdef\", cv.getValue());\r\n\/\/\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/\/\/   @Ignore\r\n\/\/   public void testAsynch() throws Exception\r\n\/\/   {\r\n\/\/      beforeFooAsynch(TestResourceWithAllFivePotentialViolations.class);\r\n\/\/\r\n\/\/      \/\/ Submit asynchronous job with violations prior to execution of resource method.\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/a\/z\/unused\/unused?asynch=true\"));\r\n\/\/      Foo foo = new Foo(\"p\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      ClientResponse<?> response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());\r\n\/\/      String jobUrl = response.getResponseHeaders().getFirst(HttpHeaders.LOCATION);\r\n\/\/      System.out.println(\"JOB: \" + jobUrl);\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Get result: Should have 1 each of field, property, class, and parameter violations,\r\n\/\/      \/\/             and no return value violations.\r\n\/\/      request = new ClientRequest(jobUrl);\r\n\/\/      response = request.get();\r\n\/\/      while (HttpServletResponse.SC_ACCEPTED == response.getStatus())\r\n\/\/      {\r\n\/\/         Thread.sleep(1000);\r\n\/\/         response.releaseConnection();\r\n\/\/         response = request.get();\r\n\/\/      }\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      Object entity = response.getEntity(String.class);\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 1, 1, 1, 1, 0);\r\n\/\/      ResteasyConstraintViolation cv = r.getFieldViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 2 and 4\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"a\", cv.getValue());\r\n\/\/      cv = r.getPropertyViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"size must be between 3 and 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"z\", cv.getValue());\r\n\/\/      cv = r.getClassViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"Concatenation of s and t must have length > 5\", cv.getMessage());\r\n\/\/      Assert.assertTrue(cv.getValue().startsWith(\"org.everrest.validation.TestValidation$TestResourceWithAllFivePotentialViolations@\"));\r\n\/\/      cv = r.getParameterViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"s must have length: 3 <= length <= 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"Foo[p]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Delete job.\r\n\/\/      request = new ClientRequest(jobUrl);\r\n\/\/      response = request.delete();\r\n\/\/      Assert.assertEquals(HttpServletResponse.SC_NO_CONTENT, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Submit asynchronous job with violations in result of resource method.\r\n\/\/      request = new ClientRequest(generateURL(\"\/abc\/xyz\/unused\/unused?asynch=true\"));\r\n\/\/      foo = new Foo(\"pqr\");\r\n\/\/      request.body(\"application\/foo\", foo);\r\n\/\/      response = request.post(Foo.class);\r\n\/\/      Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());\r\n\/\/      jobUrl = response.getResponseHeaders().getFirst(HttpHeaders.LOCATION);\r\n\/\/      System.out.println(\"JOB: \" + jobUrl);\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Get result: Should have no field, property, class, or parameter violations,\r\n\/\/      \/\/             and one return value violation.\r\n\/\/      request = new ClientRequest(jobUrl);\r\n\/\/      response = request.get();\r\n\/\/      while (HttpServletResponse.SC_ACCEPTED == response.getStatus())\r\n\/\/      {\r\n\/\/         Thread.sleep(1000);\r\n\/\/         response.releaseConnection();\r\n\/\/         response = request.get();\r\n\/\/      }\r\n\/\/      Assert.assertEquals(500, response.getStatus());\r\n\/\/      entity = response.getEntity(String.class);\r\n\/\/      r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 0, 1);\r\n\/\/      cv = r.getReturnValueViolations().iterator().next();\r\n\/\/      Assert.assertEquals(\"s must have length: 4 <= length <= 5\", cv.getMessage());\r\n\/\/      Assert.assertEquals(\"Foo[pqr]\", cv.getValue());\r\n\/\/\r\n\/\/      \/\/ Delete job.\r\n\/\/      request = new ClientRequest(jobUrl);\r\n\/\/      response = request.delete();\r\n\/\/      Assert.assertEquals(HttpServletResponse.SC_NO_CONTENT, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/   public void testCrossParameterConstraint() throws Exception\r\n\/\/   {\r\n\/\/      before(TestSubResourceWithCrossParameterConstraint.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/2\/3\"));\r\n\/\/      ClientResponse<?> response = request.post();\r\n\/\/      Assert.assertEquals(204, response.getStatus());\r\n\/\/      response.releaseConnection();\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      request = new ClientRequest(generateURL(\"\/5\/7\"));\r\n\/\/      response = request.post();\r\n\/\/      Assert.assertEquals(400, response.getStatus());\r\n\/\/      String header = response.getResponseHeaders().getFirst(Validation.VALIDATION_HEADER);\r\n\/\/      Assert.assertNotNull(header);\r\n\/\/      Assert.assertTrue(Boolean.valueOf(header));\r\n\/\/      Object entity = response.getEntity(String.class);\r\n\/\/      System.out.println(\"entity: \" + entity);\r\n\/\/      ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/      countViolations(r, 0, 0, 0, 1, 0);\r\n\/\/      ResteasyConstraintViolation violation = r.getParameterViolations().iterator().next();\r\n\/\/      System.out.println(\"violation: \" + violation);\r\n\/\/      Assert.assertEquals(\"Parameters must total <= 7\", violation.getMessage());\r\n\/\/      System.out.println(\"violation value: \" + violation.getValue());\r\n\/\/      Assert.assertEquals(\"[5, 7]\", violation.getValue());\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/\r\n\/\/   @Test\r\n\/\/   public void testProxy() throws Exception\r\n\/\/   {\r\n\/\/      before(TestProxyResource.class);\r\n\/\/\r\n\/\/      \/\/ Valid\r\n\/\/      TestProxyInterface client = ProxyFactory.create(TestProxyInterface.class, generateURL(\"\/\"));\r\n\/\/      client.s(\"abcd\");\r\n\/\/      String result = client.g();\r\n\/\/      Assert.assertEquals(\"abcd\", result);\r\n\/\/\r\n\/\/      \/\/ Invalid\r\n\/\/      client.s(\"abcde\");\r\n\/\/      try\r\n\/\/      {\r\n\/\/         result = client.g();\r\n\/\/      }\r\n\/\/      catch (ClientResponseFailure e)\r\n\/\/      {\r\n\/\/         ClientResponse<?> response = e.getResponse();\r\n\/\/         System.out.println(\"status: \" + response.getStatus());\r\n\/\/         String header = response.getResponseHeaders().getFirst(Validation.VALIDATION_HEADER);\r\n\/\/         Assert.assertNotNull(header);\r\n\/\/         Assert.assertTrue(Boolean.valueOf(header));\r\n\/\/         Object entity = response.getEntity(String.class);\r\n\/\/         System.out.println(\"entity: \" + entity);\r\n\/\/         ViolationReport r = new ViolationReport(String.class.cast(entity));\r\n\/\/         countViolations(r, 0, 0, 0, 0, 1);\r\n\/\/         ResteasyConstraintViolation violation = r.getReturnValueViolations().iterator().next();\r\n\/\/         System.out.println(\"violation: \" + violation);\r\n\/\/         Assert.assertEquals(\"size must be between 2 and 4\", violation.getMessage());\r\n\/\/         Assert.assertEquals(\"abcde\", violation.getValue());\r\n\/\/      }\r\n\/\/      catch (Exception e)\r\n\/\/      {\r\n\/\/         Assert.fail(\"expected ClientResponseFailure\");\r\n\/\/      }\r\n\/\/      finally\r\n\/\/      {\r\n\/\/         after();\r\n\/\/      }\r\n\/\/   }\r\n\/\/\r\n\/\/   @Test\r\n\/\/   public void testOtherGroups() throws Exception\r\n\/\/   {\r\n\/\/      before(TestResourceWithOtherGroups.class);\r\n\/\/\r\n\/\/      \/\/ Test invalid field, property, parameter, and class.\r\n\/\/      ClientRequest request = new ClientRequest(generateURL(\"\/test\/a\/z\"));\r\n\/\/      ClientResponse<?> response = request.post(String.class);\r\n\/\/      Assert.assertEquals(200, response.getStatus());\r\n\/\/      Object entity = response.getEntity();\r\n\/\/      System.out.println(\"entity: \" + entity);\r\n\/\/      Assert.assertEquals(\"z\", entity);\r\n\/\/      after();\r\n\/\/   }\r\n\/\/\r\n\/\/   private void countViolations(ViolationReport r, int fieldCount, int propertyCount, int classCount, int parameterCount, int returnValueCount)\r\n\/\/   {\r\n\/\/      Assert.assertEquals(fieldCount,       r.getFieldViolations().size());\r\n\/\/      Assert.assertEquals(propertyCount,    r.getPropertyViolations().size());\r\n\/\/      Assert.assertEquals(classCount,       r.getClassViolations().size());\r\n\/\/      Assert.assertEquals(parameterCount,   r.getParameterViolations().size());\r\n\/\/      Assert.assertEquals(returnValueCount, r.getReturnValueViolations().size());\r\n\/\/   }\r\n\/\/\r\n\/\/   private List<String> getMessages(ViolationReport r)\r\n\/\/   {\r\n\/\/      List<String> list = new ArrayList<String>();\r\n\/\/      list.addAll(getMessagesFromList(r.getFieldViolations()));\r\n\/\/      list.addAll(getMessagesFromList(r.getPropertyViolations()));\r\n\/\/      list.addAll(getMessagesFromList(r.getClassViolations()));\r\n\/\/      list.addAll(getMessagesFromList(r.getParameterViolations()));\r\n\/\/      list.addAll(getMessagesFromList(r.getReturnValueViolations()));\r\n\/\/      return list;\r\n\/\/   }\r\n\/\/\r\n\/\/   private List<String> getMessagesFromList(List<ResteasyConstraintViolation> rcvs)\r\n\/\/   {\r\n\/\/      List<String> list = new ArrayList<String>();\r\n\/\/      for (Iterator<ResteasyConstraintViolation> it = rcvs.iterator(); it.hasNext(); )\r\n\/\/      {\r\n\/\/         ResteasyConstraintViolation rcv = it.next();\r\n\/\/         list.add(rcv.getMessage() + \"; \" + rcv.getValue());\r\n\/\/      }\r\n\/\/      return list;\r\n\/\/   }\r\n}\r\n","subject":"","message":"Added validation initial\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"eb895d489439566be637bb470e44eedd37269efe","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"3b80bbc2431c5bde295fca26c5370db786384151","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"9d1af588b4b0f0140d7d980d86ea092f13a17890","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"017aea528698485bba1780c7bae95e85e3976388","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"9deb268bd164614bf357f4907c22eea4d1217139","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"bacfad3a236c8f19f9dec9c42bc3aaa3c4b41517","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"12957a754ea35f37b8831a06bb7393ce73e1918d","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"everrest","url":"https:\/\/github.com\/codenvy\/everrest","stars":24,"test_cases":{},"commit":"692116fc23e0b16753d1c59ec00f91efe906b2f1","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"7590ad150b1523691ae6f26ae24a291b81d804c9","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"504f6cf639c2b0251d3b86c39b76dee21b3dd9ec","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"e2b3fa0f9d07058c3817181aec7bff10530c9020","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"f1d20e1fdb75be5047dd29513419aac60b2731ac","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"d1af174afab076bb0000209b7e8765cb84b0b315","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"a5abdd08f3165107279660de8f82dc9d1c40cdd6","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"87c9be6879d56bc94473d58151b82d3ad0a4b094","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"730a6d35398c147f1ae2793804fddb23bdc421f3","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"ff471f44c111d79bb7c5a04764da95e4fe8004b5","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"tinylog","url":"https:\/\/github.com\/pmwmedia\/tinylog","stars":274,"test_cases":{},"commit":"e9c96a5329ffdc243c34e9096202378409495215","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"f1a29a06f5a924bdc2c0f436f9bdb60adbb9619e","old_file":"plugin-ssh\/che-plugin-ssh-git-native\/src\/main\/java\/org\/eclipse\/che\/git\/impl\/nativegit\/ssh\/SshKeyProviderImpl.java","new_file":"plugin-ssh\/che-plugin-ssh-git-native\/src\/main\/java\/org\/eclipse\/che\/git\/impl\/nativegit\/ssh\/SshKeyProviderImpl.java","old_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2016 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.git.impl.nativegit.ssh;\n\nimport com.google.inject.Inject;\n\nimport org.eclipse.che.api.core.UnauthorizedException;\nimport org.eclipse.che.api.git.GitException;\nimport org.eclipse.che.api.git.GitUrl;\nimport org.eclipse.che.ide.ext.ssh.server.SshKey;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStore;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStoreException;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyUploader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Optional;\nimport java.util.Set;\n\n\/**\n * Implementation SshKeyProvider that provides private key and upload public\n *\n * @author Anton Korneta\n *\/\npublic class SshKeyProviderImpl implements SshKeyProvider {\n    private static final Logger LOG = LoggerFactory.getLogger(SshKeyProviderImpl.class);\n\n    private final SshKeyStore         sshKeyStore;\n    private final Set<SshKeyUploader> sshKeyUploaders;\n\n    @Inject\n    public SshKeyProviderImpl(SshKeyStore sshKeyStore, Set<SshKeyUploader> sshKeyUploaders) {\n        this.sshKeyStore = sshKeyStore;\n        this.sshKeyUploaders = sshKeyUploaders;\n    }\n\n    \/**\n     * Get private ssh key and upload public ssh key to repository hosting service.\n     *\n     * @param url\n     *         url to git repository\n     * @return private ssh key\n     * @throws GitException\n     *         if an error occurs while generating or uploading keys\n     *\/\n    @Override\n    public byte[] getPrivateKey(String url) throws GitException {\n        String host = GitUrl.getHost(url);\n        SshKey publicKey;\n        SshKey privateKey;\n\n        \/\/ check keys existence\n        try {\n            if ((privateKey = sshKeyStore.getPrivateKey(host)) != null) {\n                publicKey = sshKeyStore.getPublicKey(host);\n            } else {\n                throw new GitException(\"Unable get private ssh key\");\n            }\n        } catch (SshKeyStoreException e) {\n            throw new GitException(e.getMessage(), e);\n        }\n\n        final Optional<SshKeyUploader> optionalKeyUploader = sshKeyUploaders.stream()\n                                                                            .filter(keyUploader -> keyUploader.match(url))\n                                                                            .findFirst();\n        if (optionalKeyUploader.isPresent()) {\n            final SshKeyUploader uploader = optionalKeyUploader.get();\n            \/\/ upload public key\n            try {\n                uploader.uploadKey(publicKey);\n            } catch (IOException e) {\n                throw new GitException(e.getMessage(), e);\n            } catch (UnauthorizedException e) {\n                \/\/ Git action might fail without uploaded public SSH key.\n                LOG.warn(String.format(\"Unable upload public SSH key with %s\", uploader.getClass().getSimpleName()), e);\n            }\n        } else {\n            \/\/ Git action might fail without SSH key.\n            LOG.warn(String.format(\"Not found ssh key uploader for %s\", host));\n        }\n        return privateKey.getBytes();\n    }\n}\n","new_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2016 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.git.impl.nativegit.ssh;\n\nimport com.google.inject.Inject;\n\nimport org.eclipse.che.api.core.UnauthorizedException;\nimport org.eclipse.che.api.git.GitException;\nimport org.eclipse.che.api.git.GitUrlUtils;\nimport org.eclipse.che.ide.ext.ssh.server.SshKey;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStore;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStoreException;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyUploader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Optional;\nimport java.util.Set;\n\n\/**\n * Implementation SshKeyProvider that provides private key and upload public\n *\n * @author Anton Korneta\n *\/\npublic class SshKeyProviderImpl implements SshKeyProvider {\n    private static final Logger LOG = LoggerFactory.getLogger(SshKeyProviderImpl.class);\n\n    private final SshKeyStore         sshKeyStore;\n    private final Set<SshKeyUploader> sshKeyUploaders;\n\n    @Inject\n    public SshKeyProviderImpl(SshKeyStore sshKeyStore, Set<SshKeyUploader> sshKeyUploaders) {\n        this.sshKeyStore = sshKeyStore;\n        this.sshKeyUploaders = sshKeyUploaders;\n    }\n\n    \/**\n     * Get private ssh key and upload public ssh key to repository hosting service.\n     *\n     * @param url\n     *         url to git repository\n     * @return private ssh key\n     * @throws GitException\n     *         if an error occurs while generating or uploading keys\n     *\/\n    @Override\n    public byte[] getPrivateKey(String url) throws GitException {\n        String host = GitUrlUtils.getHost(url);\n        SshKey publicKey;\n        SshKey privateKey;\n\n        \/\/ check keys existence\n        try {\n            if ((privateKey = sshKeyStore.getPrivateKey(host)) != null) {\n                publicKey = sshKeyStore.getPublicKey(host);\n            } else {\n                throw new GitException(\"Unable get private ssh key\");\n            }\n        } catch (SshKeyStoreException e) {\n            throw new GitException(e.getMessage(), e);\n        }\n\n        final Optional<SshKeyUploader> optionalKeyUploader = sshKeyUploaders.stream()\n                                                                            .filter(keyUploader -> keyUploader.match(url))\n                                                                            .findFirst();\n        if (optionalKeyUploader.isPresent()) {\n            final SshKeyUploader uploader = optionalKeyUploader.get();\n            \/\/ upload public key\n            try {\n                uploader.uploadKey(publicKey);\n            } catch (IOException e) {\n                throw new GitException(e.getMessage(), e);\n            } catch (UnauthorizedException e) {\n                \/\/ Git action might fail without uploaded public SSH key.\n                LOG.warn(String.format(\"Unable upload public SSH key with %s\", uploader.getClass().getSimpleName()), e);\n            }\n        } else {\n            \/\/ Git action might fail without SSH key.\n            LOG.warn(String.format(\"Not found ssh key uploader for %s\", host));\n        }\n        return privateKey.getBytes();\n    }\n}\n","subject":"","message":"CHE-336: Refactoring of GitUrl class\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"e92f74962169063eda7926cedaaae5f8764b00ee","old_file":"plugin-java\/che-plugin-java-ext-debugger-java\/src\/main\/java\/org\/eclipse\/che\/ide\/ext\/java\/jdi\/server\/EventsCollector.java","new_file":"plugin-java\/che-plugin-java-ext-debugger-java\/src\/main\/java\/org\/eclipse\/che\/ide\/ext\/java\/jdi\/server\/EventsCollector.java","old_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.ide.ext.java.jdi.server;\n\nimport com.sun.jdi.VMDisconnectedException;\nimport com.sun.jdi.event.EventQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\/** @author andrew00x *\/\nfinal class EventsCollector implements Runnable {\n    private static final Logger LOG = LoggerFactory.getLogger(EventsCollector.class);\n    private final    EventsHandler handler;\n    private final    EventQueue    queue;\n    private final    Thread        thread;\n    private volatile boolean       running;\n\n    EventsCollector(EventQueue queue, EventsHandler handler) {\n        this.queue = queue;\n        this.handler = handler;\n\n        thread = new Thread(this);\n        running = true;\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            try {\n                handler.handleEvents(queue.remove());\n            } catch (DebuggerException e) {\n                LOG.error(e.getMessage(), e);\n            } catch (VMDisconnectedException e) {\n                break;\n            } catch (InterruptedException e) {\n                \/\/ Thread interrupted with method stop().\n                LOG.debug(\"EventsCollector terminated\");\n            }\n        }\n        LOG.debug(\"EventsCollector stopped\");\n    }\n\n    void stop() {\n        running = false;\n        thread.interrupt();\n    }\n}\n","new_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.ide.ext.java.jdi.server;\n\nimport com.sun.jdi.VMDisconnectedException;\nimport com.sun.jdi.event.EventQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\/** @author andrew00x *\/\nfinal class EventsCollector implements Runnable {\n    private static final Logger LOG = LoggerFactory.getLogger(EventsCollector.class);\n    private final    EventsHandler handler;\n    private final    EventQueue    queue;\n    private final    Thread        thread;\n    private volatile boolean       running;\n\n    EventsCollector(EventQueue queue, EventsHandler handler) {\n        this.queue = queue;\n        this.handler = handler;\n\n        thread = new Thread(this);\n        running = true;\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            try {\n                handler.handleEvents(queue.remove());\n            } catch (DebuggerException e) {\n                LOG.warn(e.getMessage(), e);\n            } catch (VMDisconnectedException e) {\n                break;\n            } catch (InterruptedException e) {\n                \/\/ Thread interrupted with method stop().\n                LOG.debug(\"EventsCollector terminated\");\n            }\n        }\n        LOG.debug(\"EventsCollector stopped\");\n    }\n\n    void stop() {\n        running = false;\n        thread.interrupt();\n    }\n}\n","subject":"","message":"Change log level to warn in case InvalidBreakPointException\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"be39091e7631d0981df944a979123cd161d37240","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"09cf8d6c300ba0f2ef3f8845c7aec4e1d55daf69","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"db17d4bd88aa6dbbbaabc028073874361d943774","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"f1a29a06f5a924bdc2c0f436f9bdb60adbb9619e","old_file":"plugin-ssh\/che-plugin-ssh-git-native\/src\/main\/java\/org\/eclipse\/che\/git\/impl\/nativegit\/ssh\/SshKeyProviderImpl.java","new_file":"plugin-ssh\/che-plugin-ssh-git-native\/src\/main\/java\/org\/eclipse\/che\/git\/impl\/nativegit\/ssh\/SshKeyProviderImpl.java","old_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2016 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.git.impl.nativegit.ssh;\n\nimport com.google.inject.Inject;\n\nimport org.eclipse.che.api.core.UnauthorizedException;\nimport org.eclipse.che.api.git.GitException;\nimport org.eclipse.che.api.git.GitUrl;\nimport org.eclipse.che.ide.ext.ssh.server.SshKey;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStore;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStoreException;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyUploader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Optional;\nimport java.util.Set;\n\n\/**\n * Implementation SshKeyProvider that provides private key and upload public\n *\n * @author Anton Korneta\n *\/\npublic class SshKeyProviderImpl implements SshKeyProvider {\n    private static final Logger LOG = LoggerFactory.getLogger(SshKeyProviderImpl.class);\n\n    private final SshKeyStore         sshKeyStore;\n    private final Set<SshKeyUploader> sshKeyUploaders;\n\n    @Inject\n    public SshKeyProviderImpl(SshKeyStore sshKeyStore, Set<SshKeyUploader> sshKeyUploaders) {\n        this.sshKeyStore = sshKeyStore;\n        this.sshKeyUploaders = sshKeyUploaders;\n    }\n\n    \/**\n     * Get private ssh key and upload public ssh key to repository hosting service.\n     *\n     * @param url\n     *         url to git repository\n     * @return private ssh key\n     * @throws GitException\n     *         if an error occurs while generating or uploading keys\n     *\/\n    @Override\n    public byte[] getPrivateKey(String url) throws GitException {\n        String host = GitUrl.getHost(url);\n        SshKey publicKey;\n        SshKey privateKey;\n\n        \/\/ check keys existence\n        try {\n            if ((privateKey = sshKeyStore.getPrivateKey(host)) != null) {\n                publicKey = sshKeyStore.getPublicKey(host);\n            } else {\n                throw new GitException(\"Unable get private ssh key\");\n            }\n        } catch (SshKeyStoreException e) {\n            throw new GitException(e.getMessage(), e);\n        }\n\n        final Optional<SshKeyUploader> optionalKeyUploader = sshKeyUploaders.stream()\n                                                                            .filter(keyUploader -> keyUploader.match(url))\n                                                                            .findFirst();\n        if (optionalKeyUploader.isPresent()) {\n            final SshKeyUploader uploader = optionalKeyUploader.get();\n            \/\/ upload public key\n            try {\n                uploader.uploadKey(publicKey);\n            } catch (IOException e) {\n                throw new GitException(e.getMessage(), e);\n            } catch (UnauthorizedException e) {\n                \/\/ Git action might fail without uploaded public SSH key.\n                LOG.warn(String.format(\"Unable upload public SSH key with %s\", uploader.getClass().getSimpleName()), e);\n            }\n        } else {\n            \/\/ Git action might fail without SSH key.\n            LOG.warn(String.format(\"Not found ssh key uploader for %s\", host));\n        }\n        return privateKey.getBytes();\n    }\n}\n","new_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2016 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.git.impl.nativegit.ssh;\n\nimport com.google.inject.Inject;\n\nimport org.eclipse.che.api.core.UnauthorizedException;\nimport org.eclipse.che.api.git.GitException;\nimport org.eclipse.che.api.git.GitUrlUtils;\nimport org.eclipse.che.ide.ext.ssh.server.SshKey;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStore;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyStoreException;\nimport org.eclipse.che.ide.ext.ssh.server.SshKeyUploader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Optional;\nimport java.util.Set;\n\n\/**\n * Implementation SshKeyProvider that provides private key and upload public\n *\n * @author Anton Korneta\n *\/\npublic class SshKeyProviderImpl implements SshKeyProvider {\n    private static final Logger LOG = LoggerFactory.getLogger(SshKeyProviderImpl.class);\n\n    private final SshKeyStore         sshKeyStore;\n    private final Set<SshKeyUploader> sshKeyUploaders;\n\n    @Inject\n    public SshKeyProviderImpl(SshKeyStore sshKeyStore, Set<SshKeyUploader> sshKeyUploaders) {\n        this.sshKeyStore = sshKeyStore;\n        this.sshKeyUploaders = sshKeyUploaders;\n    }\n\n    \/**\n     * Get private ssh key and upload public ssh key to repository hosting service.\n     *\n     * @param url\n     *         url to git repository\n     * @return private ssh key\n     * @throws GitException\n     *         if an error occurs while generating or uploading keys\n     *\/\n    @Override\n    public byte[] getPrivateKey(String url) throws GitException {\n        String host = GitUrlUtils.getHost(url);\n        SshKey publicKey;\n        SshKey privateKey;\n\n        \/\/ check keys existence\n        try {\n            if ((privateKey = sshKeyStore.getPrivateKey(host)) != null) {\n                publicKey = sshKeyStore.getPublicKey(host);\n            } else {\n                throw new GitException(\"Unable get private ssh key\");\n            }\n        } catch (SshKeyStoreException e) {\n            throw new GitException(e.getMessage(), e);\n        }\n\n        final Optional<SshKeyUploader> optionalKeyUploader = sshKeyUploaders.stream()\n                                                                            .filter(keyUploader -> keyUploader.match(url))\n                                                                            .findFirst();\n        if (optionalKeyUploader.isPresent()) {\n            final SshKeyUploader uploader = optionalKeyUploader.get();\n            \/\/ upload public key\n            try {\n                uploader.uploadKey(publicKey);\n            } catch (IOException e) {\n                throw new GitException(e.getMessage(), e);\n            } catch (UnauthorizedException e) {\n                \/\/ Git action might fail without uploaded public SSH key.\n                LOG.warn(String.format(\"Unable upload public SSH key with %s\", uploader.getClass().getSimpleName()), e);\n            }\n        } else {\n            \/\/ Git action might fail without SSH key.\n            LOG.warn(String.format(\"Not found ssh key uploader for %s\", host));\n        }\n        return privateKey.getBytes();\n    }\n}\n","subject":"","message":"CHE-336: Refactoring of GitUrl class\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"e83f473589c28d36c3331c1d985d2f90c5b25780","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"23d81008edd45bc9246aa76da3fdfcb1acb9cf58","old_file":"plugin-docker\/che-plugin-docker-machine\/src\/test\/java\/org\/eclipse\/che\/plugin\/docker\/machine\/DockerInstanceProviderTest.java","new_file":"plugin-docker\/che-plugin-docker-machine\/src\/test\/java\/org\/eclipse\/che\/plugin\/docker\/machine\/DockerInstanceProviderTest.java","old_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.plugin.docker.machine;\n\nimport org.eclipse.che.api.core.NotFoundException;\nimport org.eclipse.che.api.core.model.machine.Recipe;\nimport org.eclipse.che.api.core.util.LineConsumer;\nimport org.eclipse.che.api.machine.server.exception.MachineException;\nimport org.eclipse.che.api.machine.server.recipe.RecipeImpl;\nimport org.eclipse.che.commons.env.EnvironmentContext;\nimport org.eclipse.che.commons.user.UserImpl;\nimport org.eclipse.che.plugin.docker.client.DockerConnector;\nimport org.eclipse.che.plugin.docker.client.ProgressMonitor;\nimport org.eclipse.che.plugin.docker.client.dto.AuthConfigs;\nimport org.eclipse.che.plugin.docker.client.json.ContainerConfig;\nimport org.eclipse.che.plugin.docker.client.json.ContainerCreated;\nimport org.eclipse.che.plugin.docker.client.json.HostConfig;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.testng.MockitoTestNGListener;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Listeners;\nimport org.testng.annotations.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.util.Arrays.asList;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.anyVararg;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertTrue;\n\n@Listeners(MockitoTestNGListener.class)\npublic class DockerInstanceProviderTest {\n\n    private static final String API_ENDPOINT_VALUE = \"apiEndpoint\";\n\n    private static final String PROJECTS_ROOT = \"\/projects\";\n\n    private static final String CONTAINER_ID = \"containerId\";\n\n    @Mock\n    private DockerConnector dockerConnector;\n\n    @Mock\n    private DockerMachineFactory dockerMachineFactory;\n\n    @Mock\n    private DockerInstanceStopDetector dockerInstanceStopDetector;\n\n    @Mock\n    private DockerNode dockerNode;\n\n    private DockerInstanceProvider dockerInstanceProvider;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        EnvironmentContext envCont = new EnvironmentContext();\n        envCont.setUser(new UserImpl(\"user\", null, null, null, false));\n        EnvironmentContext.setCurrent(envCont);\n\n        when(dockerMachineFactory.createNode(anyString())).thenReturn(dockerNode);\n        when(dockerConnector.createContainer(any(ContainerConfig.class), anyString()))\n                .thenReturn(new ContainerCreated(CONTAINER_ID, new String[0]));\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        EnvironmentContext.reset();\n    }\n\n    @Test\n    public void shouldReturnTypeDocker() throws Exception {\n        assertEquals(dockerInstanceProvider.getType(), \"docker\");\n    }\n\n    @Test\n    public void shouldReturnRecipeTypesDockerfile() throws Exception {\n        assertEquals(dockerInstanceProvider.getRecipeTypes(), Collections.singleton(\"Dockerfile\"));\n    }\n\n    \/\/ TODO add tests for instance snapshot removal\n\n    @Test\n    public void shouldBuildDockerfileOnInstanceCreationFromRecipe() throws Exception {\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(\"builtImageId\");\n\n\n        createInstanceFromRecipe();\n\n\n        verify(dockerConnector).buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg());\n    }\n\n    @Test\n    public void shouldPullDockerImageOnInstanceCreationFromSnapshot() throws Exception {\n        String repo = \"repo\";\n        String tag = \"tag\";\n        String registry = \"localhost:1234\";\n\n\n        createInstanceFromSnapshot(repo, tag, registry);\n\n\n        verify(dockerConnector).pull(eq(repo), eq(tag), eq(registry), any(ProgressMonitor.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromRecipe() throws Exception {\n        String builtImageId = \"builtImageId\";\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(builtImageId);\n\n\n        createInstanceFromRecipe();\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getImage(), builtImageId);\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).createContainer(any(ContainerConfig.class), anyString());\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromSnapshot() throws Exception {\n        final String machineId = \"machineId\";\n        final String workspaceId = \"workspaceId\";\n        final String userId = \"userId\";\n        final boolean isDev = false;\n        final int memorySizeInMB = 64;\n        final String displayName = \"Display name\";\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n\n\n        createInstanceFromSnapshot(isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineId),\n                                                    eq(workspaceId),\n                                                    eq(isDev),\n                                                    eq(userId),\n                                                    eq(displayName),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class),\n                                                    eq(recipe),\n                                                    eq(memorySizeInMB));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromRecipe() throws Exception {\n        final String machineId = \"machineId\";\n        final String workspaceId = \"workspaceId\";\n        final String userId = \"userId\";\n        final boolean isDev = false;\n        final int memorySizeInMB = 64;\n        final String displayName = \"Display name\";\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n\n\n        createInstanceFromRecipe(isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineId),\n                                                    eq(workspaceId),\n                                                    eq(isDev),\n                                                    eq(userId),\n                                                    eq(displayName),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class),\n                                                    eq(recipe),\n                                                    eq(memorySizeInMB));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = true;\n        final String workspaceId = \"workspaceId\";\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromRecipe(isDev, workspaceId);\n\n        verify(dockerNode).bindWorkspace(eq(workspaceId), eq(hostProjectsFolder));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = true;\n        final String workspaceId = \"workspaceId\";\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromSnapshot(isDev, workspaceId);\n\n        verify(dockerNode).bindWorkspace(eq(workspaceId), eq(hostProjectsFolder));\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = false;\n        final String workspaceId = \"workspaceId\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromRecipe(isDev, workspaceId);\n\n        verify(dockerNode, never()).bindWorkspace(anyString(), anyString());\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = false;\n        final String workspaceId = \"workspaceId\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromSnapshot(isDev, workspaceId);\n\n        verify(dockerNode, never()).bindWorkspace(anyString(), anyString());\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromRecipe(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n        assertEquals(startContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromSnapshot(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n        assertEquals(startContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        assertEquals(createContainerCaptor.getValue().getMemorySwap(), -1);\n        assertEquals(startContainerCaptor.getValue().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        assertEquals(createContainerCaptor.getValue().getMemorySwap(), -1);\n        assertEquals(startContainerCaptor.getValue().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        final String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n\n    @Test(enabled = false)\n    public void shouldAddExtraHostOnDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            new String[]{\"dev.box.com:192.168.0.1\"},\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 1);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test(enabled = false)\n    public void shouldAddExtraHostOnDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            new String[]{\"dev.box.com:192.168.0.1\", \"codenvy.com.com:185\"},\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test(enabled = false)\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            new String[]{\"dev.box.com:192.168.0.1\"},\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 1);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test(enabled = false)\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            new String[]{\"dev.box.com:192.168.0.1\", \"codenvy.com.com:185\"},\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithValidCharacters() throws Exception {\n        final String userName = \"user\";\n        final String displayName = \"displayName\";\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", userName, \"workspaceId\", displayName);\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"workspaceId\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithInvalidCharacters() throws Exception {\n        final String userName = \"{use}r+\";\n        final String displayName = \"displ{[ayName@\";\n        EnvironmentContext.getCurrent().setUser(new UserImpl(userName));\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", \"user\", \"workspaceId\", \"displayName\");\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"workspaceId\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE +  \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n\n    @Test\n    \/**\n     * E.g from https:\/\/github.com\/boot2docker\/boot2docker\/blob\/master\/README.md#virtualbox-guest-additions\n     *\n     *   Users should be \/Users\n     *   \/Users should be \/Users\n     *   c\/Users should be \/c\/Users\n     *   \/c\/Users should be \/c\/Users\n     *   c:\/Users should be \/c\/Users\n     *\/\n    public void shouldEscapePathForWindowsHost() {\n        assertEquals(dockerInstanceProvider.escapePath(\"Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c:\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\"), \"\/c\/Users\");\n\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\"),\n                                                       \"\/c\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\");\n    }\n\n\n    private void createInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe(false,\n                                 64,\n                                 \"machineId\",\n                                 \"userId\",\n                                 \"workspaceId\",\n                                 \"Display Name\",\n                                 new RecipeImpl().withType(\"Dockerfile\")\n                                                 .withScript(\"FROM busybox\"));\n    }\n\n    private void createInstanceFromRecipe(boolean isDev) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev, String workspaceId) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromRecipe(int memorySizeInMB) throws Exception {\n        createInstanceFromRecipe(null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(Boolean isDev,\n                                          Integer memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        createInstanceFromRecipe(isDev == null ? false : isDev,\n                                 memorySizeInMB == null ? 64 : memorySizeInMB,\n                                 machineId == null ? \"machineId\" : machineId,\n                                 userId == null ? \"userId\" : userId,\n                                 workspaceId == null ? \"workspaceId\" : workspaceId,\n                                 displayName == null ? \"Display Name\" : displayName,\n                                 recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                  .withScript(\"FROM busybox\") : recipe);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev,\n                                          int memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              machineId,\n                                              userId,\n                                              workspaceId,\n                                              isDev,\n                                              displayName,\n                                              memorySizeInMB,\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot() throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(int memorySizeInMB) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev, String workspaceId) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo, String tag, String registry) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(repo, tag, registry, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n\n        createInstanceFromSnapshot(repo == null ? \"repo\" : repo,\n                                   tag == null ? \"tag\" : tag,\n                                   registry == null ? \"localhost:1234\" : registry,\n                                   isDev == null ? false : isDev,\n                                   memorySizeInMB == null ? 64 : memorySizeInMB,\n                                   machineId == null ? \"machineId\" : machineId,\n                                   userId == null ? \"userId\" : userId,\n                                   workspaceId == null ? \"workspaceId\" : workspaceId,\n                                   displayName == null ? \"Display Name\" : displayName,\n                                   recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                    .withScript(\"FROM busybox\") : recipe);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            boolean isDev,\n                                            int memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(repo, tag, \"imageId\", registry),\n                                              machineId,\n                                              userId,\n                                              workspaceId,\n                                              isDev,\n                                              displayName,\n                                              recipe,\n                                              memorySizeInMB,\n                                              LineConsumer.DEV_NULL);\n    }\n}","new_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.plugin.docker.machine;\n\nimport org.eclipse.che.api.core.NotFoundException;\nimport org.eclipse.che.api.core.model.machine.Recipe;\nimport org.eclipse.che.api.core.util.LineConsumer;\nimport org.eclipse.che.api.machine.server.exception.MachineException;\nimport org.eclipse.che.api.machine.server.recipe.RecipeImpl;\nimport org.eclipse.che.commons.env.EnvironmentContext;\nimport org.eclipse.che.commons.user.UserImpl;\nimport org.eclipse.che.plugin.docker.client.DockerConnector;\nimport org.eclipse.che.plugin.docker.client.ProgressMonitor;\nimport org.eclipse.che.plugin.docker.client.dto.AuthConfigs;\nimport org.eclipse.che.plugin.docker.client.json.ContainerConfig;\nimport org.eclipse.che.plugin.docker.client.json.ContainerCreated;\nimport org.eclipse.che.plugin.docker.client.json.HostConfig;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.testng.MockitoTestNGListener;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Listeners;\nimport org.testng.annotations.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.util.Arrays.asList;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.anyVararg;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertTrue;\n\n@Listeners(MockitoTestNGListener.class)\npublic class DockerInstanceProviderTest {\n\n    private static final String API_ENDPOINT_VALUE = \"apiEndpoint\";\n\n    private static final String PROJECTS_ROOT = \"\/projects\";\n\n    private static final String CONTAINER_ID = \"containerId\";\n\n    @Mock\n    private DockerConnector dockerConnector;\n\n    @Mock\n    private DockerMachineFactory dockerMachineFactory;\n\n    @Mock\n    private DockerInstanceStopDetector dockerInstanceStopDetector;\n\n    @Mock\n    private DockerNode dockerNode;\n\n    private DockerInstanceProvider dockerInstanceProvider;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        EnvironmentContext envCont = new EnvironmentContext();\n        envCont.setUser(new UserImpl(\"user\", null, null, null, false));\n        EnvironmentContext.setCurrent(envCont);\n\n        when(dockerMachineFactory.createNode(anyString())).thenReturn(dockerNode);\n        when(dockerConnector.createContainer(any(ContainerConfig.class), anyString()))\n                .thenReturn(new ContainerCreated(CONTAINER_ID, new String[0]));\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        EnvironmentContext.reset();\n    }\n\n    @Test\n    public void shouldReturnTypeDocker() throws Exception {\n        assertEquals(dockerInstanceProvider.getType(), \"docker\");\n    }\n\n    @Test\n    public void shouldReturnRecipeTypesDockerfile() throws Exception {\n        assertEquals(dockerInstanceProvider.getRecipeTypes(), Collections.singleton(\"Dockerfile\"));\n    }\n\n    \/\/ TODO add tests for instance snapshot removal\n\n    @Test\n    public void shouldBuildDockerfileOnInstanceCreationFromRecipe() throws Exception {\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(\"builtImageId\");\n\n\n        createInstanceFromRecipe();\n\n\n        verify(dockerConnector).buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg());\n    }\n\n    @Test\n    public void shouldPullDockerImageOnInstanceCreationFromSnapshot() throws Exception {\n        String repo = \"repo\";\n        String tag = \"tag\";\n        String registry = \"localhost:1234\";\n\n\n        createInstanceFromSnapshot(repo, tag, registry);\n\n\n        verify(dockerConnector).pull(eq(repo), eq(tag), eq(registry), any(ProgressMonitor.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromRecipe() throws Exception {\n        String builtImageId = \"builtImageId\";\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(builtImageId);\n\n\n        createInstanceFromRecipe();\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getImage(), builtImageId);\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).createContainer(any(ContainerConfig.class), anyString());\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromSnapshot() throws Exception {\n        final String machineId = \"machineId\";\n        final String workspaceId = \"workspaceId\";\n        final String userId = \"userId\";\n        final boolean isDev = false;\n        final int memorySizeInMB = 64;\n        final String displayName = \"Display name\";\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n\n\n        createInstanceFromSnapshot(isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineId),\n                                                    eq(workspaceId),\n                                                    eq(isDev),\n                                                    eq(userId),\n                                                    eq(displayName),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class),\n                                                    eq(recipe),\n                                                    eq(memorySizeInMB));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromRecipe() throws Exception {\n        final String machineId = \"machineId\";\n        final String workspaceId = \"workspaceId\";\n        final String userId = \"userId\";\n        final boolean isDev = false;\n        final int memorySizeInMB = 64;\n        final String displayName = \"Display name\";\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n\n\n        createInstanceFromRecipe(isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineId),\n                                                    eq(workspaceId),\n                                                    eq(isDev),\n                                                    eq(userId),\n                                                    eq(displayName),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class),\n                                                    eq(recipe),\n                                                    eq(memorySizeInMB));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = true;\n        final String workspaceId = \"workspaceId\";\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromRecipe(isDev, workspaceId);\n\n        verify(dockerNode).bindWorkspace(eq(workspaceId), eq(hostProjectsFolder));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = true;\n        final String workspaceId = \"workspaceId\";\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromSnapshot(isDev, workspaceId);\n\n        verify(dockerNode).bindWorkspace(eq(workspaceId), eq(hostProjectsFolder));\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = false;\n        final String workspaceId = \"workspaceId\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromRecipe(isDev, workspaceId);\n\n        verify(dockerNode, never()).bindWorkspace(anyString(), anyString());\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = false;\n        final String workspaceId = \"workspaceId\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromSnapshot(isDev, workspaceId);\n\n        verify(dockerNode, never()).bindWorkspace(anyString(), anyString());\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromRecipe(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n        assertEquals(startContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromSnapshot(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n        assertEquals(startContainerCaptor.getValue().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        assertEquals(createContainerCaptor.getValue().getMemorySwap(), -1);\n        assertEquals(startContainerCaptor.getValue().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        ArgumentCaptor<HostConfig> startContainerCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), startContainerCaptor.capture());\n        assertEquals(createContainerCaptor.getValue().getMemorySwap(), -1);\n        assertEquals(startContainerCaptor.getValue().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        final String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        assertEquals(argumentCaptor.getValue().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 1);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 1);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] extraHosts = argumentCaptor.getValue().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<HostConfig> argumentCaptor = ArgumentCaptor.forClass(HostConfig.class);\n        verify(dockerConnector).startContainer(anyString(), argumentCaptor.capture());\n\n        final String[] actualBinds = argumentCaptor.getValue().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithValidCharacters() throws Exception {\n        final String userName = \"user\";\n        final String displayName = \"displayName\";\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", userName, \"workspaceId\", displayName);\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"workspaceId\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithInvalidCharacters() throws Exception {\n        final String userName = \"{use}r+\";\n        final String displayName = \"displ{[ayName@\";\n        EnvironmentContext.getCurrent().setUser(new UserImpl(userName));\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", \"user\", \"workspaceId\", \"displayName\");\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"workspaceId\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE +  \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + DockerInstanceProvider.PROJECTS_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n\n    @Test\n    \/**\n     * E.g from https:\/\/github.com\/boot2docker\/boot2docker\/blob\/master\/README.md#virtualbox-guest-additions\n     *\n     *   Users should be \/Users\n     *   \/Users should be \/Users\n     *   c\/Users should be \/c\/Users\n     *   \/c\/Users should be \/c\/Users\n     *   c:\/Users should be \/c\/Users\n     *\/\n    public void shouldEscapePathForWindowsHost() {\n        assertEquals(dockerInstanceProvider.escapePath(\"Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c:\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\"), \"\/c\/Users\");\n\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\"),\n                                                       \"\/c\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\");\n    }\n\n\n    private void createInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe(false,\n                                 64,\n                                 \"machineId\",\n                                 \"userId\",\n                                 \"workspaceId\",\n                                 \"Display Name\",\n                                 new RecipeImpl().withType(\"Dockerfile\")\n                                                 .withScript(\"FROM busybox\"));\n    }\n\n    private void createInstanceFromRecipe(boolean isDev) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev, String workspaceId) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromRecipe(int memorySizeInMB) throws Exception {\n        createInstanceFromRecipe(null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(Boolean isDev,\n                                          Integer memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        createInstanceFromRecipe(isDev == null ? false : isDev,\n                                 memorySizeInMB == null ? 64 : memorySizeInMB,\n                                 machineId == null ? \"machineId\" : machineId,\n                                 userId == null ? \"userId\" : userId,\n                                 workspaceId == null ? \"workspaceId\" : workspaceId,\n                                 displayName == null ? \"Display Name\" : displayName,\n                                 recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                  .withScript(\"FROM busybox\") : recipe);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev,\n                                          int memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              machineId,\n                                              userId,\n                                              workspaceId,\n                                              isDev,\n                                              displayName,\n                                              memorySizeInMB,\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot() throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(int memorySizeInMB) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev, String workspaceId) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo, String tag, String registry) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(repo, tag, registry, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, memorySizeInMB, machineId, userId, workspaceId, displayName, recipe);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n\n        createInstanceFromSnapshot(repo == null ? \"repo\" : repo,\n                                   tag == null ? \"tag\" : tag,\n                                   registry == null ? \"localhost:1234\" : registry,\n                                   isDev == null ? false : isDev,\n                                   memorySizeInMB == null ? 64 : memorySizeInMB,\n                                   machineId == null ? \"machineId\" : machineId,\n                                   userId == null ? \"userId\" : userId,\n                                   workspaceId == null ? \"workspaceId\" : workspaceId,\n                                   displayName == null ? \"Display Name\" : displayName,\n                                   recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                    .withScript(\"FROM busybox\") : recipe);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            boolean isDev,\n                                            int memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            Recipe recipe) throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(repo, tag, \"imageId\", registry),\n                                              machineId,\n                                              userId,\n                                              workspaceId,\n                                              isDev,\n                                              displayName,\n                                              recipe,\n                                              memorySizeInMB,\n                                              LineConsumer.DEV_NULL);\n    }\n}","subject":"","message":"CLDIDE-2537 Changed injected variable from array to string with ',' delimiter to allow inject NULL from configuration\n\nSigned-off-by: Sergii Kabashniuk <skabashnyuk@codenvy.com>\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"9b483912a8706ad95a8a9e6ae061911f12fa837d","old_file":"plugin-docker\/che-plugin-docker-machine\/src\/test\/java\/org\/eclipse\/che\/plugin\/docker\/machine\/DockerInstanceProviderTest.java","new_file":"plugin-docker\/che-plugin-docker-machine\/src\/test\/java\/org\/eclipse\/che\/plugin\/docker\/machine\/DockerInstanceProviderTest.java","old_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.plugin.docker.machine;\n\nimport org.eclipse.che.api.core.NotFoundException;\nimport org.eclipse.che.api.core.model.machine.Channels;\nimport org.eclipse.che.api.core.model.machine.MachineSource;\nimport org.eclipse.che.api.core.model.machine.MachineState;\nimport org.eclipse.che.api.core.model.machine.MachineStatus;\nimport org.eclipse.che.api.core.model.machine.Recipe;\nimport org.eclipse.che.api.core.util.LineConsumer;\nimport org.eclipse.che.api.machine.server.exception.MachineException;\nimport org.eclipse.che.api.machine.server.model.impl.ChannelsImpl;\nimport org.eclipse.che.api.machine.server.model.impl.LimitsImpl;\nimport org.eclipse.che.api.machine.server.model.impl.MachineSourceImpl;\nimport org.eclipse.che.api.machine.server.model.impl.MachineStateImpl;\nimport org.eclipse.che.api.machine.server.recipe.RecipeImpl;\nimport org.eclipse.che.commons.env.EnvironmentContext;\nimport org.eclipse.che.commons.user.UserImpl;\nimport org.eclipse.che.plugin.docker.client.DockerConnector;\nimport org.eclipse.che.plugin.docker.client.ProgressMonitor;\nimport org.eclipse.che.plugin.docker.client.dto.AuthConfigs;\nimport org.eclipse.che.plugin.docker.client.json.ContainerConfig;\nimport org.eclipse.che.plugin.docker.client.json.ContainerCreated;\nimport org.eclipse.che.plugin.docker.client.json.HostConfig;\nimport org.eclipse.che.plugin.docker.machine.node.DockerNode;\nimport org.eclipse.che.plugin.docker.machine.node.WorkspaceFolderPathProvider;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.testng.MockitoTestNGListener;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Listeners;\nimport org.testng.annotations.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.util.Arrays.asList;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.anyVararg;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertTrue;\n\n@Listeners(MockitoTestNGListener.class)\npublic class DockerInstanceProviderTest {\n    private static final String PROJECT_FOLDER_PATH = \"\/projects\";\n\n    private static final String API_ENDPOINT_VALUE = \"apiEndpoint\";\n\n    private static final String CONTAINER_ID = \"containerId\";\n\n    private static final String WORKSPACE_ID = \"wsId\";\n\n    @Mock\n    private DockerConnector dockerConnector;\n\n    @Mock\n    private DockerMachineFactory dockerMachineFactory;\n\n    @Mock\n    private DockerInstanceStopDetector dockerInstanceStopDetector;\n\n    @Mock\n    private DockerNode dockerNode;\n\n    @Mock\n    private WorkspaceFolderPathProvider workspaceFolderPathProvider;\n\n    private DockerInstanceProvider dockerInstanceProvider;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        when(dockerConnector.getDockerHostIp()).thenReturn(\"123.123.123.123\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<ServerConf>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        EnvironmentContext envCont = new EnvironmentContext();\n        envCont.setUser(new UserImpl(\"user\", null, null, null, false));\n        EnvironmentContext.setCurrent(envCont);\n\n        when(dockerMachineFactory.createNode(anyString(), anyString())).thenReturn(dockerNode);\n        when(dockerConnector.createContainer(any(ContainerConfig.class), anyString()))\n                .thenReturn(new ContainerCreated(CONTAINER_ID, new String[0]));\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        EnvironmentContext.reset();\n    }\n\n    @Test\n    public void shouldReturnTypeDocker() throws Exception {\n        assertEquals(dockerInstanceProvider.getType(), \"docker\");\n    }\n\n    @Test\n    public void shouldReturnRecipeTypesDockerfile() throws Exception {\n        assertEquals(dockerInstanceProvider.getRecipeTypes(), Collections.singleton(\"Dockerfile\"));\n    }\n\n    \/\/ TODO add tests for instance snapshot removal\n\n    @Test\n    public void shouldBuildDockerfileOnInstanceCreationFromRecipe() throws Exception {\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(\"builtImageId\");\n\n\n        createInstanceFromRecipe();\n\n\n        verify(dockerConnector).buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg());\n    }\n\n    @Test\n    public void shouldPullDockerImageOnInstanceCreationFromSnapshot() throws Exception {\n        String repo = \"repo\";\n        String tag = \"tag\";\n        String registry = \"localhost:1234\";\n\n\n        createInstanceFromSnapshot(repo, tag, registry);\n\n\n        verify(dockerConnector).pull(eq(repo), eq(tag), eq(registry), any(ProgressMonitor.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromRecipe() throws Exception {\n        String builtImageId = \"builtImageId\";\n        when(dockerConnector.buildImage(anyString(), any(ProgressMonitor.class), any(AuthConfigs.class), anyVararg()))\n                .thenReturn(builtImageId);\n\n\n        createInstanceFromRecipe();\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getImage(), builtImageId);\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).createContainer(any(ContainerConfig.class), anyString());\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromSnapshot() throws Exception {\n        final MachineSourceImpl machineSource = new MachineSourceImpl(\"type\", \"location\");\n        final MachineStateImpl machineState = new MachineStateImpl(false,\n                                                                   \"Display name\",\n                                                                   \"machineType\",\n                                                                   machineSource,\n                                                                   new LimitsImpl(64),\n                                                                   \"machineId\",\n                                                                   new ChannelsImpl(\"chan1\", \"chan2\"),\n                                                                   \"workspaceId\",\n                                                                   \"userId\",\n                                                                   \"envName\",\n                                                                   MachineStatus.CREATING);\n\n\n        createInstanceFromSnapshot(machineState);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineState),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromRecipe() throws Exception {\n        final MachineSourceImpl machineSource = new MachineSourceImpl(\"type\", \"location\");\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n        final MachineStateImpl machineState = new MachineStateImpl(false,\n                                                                   \"Display name\",\n                                                                   \"machineType\",\n                                                                   machineSource,\n                                                                   new LimitsImpl(64),\n                                                                   \"machineId\",\n                                                                   new ChannelsImpl(\"chan1\", \"chan2\"),\n                                                                   \"workspaceId\",\n                                                                   \"userId\",\n                                                                   \"envName\",\n                                                                   MachineStatus.CREATING);\n\n        createInstanceFromRecipe(recipe, machineState);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineState),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = true;\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromRecipe(isDev, WORKSPACE_ID);\n\n        verify(dockerNode).bindWorkspace();\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = true;\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromSnapshot(isDev, WORKSPACE_ID);\n\n        verify(dockerNode).bindWorkspace();\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = false;\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromRecipe(isDev, WORKSPACE_ID);\n\n        verify(dockerNode, never()).bindWorkspace();\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = false;\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromSnapshot(isDev, WORKSPACE_ID);\n\n        verify(dockerNode, never()).bindWorkspace();\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromRecipe(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromSnapshot(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        final String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 3);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 3);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithValidCharacters() throws Exception {\n        final String userName = \"user\";\n        final String displayName = \"displayName\";\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", userName, WORKSPACE_ID, displayName);\n\n        final String containerName = dockerInstanceProvider.generateContainerName(WORKSPACE_ID, displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithInvalidCharacters() throws Exception {\n        final String userName = \"{use}r+\";\n        final String displayName = \"displ{[ayName@\";\n        EnvironmentContext.getCurrent().setUser(new UserImpl(userName));\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", \"user\", \"WORKSPACE_ID\", \"displayName\");\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"WORKSPACE_ID\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" + DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE +  \"=\" + PROJECT_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    \/**\n     * E.g from https:\/\/github.com\/boot2docker\/boot2docker\/blob\/master\/README.md#virtualbox-guest-additions\n     *\n     *   Users should be \/Users\n     *   \/Users should be \/Users\n     *   c\/Users should be \/c\/Users\n     *   \/c\/Users should be \/c\/Users\n     *   c:\/Users should be \/c\/Users\n     *\/\n    @Test\n    public void shouldEscapePathForWindowsHost() {\n        assertEquals(dockerInstanceProvider.escapePath(\"Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c:\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\"), \"\/c\/Users\");\n\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\"),\n                     \"\/c\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\");\n    }\n\n\n    private void createInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe(false,\n                                 64,\n                                 \"machineId\",\n                                 \"userId\",\n                                 WORKSPACE_ID,\n                                 \"Display Name\",\n                                 new RecipeImpl().withType(\"Dockerfile\")\n                                                 .withScript(\"FROM busybox\"));\n    }\n\n    private void createInstanceFromRecipe(boolean isDev) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev, String workspaceId) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromRecipe(int memorySizeInMB) throws Exception {\n        createInstanceFromRecipe(null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(Boolean isDev,\n                                          Integer memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        createInstanceFromRecipe(isDev == null ? false : isDev,\n                                 memorySizeInMB == null ? 64 : memorySizeInMB,\n                                 machineId == null ? \"machineId\" : machineId,\n                                 userId == null ? \"userId\" : userId,\n                                 workspaceId == null ? WORKSPACE_ID : workspaceId,\n                                 displayName == null ? \"Display Name\" : displayName,\n                                 recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                  .withScript(\"FROM busybox\") : recipe,\n                                 \"machineType\",\n                                 new MachineSourceImpl(\"source type\", \"source location\"),\n                                 new ChannelsImpl(\"channel1\", \"channel2\"),\n                                 MachineStatus.CREATING);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev,\n                                          int memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe,\n                                          String machineType,\n                                          MachineSource machineSource,\n                                          Channels channels,\n                                          MachineStatus machineStatus)\n            throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              new MachineStateImpl(isDev,\n                                                                   displayName,\n                                                                   machineType,\n                                                                   machineSource,\n                                                                   new LimitsImpl(memorySizeInMB),\n                                                                   machineId,\n                                                                   channels,\n                                                                   workspaceId,\n                                                                   userId,\n                                                                   \"envName\",\n                                                                   machineStatus),\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromRecipe(Recipe recipe, MachineState machineState) throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              machineState,\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot() throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(int memorySizeInMB) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, memorySizeInMB, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev, String workspaceId) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, workspaceId, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo, String tag, String registry) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(repo, tag, registry, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName)\n            throws NotFoundException, MachineException {\n\n        createInstanceFromSnapshot(repo == null ? \"repo\" : repo,\n                                   tag == null ? \"tag\" : tag,\n                                   registry == null ? \"localhost:1234\" : registry,\n                                   isDev == null ? false : isDev,\n                                   memorySizeInMB == null ? 64 : memorySizeInMB,\n                                   machineId == null ? \"machineId\" : machineId,\n                                   userId == null ? \"userId\" : userId,\n                                   workspaceId == null ? WORKSPACE_ID : workspaceId,\n                                   displayName == null ? \"Display Name\" : displayName,\n                                   \"machineType\",\n                                   new MachineSourceImpl(\"source type\", \"source location\"),\n                                   new ChannelsImpl(\"channel1\", \"channel2\"),\n                                   MachineStatus.CREATING,\n                                   \"envName\");\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            boolean isDev,\n                                            int memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            String machineType,\n                                            MachineSource machineSource,\n                                            Channels channels,\n                                            MachineStatus machineStatus,\n                                            String envName)\n            throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(repo, tag, \"imageId\", registry),\n                                              new MachineStateImpl(isDev,\n                                                                   displayName,\n                                                                   machineType,\n                                                                   machineSource,\n                                                                   new LimitsImpl(memorySizeInMB),\n                                                                   machineId,\n                                                                   channels,\n                                                                   workspaceId,\n                                                                   userId,\n                                                                   envName,\n                                                                   machineStatus),\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot(MachineState machineState)\n            throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(\"repo\" ,\n                                                                    \"tag\",\n                                                                    \"imageId\",\n                                                                    \"localhost:1234\"),\n                                              machineState,\n                                              LineConsumer.DEV_NULL);\n    }\n}","new_contents":"\/*******************************************************************************\n * Copyright (c) 2012-2015 Codenvy, S.A.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http:\/\/www.eclipse.org\/legal\/epl-v10.html\n *\n * Contributors:\n *   Codenvy, S.A. - initial API and implementation\n *******************************************************************************\/\npackage org.eclipse.che.plugin.docker.machine;\n\nimport org.eclipse.che.api.core.NotFoundException;\nimport org.eclipse.che.api.core.model.machine.Channels;\nimport org.eclipse.che.api.core.model.machine.MachineSource;\nimport org.eclipse.che.api.core.model.machine.MachineState;\nimport org.eclipse.che.api.core.model.machine.MachineStatus;\nimport org.eclipse.che.api.core.model.machine.Recipe;\nimport org.eclipse.che.api.core.util.LineConsumer;\nimport org.eclipse.che.api.machine.server.exception.MachineException;\nimport org.eclipse.che.api.machine.server.model.impl.ChannelsImpl;\nimport org.eclipse.che.api.machine.server.model.impl.LimitsImpl;\nimport org.eclipse.che.api.machine.server.model.impl.MachineSourceImpl;\nimport org.eclipse.che.api.machine.server.model.impl.MachineStateImpl;\nimport org.eclipse.che.api.machine.server.recipe.RecipeImpl;\nimport org.eclipse.che.commons.env.EnvironmentContext;\nimport org.eclipse.che.commons.user.UserImpl;\nimport org.eclipse.che.plugin.docker.client.DockerConnector;\nimport org.eclipse.che.plugin.docker.client.ProgressMonitor;\nimport org.eclipse.che.plugin.docker.client.dto.AuthConfigs;\nimport org.eclipse.che.plugin.docker.client.json.ContainerConfig;\nimport org.eclipse.che.plugin.docker.client.json.ContainerCreated;\nimport org.eclipse.che.plugin.docker.client.json.HostConfig;\nimport org.eclipse.che.plugin.docker.machine.node.DockerNode;\nimport org.eclipse.che.plugin.docker.machine.node.WorkspaceFolderPathProvider;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.testng.MockitoTestNGListener;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Listeners;\nimport org.testng.annotations.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.util.Arrays.asList;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.anyVararg;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertTrue;\n\n@Listeners(MockitoTestNGListener.class)\npublic class DockerInstanceProviderTest {\n    private static final String PROJECT_FOLDER_PATH = \"\/projects\";\n    private static final String API_ENDPOINT_VALUE = \"apiEndpoint\";\n    private static final String CONTAINER_ID = \"containerId\";\n    private static final String WORKSPACE_ID = \"wsId\";\n    private static final String DISPLAY_NAME = \"Display Name\";\n\n    @Mock\n    private DockerConnector dockerConnector;\n\n    @Mock\n    private DockerMachineFactory dockerMachineFactory;\n\n    @Mock\n    private DockerInstanceStopDetector dockerInstanceStopDetector;\n\n    @Mock\n    private DockerNode dockerNode;\n\n    @Mock\n    private WorkspaceFolderPathProvider workspaceFolderPathProvider;\n\n    private DockerInstanceProvider dockerInstanceProvider;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        when(dockerConnector.getDockerHostIp()).thenReturn(\"123.123.123.123\");\n\n        dockerInstanceProvider = spy(new DockerInstanceProvider(dockerConnector,\n                                                                dockerMachineFactory,\n                                                                dockerInstanceStopDetector,\n                                                                Collections.<ServerConf>emptySet(),\n                                                                Collections.<ServerConf>emptySet(),\n                                                                Collections.<String>emptySet(),\n                                                                Collections.<String>emptySet(),\n                                                                null,\n                                                                API_ENDPOINT_VALUE,\n                                                                workspaceFolderPathProvider,\n                                                                PROJECT_FOLDER_PATH));\n\n        EnvironmentContext envCont = new EnvironmentContext();\n        envCont.setUser(new UserImpl(\"user\", null, null, null, false));\n        EnvironmentContext.setCurrent(envCont);\n\n        when(dockerMachineFactory.createNode(anyString(), anyString())).thenReturn(dockerNode);\n        when(dockerConnector.createContainer(any(ContainerConfig.class), anyString()))\n                .thenReturn(new ContainerCreated(CONTAINER_ID, new String[0]));\n    }\n\n    @AfterMethod\n    public void tearDown() throws Exception {\n        EnvironmentContext.reset();\n    }\n\n    @Test\n    public void shouldReturnTypeDocker() throws Exception {\n        assertEquals(dockerInstanceProvider.getType(), \"docker\");\n    }\n\n    @Test\n    public void shouldReturnRecipeTypesDockerfile() throws Exception {\n        assertEquals(dockerInstanceProvider.getRecipeTypes(), Collections.singleton(\"Dockerfile\"));\n    }\n\n    \/\/ TODO add tests for instance snapshot removal\n\n    @Test\n    public void shouldBuildDockerfileOnInstanceCreationFromRecipe() throws Exception {\n        String generatedContainerId = \"genContainerId\";\n        doReturn(generatedContainerId).when(dockerInstanceProvider).generateContainerName(WORKSPACE_ID, DISPLAY_NAME);\n\n\n        createInstanceFromRecipe();\n\n\n        verify(dockerConnector).buildImage(eq(\"eclipse-che\/\" + generatedContainerId),\n                                           any(ProgressMonitor.class),\n                                           any(AuthConfigs.class),\n                                           anyVararg());\n    }\n\n    @Test\n    public void shouldPullDockerImageOnInstanceCreationFromSnapshot() throws Exception {\n        String repo = \"repo\";\n        String tag = \"tag\";\n        String registry = \"localhost:1234\";\n\n\n        createInstanceFromSnapshot(repo, tag, registry);\n\n\n        verify(dockerConnector).pull(eq(repo), eq(tag), eq(registry), any(ProgressMonitor.class));\n    }\n\n    @Test\n    public void shouldReTagBuiltImageWithPredictableOnInstanceCreationFromRecipe() throws Exception {\n        String generatedContainerId = \"genContainerId\";\n        doReturn(generatedContainerId).when(dockerInstanceProvider).generateContainerName(WORKSPACE_ID, DISPLAY_NAME);\n        String repo = \"repo1\";\n        String registry = \"registry1\";\n        String tag = \"tag1\";\n\n\n        createInstanceFromSnapshot(repo, tag, registry);\n\n\n        verify(dockerConnector).tag(eq(registry + \"\/\" + repo + \":\" + tag), eq(\"eclipse-che\/\" + generatedContainerId), eq(null));\n        verify(dockerConnector).removeImage(eq(registry + \"\/\" + repo + \":\" + tag), eq(false));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromRecipe() throws Exception {\n        String generatedContainerId = \"genContainerId\";\n        doReturn(generatedContainerId).when(dockerInstanceProvider).generateContainerName(WORKSPACE_ID, DISPLAY_NAME);\n\n\n        createInstanceFromRecipe();\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getImage(), \"eclipse-che\/\" + generatedContainerId);\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCreateContainerOnInstanceCreationFromSnapshot() throws Exception {\n        String generatedContainerId = \"genContainerId\";\n        doReturn(generatedContainerId).when(dockerInstanceProvider).generateContainerName(WORKSPACE_ID, DISPLAY_NAME);\n        createInstanceFromSnapshot();\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getImage(), \"eclipse-che\/\" + generatedContainerId);\n    }\n\n    @Test\n    public void shouldStartContainerOnCreateInstanceFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        verify(dockerConnector).startContainer(eq(CONTAINER_ID), any(HostConfig.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromSnapshot() throws Exception {\n        final MachineSourceImpl machineSource = new MachineSourceImpl(\"type\", \"location\");\n        final MachineStateImpl machineState = new MachineStateImpl(false,\n                                                                   \"Display name\",\n                                                                   \"machineType\",\n                                                                   machineSource,\n                                                                   new LimitsImpl(64),\n                                                                   \"machineId\",\n                                                                   new ChannelsImpl(\"chan1\", \"chan2\"),\n                                                                   \"workspaceId\",\n                                                                   \"userId\",\n                                                                   \"envName\",\n                                                                   MachineStatus.CREATING);\n\n\n        createInstanceFromSnapshot(machineState);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineState),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class));\n    }\n\n    @Test\n    public void shouldCallCreationDockerInstanceWithFactoryOnCreateInstanceFromRecipe() throws Exception {\n        final MachineSourceImpl machineSource = new MachineSourceImpl(\"type\", \"location\");\n        final Recipe recipe = new RecipeImpl().withType(\"Dockerfile\").withScript(\"FROM busybox\");\n        final MachineStateImpl machineState = new MachineStateImpl(false,\n                                                                   \"Display name\",\n                                                                   \"machineType\",\n                                                                   machineSource,\n                                                                   new LimitsImpl(64),\n                                                                   \"machineId\",\n                                                                   new ChannelsImpl(\"chan1\", \"chan2\"),\n                                                                   \"workspaceId\",\n                                                                   \"userId\",\n                                                                   \"envName\",\n                                                                   MachineStatus.CREATING);\n\n        createInstanceFromRecipe(recipe, machineState);\n\n\n        verify(dockerMachineFactory).createInstance(eq(machineState),\n                                                    eq(CONTAINER_ID),\n                                                    eq(dockerNode),\n                                                    any(LineConsumer.class));\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = true;\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromRecipe(isDev, WORKSPACE_ID);\n\n        verify(dockerNode).bindWorkspace();\n    }\n\n    @Test\n    public void shouldBindWorkspaceOnDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = true;\n        final String hostProjectsFolder = \"\/tmp\/projects\";\n\n        when(dockerNode.getProjectsFolder()).thenReturn(hostProjectsFolder);\n\n        createInstanceFromSnapshot(isDev, WORKSPACE_ID);\n\n        verify(dockerNode).bindWorkspace();\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final boolean isDev = false;\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromRecipe(isDev, WORKSPACE_ID);\n\n        verify(dockerNode, never()).bindWorkspace();\n    }\n\n    @Test\n    public void shouldNotBindWorkspaceOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final boolean isDev = false;\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        createInstanceFromSnapshot(isDev, WORKSPACE_ID);\n\n        verify(dockerNode, never()).bindWorkspace();\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddApiEndpointEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                   \"Api endpoint variable is missing. Required \" +\n                   DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddApiEndpointEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE),\n                    \"Api endpoint variable is missing. Required \" +\n                    DockerInstanceProvider.API_ENDPOINT_URL_VARIABLE + \"=\" + API_ENDPOINT_VALUE +\n                    \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromRecipe(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldSetMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        int memorySizeMB = 234;\n\n\n        createInstanceFromSnapshot(memorySizeMB);\n\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        \/\/ docker accepts memory size in bytes\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemory(), memorySizeMB * 1024 * 1024);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldDisableSwapMemorySizeInContainersOnInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot();\n\n        ArgumentCaptor<ContainerConfig> createContainerCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(createContainerCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n        assertEquals(createContainerCaptor.getValue().getHostConfig().getMemorySwap(), -1);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddCommonAndDevLabelsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldAddOnlyCommonLabelsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final Map<String, String> expectedLabels = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":ref\", server.getRef());\n            expectedLabels.put(\"che:server:\" + server.getPort() + \":protocol\", server.getProtocol());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertEquals(argumentCaptor.getValue().getLabels(), expectedLabels);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeCommonAndDevPortsToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        final Set<ServerConf> devServers = new HashSet<>(asList(new ServerConf(\"reference3\", \"8082\", \"https\"),\n                                                                new ServerConf(\"reference4\", \"8083\", \"sftp\")));\n        for (ServerConf server : devServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            devServers,\n                                                            commonServers,\n                                                            Collections.<String>emptySet(),\n                                                            Collections.<String>emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldExposeOnlyCommonPortsToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        Map<String, Map<String, String>> expectedExposedPorts = new HashMap<>();\n        final Set<ServerConf> commonServers = new HashSet<>(asList(new ServerConf(\"reference1\", \"8080\", \"http\"),\n                                                                   new ServerConf(\"reference2\", \"8081\", \"ftp\")));\n        for (ServerConf server : commonServers) {\n            expectedExposedPorts.put(server.getPort(), Collections.<String, String>emptyMap());\n        }\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            commonServers,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n\n        assertEquals(argumentCaptor.getValue().getExposedPorts(), expectedExposedPorts);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindProjectsFSVolumeToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        final String[] expectedVolumes = new String[]{expectedHostPathOfProjects + \":\/projects\"};\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldNotBindProjectsFSVolumeToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String[] expectedVolumes = new String[0];\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(\"\/tmp\/projects\");\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        assertEquals(argumentCaptor.getValue().getHostConfig().getBinds(), expectedVolumes);\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonAndDevVolumesToContainerOnDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(devVolumes);\n        expectedVolumes.addAll(commonVolumes);\n        expectedVolumes.add(expectedHostPathOfProjects + \":\/projects\");\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(workspaceFolderPathProvider.getPath(anyString())).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromRecipe() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromRecipe(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = true;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 3);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromRecipe() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromRecipe(isDev);\n\n        \/\/then\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 2);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n    }\n\n    @Test\n    public void shouldAddExtraHostOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        \/\/given\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            \"dev.box.com:192.168.0.1,codenvy.com.com:185\",\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n        final boolean isDev = false;\n\n        \/\/when\n        createInstanceFromSnapshot(isDev);\n        \/\/then\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] extraHosts = argumentCaptor.getValue().getHostConfig().getExtraHosts();\n        assertEquals(extraHosts.length, 3);\n        assertEquals(extraHosts[0], \"dev.box.com:192.168.0.1\");\n        assertEquals(extraHosts[1], \"codenvy.com.com:185\");\n    }\n\n    @Test\n    public void shouldBindCommonVolumesOnlyToContainerOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        final String expectedHostPathOfProjects = \"\/tmp\/projects\";\n        Set<String> devVolumes = new HashSet<>(asList(\"\/etc:\/tmp\/etc:ro\", \"\/some\/thing:\/home\/some\/thing\"));\n        Set<String> commonVolumes = new HashSet<>(asList(\"\/some\/thing\/else:\/home\/some\/thing\/else\", \"\/other\/path:\/home\/other\/path\"));\n\n        final ArrayList<String> expectedVolumes = new ArrayList<>();\n        expectedVolumes.addAll(commonVolumes);\n\n        dockerInstanceProvider = new DockerInstanceProvider(dockerConnector,\n                                                            dockerMachineFactory,\n                                                            dockerInstanceStopDetector,\n                                                            Collections.emptySet(),\n                                                            Collections.emptySet(),\n                                                            devVolumes,\n                                                            commonVolumes,\n                                                            null,\n                                                            API_ENDPOINT_VALUE,\n                                                            workspaceFolderPathProvider,\n                                                            PROJECT_FOLDER_PATH);\n\n        when(dockerNode.getProjectsFolder()).thenReturn(expectedHostPathOfProjects);\n\n        final boolean isDev = false;\n\n\n        createInstanceFromSnapshot(isDev);\n\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        verify(dockerConnector).startContainer(anyString(), eq(null));\n\n        final String[] actualBinds = argumentCaptor.getValue().getHostConfig().getBinds();\n        assertEquals(actualBinds.length, expectedVolumes.size());\n        assertEquals(new HashSet<>(asList(actualBinds)), new HashSet<>(expectedVolumes));\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithValidCharacters() throws Exception {\n        final String userName = \"user\";\n        final String displayName = \"displayName\";\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", userName, WORKSPACE_ID, displayName);\n\n        final String containerName = dockerInstanceProvider.generateContainerName(WORKSPACE_ID, displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n    @Test\n    public void shouldGenerateValidNameForContainerFromPrefixWithInvalidCharacters() throws Exception {\n        final String userName = \"{use}r+\";\n        final String displayName = \"displ{[ayName@\";\n        EnvironmentContext.getCurrent().setUser(new UserImpl(userName));\n        final String expectedPrefix = String.format(\"%s_%s_%s_\", \"user\", \"WORKSPACE_ID\", \"displayName\");\n\n        final String containerName = dockerInstanceProvider.generateContainerName(\"WORKSPACE_ID\", displayName);\n\n        assertTrue(containerName.startsWith(expectedPrefix),\n                   \"Unexpected container name \" + containerName + \" while expected \" + expectedPrefix + \"*\");\n    }\n\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" +  DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddWorkspaceIdEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(true, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                   \"Workspace Id variable is missing. Required \" + DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromRecipe(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldNotAddWorkspaceIdEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        String wsId = \"myWs\";\n        createInstanceFromSnapshot(false, wsId);\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceProvider.CHE_WORKSPACE_ID + \"=\" + wsId),\n                    \"Non dev machine should not contains \" + DockerInstanceProvider.CHE_WORKSPACE_ID);\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE +  \"=\" + PROJECT_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldAddProjectsRootEnvVariableOnDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(true);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertTrue(Arrays.asList(argumentCaptor.getValue().getEnv())\n                         .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                   \"Projects root variable is missing. Required \" +\n                   DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH +\n                   \". Found \" + Arrays.toString(argumentCaptor.getValue().getEnv()));\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromRecipe() throws Exception {\n        createInstanceFromRecipe(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    @Test\n    public void shouldNotAddProjectsRootEnvVariableOnNonDevInstanceCreationFromSnapshot() throws Exception {\n        createInstanceFromSnapshot(false);\n\n        ArgumentCaptor<ContainerConfig> argumentCaptor = ArgumentCaptor.forClass(ContainerConfig.class);\n        verify(dockerConnector).createContainer(argumentCaptor.capture(), anyString());\n        assertFalse(Arrays.asList(argumentCaptor.getValue().getEnv())\n                          .contains(DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE + \"=\" + PROJECT_FOLDER_PATH),\n                    \"Non dev machine should not contains \" + DockerInstanceMetadata.PROJECTS_ROOT_VARIABLE);\n    }\n\n    \/**\n     * E.g from https:\/\/github.com\/boot2docker\/boot2docker\/blob\/master\/README.md#virtualbox-guest-additions\n     *\n     *   Users should be \/Users\n     *   \/Users should be \/Users\n     *   c\/Users should be \/c\/Users\n     *   \/c\/Users should be \/c\/Users\n     *   c:\/Users should be \/c\/Users\n     *\/\n    @Test\n    public void shouldEscapePathForWindowsHost() {\n        assertEquals(dockerInstanceProvider.escapePath(\"Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/Users\"), \"\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"\/c\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"c:\/Users\"), \"\/c\/Users\");\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\"), \"\/c\/Users\");\n\n        assertEquals(dockerInstanceProvider.escapePath(\"C:\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\"),\n                     \"\/c\/Users\/path\/dir\/from\/host:\/name\/of\/dir\/in\/container\");\n    }\n\n\n    private void createInstanceFromRecipe() throws Exception {\n        createInstanceFromRecipe(false,\n                                 64,\n                                 \"machineId\",\n                                 \"userId\",\n                                 WORKSPACE_ID,\n                                 DISPLAY_NAME,\n                                 new RecipeImpl().withType(\"Dockerfile\")\n                                                 .withScript(\"FROM busybox\"));\n    }\n\n    private void createInstanceFromRecipe(boolean isDev) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev, String workspaceId) throws Exception {\n        createInstanceFromRecipe(isDev, null, null, null, workspaceId, null, null);\n    }\n\n    private void createInstanceFromRecipe(int memorySizeInMB) throws Exception {\n        createInstanceFromRecipe(null, memorySizeInMB, null, null, null, null, null);\n    }\n\n    private void createInstanceFromRecipe(Boolean isDev,\n                                          Integer memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe) throws Exception {\n\n        createInstanceFromRecipe(isDev == null ? false : isDev,\n                                 memorySizeInMB == null ? 64 : memorySizeInMB,\n                                 machineId == null ? \"machineId\" : machineId,\n                                 userId == null ? \"userId\" : userId,\n                                 workspaceId == null ? WORKSPACE_ID : workspaceId,\n                                 displayName == null ? \"Display Name\" : displayName,\n                                 recipe == null ? new RecipeImpl().withType(\"Dockerfile\")\n                                                                  .withScript(\"FROM busybox\") : recipe,\n                                 \"machineType\",\n                                 new MachineSourceImpl(\"source type\", \"source location\"),\n                                 new ChannelsImpl(\"channel1\", \"channel2\"),\n                                 MachineStatus.CREATING);\n    }\n\n    private void createInstanceFromRecipe(boolean isDev,\n                                          int memorySizeInMB,\n                                          String machineId,\n                                          String userId,\n                                          String workspaceId,\n                                          String displayName,\n                                          Recipe recipe,\n                                          String machineType,\n                                          MachineSource machineSource,\n                                          Channels channels,\n                                          MachineStatus machineStatus)\n            throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              new MachineStateImpl(isDev,\n                                                                   displayName,\n                                                                   machineType,\n                                                                   machineSource,\n                                                                   new LimitsImpl(memorySizeInMB),\n                                                                   machineId,\n                                                                   channels,\n                                                                   workspaceId,\n                                                                   userId,\n                                                                   \"envName\",\n                                                                   machineStatus),\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromRecipe(Recipe recipe, MachineState machineState) throws Exception {\n\n        dockerInstanceProvider.createInstance(recipe,\n                                              machineState,\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot() throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(int memorySizeInMB) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, null, memorySizeInMB, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(boolean isDev, String workspaceId) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(null, null, null, isDev, null, null, null, workspaceId, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo, String tag, String registry) throws NotFoundException, MachineException {\n        createInstanceFromSnapshot(repo, tag, registry, null, null, null, null, null, null);\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            Boolean isDev,\n                                            Integer memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName)\n            throws NotFoundException, MachineException {\n\n        createInstanceFromSnapshot(repo == null ? \"repo\" : repo,\n                                   tag == null ? \"tag\" : tag,\n                                   registry == null ? \"localhost:1234\" : registry,\n                                   isDev == null ? false : isDev,\n                                   memorySizeInMB == null ? 64 : memorySizeInMB,\n                                   machineId == null ? \"machineId\" : machineId,\n                                   userId == null ? \"userId\" : userId,\n                                   workspaceId == null ? WORKSPACE_ID : workspaceId,\n                                   displayName == null ? \"Display Name\" : displayName,\n                                   \"machineType\",\n                                   new MachineSourceImpl(\"source type\", \"source location\"),\n                                   new ChannelsImpl(\"channel1\", \"channel2\"),\n                                   MachineStatus.CREATING,\n                                   \"envName\");\n    }\n\n    private void createInstanceFromSnapshot(String repo,\n                                            String tag,\n                                            String registry,\n                                            boolean isDev,\n                                            int memorySizeInMB,\n                                            String machineId,\n                                            String userId,\n                                            String workspaceId,\n                                            String displayName,\n                                            String machineType,\n                                            MachineSource machineSource,\n                                            Channels channels,\n                                            MachineStatus machineStatus,\n                                            String envName)\n            throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(repo, tag, \"imageId\", registry),\n                                              new MachineStateImpl(isDev,\n                                                                   displayName,\n                                                                   machineType,\n                                                                   machineSource,\n                                                                   new LimitsImpl(memorySizeInMB),\n                                                                   machineId,\n                                                                   channels,\n                                                                   workspaceId,\n                                                                   userId,\n                                                                   envName,\n                                                                   machineStatus),\n                                              LineConsumer.DEV_NULL);\n    }\n\n    private void createInstanceFromSnapshot(MachineState machineState)\n            throws NotFoundException, MachineException {\n\n        dockerInstanceProvider.createInstance(new DockerInstanceKey(\"repo\" ,\n                                                                    \"tag\",\n                                                                    \"imageId\",\n                                                                    \"localhost:1234\"),\n                                              machineState,\n                                              LineConsumer.DEV_NULL);\n    }\n}","subject":"","message":"CLDIDE-2633: fix swarm scheduling of docker machines\n\nSwarm has problems with scheduling containers if image id is used instead of repo.\nThis PR fixes incorrect containers scheduling and allow system admin correlate\ndocker image\/container with workspace\/machine\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"che-plugins","url":"https:\/\/github.com\/codenvy-legacy\/che-plugins","stars":25,"test_cases":{},"commit":"9fce34005bb1f864106a5a12e394d15a17039b30","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"178216fd02b52c9067576cbee65aeb5210eb6fd3","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"178216fd02b52c9067576cbee65aeb5210eb6fd3","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"eea0ab8b56858ec39a581fb443324633f793bfa7","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"6b25c0091f45a9a7d0ffcaa50735eaf450b3c2e4","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"e8ecafc1c59428dd9abd1cc7ea9793a816483042","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"f3c87d11618c371fb6b7e4ba5b8d51ac14e18bbe","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"d62526c0a7203c84a924c5897fa4f653b1a361f2","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"259cefb28a835b231530b18854cf8d4ef3e8ae53","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"16a700f027488809252fffd66ed40be160c70d1c","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"platform","url":"https:\/\/github.com\/proofpoint\/platform","stars":60,"test_cases":{},"commit":"04a170eec7ac2f4eebaeca7d8d0ea06dad5af28a","old_file":"http-client\/src\/test\/java\/com\/proofpoint\/http\/client\/JavaUrlHttpClientTest.java","new_file":"http-client\/src\/test\/java\/com\/proofpoint\/http\/client\/JavaUrlHttpClientTest.java","old_contents":"package com.proofpoint.http.client;\n\nimport com.google.common.base.Charsets;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.io.ByteStreams;\nimport com.proofpoint.units.Duration;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.handler.HandlerCollection;\nimport org.eclipse.jetty.server.nio.SelectChannelConnector;\nimport org.eclipse.jetty.servlet.ServletContextHandler;\nimport org.eclipse.jetty.servlet.ServletHolder;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpUtils;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketTimeoutException;\nimport java.net.URI;\nimport java.util.Collections;\nimport java.util.Map.Entry;\nimport java.util.concurrent.TimeUnit;\n\npublic class JavaUrlHttpClientTest\n{\n    private EchoServlet servlet;\n    private JavaUrlHttpClient httpClient;\n    private Server server;\n    private URI baseURI;\n\n    @BeforeMethod\n    public void setup()\n            throws Exception\n    {\n        servlet = new EchoServlet();\n        httpClient = new JavaUrlHttpClient(new HttpClientConfig());\n\n        int port;\n        ServerSocket socket = new ServerSocket();\n        try {\n            socket.bind(new InetSocketAddress(0));\n            port = socket.getLocalPort();\n        }\n        finally {\n            socket.close();\n        }\n        baseURI = new URI(\"http\", null, \"127.0.0.1\", port, null, null, null);\n\n        Server server = new Server();\n        server.setSendServerVersion(false);\n\n        SelectChannelConnector httpConnector;\n        httpConnector = new SelectChannelConnector();\n        httpConnector.setName(\"http\");\n        httpConnector.setPort(port);\n        server.addConnector(httpConnector);\n\n        ServletHolder servletHolder = new ServletHolder(servlet);\n        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.NO_SESSIONS);\n        context.addServlet(servletHolder, \"\/*\");\n        HandlerCollection handlers = new HandlerCollection();\n        handlers.addHandler(context);\n        server.setHandler(handlers);\n\n        this.server = server;\n        server.start();\n    }\n\n    @AfterMethod\n    public void teardown()\n            throws Exception\n    {\n        if (server != null) {\n            server.stop();\n        }\n    }\n\n    @Test\n    public void testGetMethod()\n            throws Exception\n    {\n        URI uri = baseURI.resolve(\"\/road\/to\/nowhere\");\n        Request request = RequestBuilder.prepareGet()\n                .setUri(uri)\n                .addHeader(\"foo\", \"bar\")\n                .addHeader(\"dupe\", \"first\")\n                .addHeader(\"dupe\", \"second\")\n                .build();\n\n        int statusCode = httpClient.execute(request, new ResponseStatusCodeHandler());\n        Assert.assertEquals(statusCode, 200);\n        Assert.assertEquals(servlet.requestMethod, \"GET\");\n        Assert.assertEquals(servlet.requestUri, uri);\n        Assert.assertEquals(servlet.requestHeaders.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(servlet.requestHeaders.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n    }\n\n    @Test\n    public void testPostMethod()\n            throws Exception\n    {\n        URI uri = baseURI.resolve(\"\/road\/to\/nowhere\");\n        Request request = RequestBuilder.preparePost()\n                .setUri(uri)\n                .addHeader(\"foo\", \"bar\")\n                .addHeader(\"dupe\", \"first\")\n                .addHeader(\"dupe\", \"second\")\n                .build();\n\n        int statusCode = httpClient.execute(request, new ResponseStatusCodeHandler());\n        Assert.assertEquals(statusCode, 200);\n        Assert.assertEquals(servlet.requestMethod, \"POST\");\n        Assert.assertEquals(servlet.requestUri, uri);\n        Assert.assertEquals(servlet.requestHeaders.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(servlet.requestHeaders.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n    }\n\n    @Test\n    public void testPutMethod()\n            throws Exception\n    {\n        URI uri = baseURI.resolve(\"\/road\/to\/nowhere\");\n        Request request = RequestBuilder.preparePut()\n                .setUri(uri)\n                .addHeader(\"foo\", \"bar\")\n                .addHeader(\"dupe\", \"first\")\n                .addHeader(\"dupe\", \"second\")\n                .build();\n\n        int statusCode = httpClient.execute(request, new ResponseStatusCodeHandler());\n        Assert.assertEquals(statusCode, 200);\n        Assert.assertEquals(servlet.requestMethod, \"PUT\");\n        Assert.assertEquals(servlet.requestUri, uri);\n        Assert.assertEquals(servlet.requestHeaders.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(servlet.requestHeaders.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n    }\n\n    @Test\n    public void testDeleteMethod()\n            throws Exception\n    {\n        URI uri = baseURI.resolve(\"\/road\/to\/nowhere\");\n        Request request = RequestBuilder.prepareDelete()\n                .setUri(uri)\n                .addHeader(\"foo\", \"bar\")\n                .addHeader(\"dupe\", \"first\")\n                .addHeader(\"dupe\", \"second\")\n                .build();\n\n        int statusCode = httpClient.execute(request, new ResponseStatusCodeHandler());\n        Assert.assertEquals(statusCode, 200);\n        Assert.assertEquals(servlet.requestMethod, \"DELETE\");\n        Assert.assertEquals(servlet.requestUri, uri);\n        Assert.assertEquals(servlet.requestHeaders.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(servlet.requestHeaders.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n    }\n\n    @Test\n    public void testResponseStatusCode()\n            throws Exception\n    {\n        servlet.responseStatusCode = 543;\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        int statusCode = httpClient.execute(request, new ResponseStatusCodeHandler());\n        Assert.assertEquals(statusCode, 543);\n    }\n\n    @Test\n    public void testResponseStatusMessage()\n            throws Exception\n    {\n        servlet.responseStatusMessage = \"message\";\n\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        String statusMessage = httpClient.execute(request, new ResponseHandler<String, Exception>()\n        {\n            @Override\n            public Exception handleException(Request request, Exception exception)\n            {\n                return exception;\n            }\n\n            @Override\n            public String handle(Request request, Response response)\n                    throws Exception\n            {\n                return response.getStatusMessage();\n            }\n        });\n\n        Assert.assertEquals(statusMessage, \"message\");\n    }\n\n    @Test\n    public void testResponseHeader()\n            throws Exception\n    {\n        servlet.responseHeaders.put(\"foo\", \"bar\");\n        servlet.responseHeaders.put(\"dupe\", \"first\");\n        servlet.responseHeaders.put(\"dupe\", \"second\");\n\n        Assert.assertEquals(servlet.responseHeaders.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(servlet.responseHeaders.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        ListMultimap<String, String> headers = httpClient.execute(request, new ResponseHandler<ListMultimap<String, String>, Exception>()\n        {\n            @Override\n            public Exception handleException(Request request, Exception exception)\n            {\n                return exception;\n            }\n\n            @Override\n            public ListMultimap<String, String> handle(Request request, Response response)\n                    throws Exception\n            {\n                return response.getHeaders();\n            }\n        });\n\n        Assert.assertEquals(headers.get(\"foo\"), ImmutableList.of(\"bar\"));\n        Assert.assertEquals(headers.get(\"dupe\"), ImmutableList.of(\"first\", \"second\"));\n    }\n\n    @Test\n    public void testResponseBodyEmpty()\n            throws Exception\n    {\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        String body = httpClient.execute(request, new ResponseToStringHandler());\n        Assert.assertEquals(body, \"\");\n    }\n\n    @Test\n    public void testResponseBody()\n            throws Exception\n    {\n        servlet.responseBody = \"body text\";\n\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        String body = httpClient.execute(request, new ResponseToStringHandler());\n        Assert.assertEquals(body, \"body text\");\n    }\n\n    @Test\n    public void testErrorResponseBody()\n            throws Exception\n    {\n        servlet.responseStatusCode = 500;\n        servlet.responseBody = \"body text\";\n\n        Request request = RequestBuilder.prepareGet()\n                .setUri(baseURI)\n                .build();\n\n        String body = httpClient.execute(request, new ResponseToStringHandler());\n        Assert.assertEquals(body, \"body text\");\n    }\n\n    @Test(expectedExceptions = SocketTimeoutException.class)\n    public void testConnectTimeout()\n            throws Exception\n    {\n        ServerSocket serverSocket = new ServerSocket(0, 1);\n        \/\/ create one connection. The OS will auto-accept it because backlog for server socket == 1\n        Socket clientSocket = new Socket(\"localhost\", serverSocket.getLocalPort());\n\n        HttpClientConfig config = new HttpClientConfig();\n        config.setConnectTimeout(new Duration(5, TimeUnit.MILLISECONDS));\n        JavaUrlHttpClient client = new JavaUrlHttpClient(config);\n\n        Request request = RequestBuilder.prepareGet()\n                .setUri(URI.create(\"http:\/\/localhost:\" + serverSocket.getLocalPort() + \"\/\"))\n                .build();\n\n        try {\n            client.execute(request, new ResponseToStringHandler());\n        }\n        finally {\n            clientSocket.close();\n            serverSocket.close();\n        }\n    }\n\n    @Test(expectedExceptions = SocketTimeoutException.class, expectedExceptionsMessageRegExp = \"Read timed out\")\n    public void testReadTimeout()\n            throws Exception\n    {\n        HttpClientConfig config = new HttpClientConfig()\n                .setReadTimeout(new Duration(200, TimeUnit.MILLISECONDS));\n\n        JavaUrlHttpClient client = new JavaUrlHttpClient(config);\n\n        URI uri = URI.create(baseURI.toASCIIString() + \"\/?sleep=400\");\n        Request request = RequestBuilder.prepareGet()\n                .setUri(uri)\n                .build();\n\n        client.execute(request, new ResponseToStringHandler());\n    }\n\n    private static final class EchoServlet extends HttpServlet\n    {\n        private String requestMethod;\n        private URI requestUri;\n        private final ListMultimap<String, String> requestHeaders = ArrayListMultimap.create();\n\n        private int responseStatusCode = 200;\n        private String responseStatusMessage;\n        private final ListMultimap<String, String> responseHeaders = ArrayListMultimap.create();\n        public String responseBody;\n\n        @Override\n        protected void service(HttpServletRequest request, HttpServletResponse response)\n                throws ServletException, IOException\n        {\n            requestMethod = request.getMethod();\n            requestUri = URI.create(HttpUtils.getRequestURL(request).toString());\n\n            requestHeaders.clear();\n            for (String name : Collections.list(request.getHeaderNames())) {\n                requestHeaders.putAll(name, Collections.list(request.getHeaders(name)));\n            }\n\n            if (responseStatusMessage != null) {\n                response.sendError(responseStatusCode, responseStatusMessage);\n            }\n            else {\n                response.setStatus(responseStatusCode);\n            }\n            for (Entry<String, String> entry : responseHeaders.entries()) {\n                response.addHeader(entry.getKey(), entry.getValue());\n            }\n\n            try {\n                if (request.getParameter(\"sleep\") != null) {\n                    Thread.sleep(Long.parseLong(request.getParameter(\"sleep\")));\n                }\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n            }\n\n            if (responseBody != null) {\n                response.getOutputStream().write(responseBody.getBytes(Charsets.UTF_8));\n            }\n        }\n    }\n\n    private static class ResponseToStringHandler implements ResponseHandler<String, Exception>\n    {\n        @Override\n        public Exception handleException(Request request, Exception exception)\n        {\n            return exception;\n        }\n\n        @Override\n        public String handle(Request request, Response response)\n                throws Exception\n        {\n            return new String(ByteStreams.toByteArray(response.getInputStream()), Charsets.UTF_8);\n        }\n    }\n\n    private static class ResponseStatusCodeHandler implements ResponseHandler<Integer, Exception>\n    {\n        @Override\n        public Exception handleException(Request request, Exception exception)\n        {\n            return exception;\n        }\n\n        @Override\n        public Integer handle(Request request, Response response)\n                throws Exception\n        {\n            return response.getStatusCode();\n        }\n    }\n}\n","new_contents":"","subject":"","message":"Remove JavaUrlHttpClient\n\n","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"6070306dd321e95dc6ca15e9c04903fae7b595a9","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"b241efb07b775943a0a76cfdba9a9a490b127d6b","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"08b43b24586ad213fe16b92217a6ee2757c0eb49","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"8911d4c9361045e2d25481ac0ed09556a350c672","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"e60e4051c56f94bb73b74a083e87d5bc0c905c0e","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"0610524d4166eb0279b5384d337923b3400a148b","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"577cc9655d46f795a816d1cadaff16e8582bb7d8","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"51cbd847717cd1d8a89ed30154c2182aca893eb5","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"5e89b2c8b36404324b1955d00aed3afea73fceda","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"diirt","url":"https:\/\/github.com\/diirt\/diirt","stars":12,"test_cases":{},"commit":"697705308b8ef47f5d729c14d53c04eae103ab56","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"0ecbafec261ad2528900cfb1234662dfba2ff67f","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"e32c8ac2c5a5462ef4452f2be855bd365d6c5564","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"99422a9fc5ff629741a5fd980180d506c4cbc721","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"ec6b17998499a61acf2c8de98577f676fa03ab8c","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"0f67094cb51ab6baff8014ebd72be92eccd7ffe9","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"bf94fb6d0582b3e4f3bd75a01eea1f9e18f3c9d8","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"ccf6e4543ee8c81cc55ad16b3d1188e83550415d","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"0c577153bcb6a3b16613f70e01b5863e31169788","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"ff7f6ce9e55b18cd5f13a57a4e4259a7c777623f","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"iis","url":"https:\/\/github.com\/openaire\/iis","stars":11,"test_cases":{},"commit":"d2f71878636eb881044d13be95587360b170da5a","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"launchkey-java","url":"https:\/\/github.com\/iovation\/launchkey-java","stars":9,"test_cases":{},"commit":"c76d631d701da84f2ceec0648603f306c0c75821","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"launchkey-java","url":"https:\/\/github.com\/iovation\/launchkey-java","stars":9,"test_cases":{},"commit":"ba82f60f471c5e610b4203c5e55d79de6c7e953f","old_file":"sdk\/src\/main\/java\/com\/iovation\/launchkey\/sdk\/transport\/apachehttp\/ApacheHttpTransport.java","new_file":"sdk\/src\/main\/java\/com\/iovation\/launchkey\/sdk\/transport\/apachehttp\/ApacheHttpTransport.java","old_contents":"package com.iovation.launchkey.sdk.transport.apachehttp;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.iovation.launchkey.sdk.cache.Cache;\nimport com.iovation.launchkey.sdk.cache.CacheException;\nimport com.iovation.launchkey.sdk.crypto.Crypto;\nimport com.iovation.launchkey.sdk.crypto.jwe.JWEFailure;\nimport com.iovation.launchkey.sdk.crypto.jwe.JWEService;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTClaims;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTData;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTError;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTService;\nimport com.iovation.launchkey.sdk.domain.policy.LegacyPolicy;\nimport com.iovation.launchkey.sdk.error.*;\nimport com.iovation.launchkey.sdk.transport.Transport;\nimport com.iovation.launchkey.sdk.transport.domain.Error;\nimport com.iovation.launchkey.sdk.transport.domain.*;\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.apache.http.message.BasicHeader;\nimport org.apache.http.message.HeaderGroup;\nimport org.apache.http.util.EntityUtils;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.util.*;\n\npublic class ApacheHttpTransport implements Transport {\n\n    private static final Base64 BASE_64 = new Base64(0);\n    private static final String IOV_JWT_HEADER = \"X-IOV-JWT\";\n    private static int serverTimeOffset = 0;\n    private static Date serverTimeOffsetExpires = null;\n    private final Log logger;\n    private final EntityKeyMap entityKeyMap;\n    private PublicKeyData currentPublicKeyData = null;\n    private Date currentPublicKeyDataExpires = null;\n\n    private final ApiRequestBuilderFactory rbf;\n    private final ObjectMapper objectMapper;\n    private final Crypto crypto;\n    private final HttpClient httpClient;\n    private final JWTService jwtService;\n    private final JWEService jweService;\n    private final Cache publicKeyCache;\n    private final int offsetTTL;\n    private final int currentPublicKeyTTL;\n    private final EntityIdentifier issuer;\n\n\n    public ApacheHttpTransport(HttpClient httpClient, Crypto crypto, ObjectMapper objectMapper,\n                               Cache publicKeyCache, String baseUrl, EntityIdentifier issuer,\n                               JWTService jwtService, JWEService jweService,\n                               int offsetTTL, int currentPublicKeyTTL, EntityKeyMap entityKeyMap\n    ) {\n        this.objectMapper = objectMapper;\n        this.objectMapper.setDateFormat(new StdDateFormat());\n        this.crypto = crypto;\n        this.httpClient = httpClient;\n        this.jwtService = jwtService;\n        this.jweService = jweService;\n        this.publicKeyCache = publicKeyCache;\n        this.entityKeyMap = entityKeyMap;\n        this.offsetTTL = offsetTTL;\n        this.currentPublicKeyTTL = currentPublicKeyTTL;\n        this.issuer = issuer;\n        logger = LogFactory.getLog(getClass());\n        rbf = new ApiRequestBuilderFactory(issuer.toString(), baseUrl, objectMapper, crypto, jwtService, jweService);\n    }\n\n    @Override\n    public PublicV3PingGetResponse publicV3PingGet()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"GET\", \"\/public\/v3\/ping\", null, null, false, null);\n        return parseJsonResponse(response.getEntity(), PublicV3PingGetResponse.class);\n    }\n\n    @Override\n    public PublicV3PublicKeyGetResponse publicV3PublicKeyGet(String publicKeyFingerprint)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n\n        String path = \"\/public\/v3\/public-key\";\n        if (publicKeyFingerprint != null) {\n            path = path + \"\/\" + publicKeyFingerprint;\n        }\n        HttpResponse response = getHttpResponse(\"GET\", path, null, null, false, null);\n        Header keyHeader = response.getFirstHeader(\"X-IOV-KEY-ID\");\n        if (keyHeader == null) {\n            throw new InvalidResponseException(\"Public Key ID header X-IOV-KEY-ID not found in response\", null, null);\n        }\n        try {\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new InvalidResponseException(\"No public key in response\", null, null);\n            }\n            String publicKey = EntityUtils.toString(entity);\n            return new PublicV3PublicKeyGetResponse(publicKey, keyHeader.getValue());\n        } catch (IllegalArgumentException e) {\n            throw new InvalidResponseException(\"Invalid public key in response.\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"Error reading response\", e, null);\n        }\n    }\n\n    @Override\n    public ServiceV3AuthsPostResponse serviceV3AuthsPost(ServiceV3AuthsPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/service\/v3\/auths\", subject, request, true, null);\n        return decryptResponse(response, ServiceV3AuthsPostResponse.class);\n    }\n\n    @Override\n    public ServiceV3AuthsGetResponse serviceV3AuthsGet(UUID authRequestId, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException, AuthorizationRequestTimedOutError,\n            NoKeyFoundException {\n        ServiceV3AuthsGetResponse response;\n        HttpResponse httpResponse;\n\n        String path = \"\/service\/v3\/auths\/\" + authRequestId.toString();\n        try {\n            httpResponse = getHttpResponse(\"GET\", path, subject, null, true, null);\n        } catch (RequestTimedOut e) {\n            throw new AuthorizationRequestTimedOutError();\n        }\n\n        int statusCode = httpResponse.getStatusLine().getStatusCode();\n        if (statusCode == 204) { \/\/ User has not responded\n            response = null;\n        } else { \/\/ Users responded\n            ServiceV3AuthsGetResponseCore apiResponse =\n                    decryptResponse(httpResponse, ServiceV3AuthsGetResponseCore.class);\n\n            EntityIdentifier audience;\n            try {\n                JWTData jwtData = jwtService.getJWTData(getJWT(httpResponse));\n                audience = EntityIdentifier.fromString(jwtData.getAudience());\n            } catch (JWTError jwtError){\n                    throw new CryptographyError(\"Unable to parse JWT to get key info!\", jwtError);\n            }\n            try {\n                if (apiResponse.getJweEncryptedDeviceResponse() != null) {\n                    String decrypted = jweService.decrypt(apiResponse.getJweEncryptedDeviceResponse());\n                    ServiceV3AuthsGetResponseDeviceJWE deviceResponse =\n                            objectMapper.readValue(decrypted, ServiceV3AuthsGetResponseDeviceJWE.class);\n                    response =  new ServiceV3AuthsGetResponse(\n                            audience,\n                            subject.getId(),\n                            apiResponse.getServiceUserHash(),\n                            apiResponse.getOrgUserHash(),\n                            apiResponse.getUserPushId(),\n                            deviceResponse.getAuthorizationRequestId(),\n                            \"AUTHORIZED\".equals(deviceResponse.getType()),\n                            deviceResponse.getDeviceId(),\n                            deviceResponse.getServicePins(),\n                            deviceResponse.getType(),\n                            deviceResponse.getReason(),\n                            deviceResponse.getDenialReason(),\n                            deviceResponse.getAuthPolicy(),\n                            deviceResponse.getAuthMethods()\n                    );\n\n                } else {\n                    RSAPrivateKey key = entityKeyMap.getKey(audience, apiResponse.getPublicKeyId());\n                    byte[] decrypted;\n                    try {\n                        byte[] encrypted = Base64.decodeBase64(apiResponse.getEncryptedDeviceResponse().getBytes());\n                        decrypted = crypto.decryptRSA(encrypted, key);\n                    } catch (Exception e) {\n                        throw new CryptographyError(\"Unable to decrypt device response!\", e);\n                    }\n                    ServiceV3AuthsGetResponseDevice deviceResponse =\n                            objectMapper.readValue(decrypted, ServiceV3AuthsGetResponseDevice.class);\n                    response = new ServiceV3AuthsGetResponse(\n                            audience,\n                            subject.getId(),\n                            apiResponse.getServiceUserHash(),\n                            apiResponse.getOrgUserHash(),\n                            apiResponse.getUserPushId(),\n                            deviceResponse.getAuthorizationRequestId(),\n                            deviceResponse.getResponse(),\n                            deviceResponse.getDeviceId(),\n                            deviceResponse.getServicePins(),\n                            null,\n                            null,\n                            null,\n                            null,\n                            null\n\n                    );\n                }\n            } catch (JsonParseException e) {\n                throw new MarshallingError(\"Unable to parse the decrypted device response!\", e);\n            } catch (JsonMappingException e) {\n                throw new MarshallingError(\"Unable to map the decrypted device response data!\", e);\n            } catch (IOException e) {\n                throw new CommunicationErrorException(\"An I\/O error occurred!\", e, null);\n            } catch (JWEFailure jweFailure) {\n                throw new CryptographyError(\"Unable to decrypt auth_jwe in response!\", jweFailure);\n            }\n        }\n        return response;\n    }\n\n    @Override\n    public void serviceV3AuthsDelete(UUID authRequestId, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError,\n            CryptographyError, InvalidCredentialsException {\n        String path = \"\/service\/v3\/auths\/\" + authRequestId.toString();\n        getHttpResponse(\"DELETE\", path, subject, null, true, null);\n    }\n\n    @Override\n    public void serviceV3SessionsPost(ServiceV3SessionsPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError,\n            CryptographyError, InvalidCredentialsException {\n        getHttpResponse(\"POST\", \"\/service\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    public void serviceV3SessionsDelete(ServiceV3SessionsDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/service\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    public ServiceV3TotpPostResponse serviceV3TotpPost(ServiceV3TotpPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError, InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/service\/v3\/totp\", subject, request, true, null);\n        return decryptResponse(response, ServiceV3TotpPostResponse.class);\n    }\n\n    @Override\n    public DirectoryV3DevicesPostResponse directoryV3DevicesPost(DirectoryV3DevicesPostRequest request,\n                                                                 EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/devices\", subject, request, true, null);\n        return decryptResponse(response, DirectoryV3DevicesPostResponse.class);\n    }\n\n    @Override\n    public DirectoryV3DevicesListPostResponse directoryV3DevicesListPost(DirectoryV3DevicesListPostRequest request,\n                                                                         EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/devices\/list\", subject, request, true, null);\n        DirectoryV3DevicesListPostResponseDevice[] devices =\n                decryptResponse(response, DirectoryV3DevicesListPostResponseDevice[].class);\n        return new DirectoryV3DevicesListPostResponse(Arrays.asList(devices));\n    }\n\n    @Override\n    public void directoryV3devicesDelete(DirectoryV3DevicesDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/devices\", subject, request, true, null);\n    }\n\n    @Override\n    public DirectoryV3SessionsListPostResponse directoryV3SessionsListPost(DirectoryV3SessionsListPostRequest request,\n                                                                           EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/sessions\/list\", subject, request, true, null);\n        DirectoryV3SessionsListPostResponseSession[] sessions =\n                decryptResponse(response, DirectoryV3SessionsListPostResponseSession[].class);\n        return new DirectoryV3SessionsListPostResponse(Arrays.asList(sessions));\n    }\n\n    @Override\n    public void directoryV3SessionsDelete(DirectoryV3SessionsDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    @Deprecated\n    public ServerSentEvent handleServerSentEvent(Map<String, List<String>> headers, String body)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException,\n            InvalidCredentialsException, CryptographyError, NoKeyFoundException {\n        return handleServerSentEvent(headers, null, null, body);\n    }\n\n    @Override\n    public ServerSentEvent handleServerSentEvent(Map<String, List<String>> headers, String method, String path, String body)\n        throws CommunicationErrorException, MarshallingError, InvalidResponseException, InvalidCredentialsException,\n            CryptographyError, NoKeyFoundException {\n\n        ServerSentEvent response;\n        HeaderGroup headerGroup = new HeaderGroup();\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            for (String item : entry.getValue()) {\n                headerGroup.addHeader(new BasicHeader(entry.getKey(), item));\n            }\n        }\n        String jwt = headerGroup.getFirstHeader(IOV_JWT_HEADER).getValue();\n        try {\n            JWTClaims jwtClaims = validateJWT(null, jwt, issuer.toString());\n            if (method != null && !method.equals(jwtClaims.getMethod())) {\n                throw new JWTError(\"JWT request method does not match the method provided\", null);\n            }\n            if (path != null && !path.equals(jwtClaims.getPath())) {\n                throw new JWTError(\"JWT request path does not match the path provided\", null);\n            }\n\n            ByteArrayOutputStream bodyStream = new ByteArrayOutputStream();\n            bodyStream.write(body.getBytes());\n            verifyContentHash(jwtClaims, bodyStream, \"request\");\n\n            if (headerGroup.getFirstHeader(\"Content-Type\").getValue().startsWith(\"application\/jose\")) {\n                \/\/ Auths response is encrypted\n                final EntityIdentifier requestingEntity = EntityIdentifier.fromString(jwtClaims.getAudience());\n                final String encryptionKeyId = jweService.getHeaders(body).get(\"kid\");\n                final RSAPrivateKey privateKey = entityKeyMap.getKey(requestingEntity, encryptionKeyId);\n                final String decrypted = jweService.decrypt(body, privateKey);\n\n                ServerSentEventType type = objectMapper.readValue(decrypted, ServerSentEventType.class);\n\n                if (ServerSentEventType.AUTHORIZATION_RESPONSE_WEBHOOK.equals(type.getType())) {\n                    response = handleAuthResponseServerSentEvent(jwtClaims, requestingEntity, privateKey, decrypted);\n                } else if (ServerSentEventType.DEVICE_LINK_COMPLETION_WEBHOOK.equals(type.getType())) {\n                    response = objectMapper.readValue(decrypted, ServerSentEventDeviceLinkCompletion.class);\n                } else {\n                    response = null;\n                    logger.warn(\"Unknown Webhook Type \\\"\" + type.getType() + \"\\\". Did not process.\");\n                }\n            } else {\n                \/\/ Session end is not encrypted\n                response = objectMapper.readValue(body, ServerSentEventUserServiceSessionEnd.class);\n            }\n        } catch (JWTError jwtError) {\n            throw new InvalidRequestException(\"Invalid JWT in the headers!\", jwtError, null);\n        } catch (JWEFailure jweFailure) {\n            throw new InvalidRequestException(\"Unable to decrypt the body!\", jweFailure, null);\n        } catch (JsonParseException e) {\n            throw new InvalidRequestException(\"Unable to parse the decrypted body as JSON!\", e, null);\n        } catch (JsonMappingException e) {\n            throw new InvalidRequestException(\"Unable to map the decrypted body JSON to a Map<String, Object>!\", e,\n                    null);\n        } catch (IOException e) {\n            throw new InvalidRequestException(\"Unable to read the body due to an I\/O error!\", e, null);\n        } catch (NoSuchAlgorithmException e) {\n            throw new InvalidRequestException(\"Invalid hash algorithm\", e, null);\n        }\n        return response;\n    }\n\n    private ServerSentEvent handleAuthResponseServerSentEvent(JWTClaims jwtClaims, EntityIdentifier requestingEntity,\n                                                              RSAPrivateKey privateKey, String decrypted\n    ) throws IOException, JWEFailure {\n        ServerSentEvent response;\n        final ServerSentEventAuthorizationResponseCore core =\n                objectMapper.readValue(decrypted, ServerSentEventAuthorizationResponseCore.class);\n        if (core.getAuthJwe() != null) {\n            final String decryptedDeviceResponse =\n                    jweService.decrypt(core.getAuthJwe(), privateKey);\n            final ServiceV3AuthsGetResponseDeviceJWE deviceResponse =\n                    objectMapper.readValue(decryptedDeviceResponse, ServiceV3AuthsGetResponseDeviceJWE.class);\n            response = new ServerSentEventAuthorizationResponse(\n                    requestingEntity,\n                    EntityIdentifier.fromString(jwtClaims.getSubject()).getId(),\n                    core.getServiceUserHash(),\n                    core.getOrgUserHash(),\n                    core.getUserPushId(),\n                    deviceResponse.getAuthorizationRequestId(),\n                    \"AUTHORIZED\".equals(deviceResponse.getType()),\n                    deviceResponse.getDeviceId(),\n                    deviceResponse.getServicePins(),\n                    deviceResponse.getType(),\n                    deviceResponse.getReason(),\n                    deviceResponse.getDenialReason()\n            );\n        } else {\n            final byte[] decryptedDeviceResponse =\n                    crypto.decryptRSA(BASE_64.decode(core.getAuth().getBytes()), privateKey);\n            final ServiceV3AuthsGetResponseDevice deviceResponse =\n                    objectMapper.readValue(decryptedDeviceResponse, ServiceV3AuthsGetResponseDevice.class);\n            response = new ServerSentEventAuthorizationResponse(\n                    requestingEntity,\n                    EntityIdentifier.fromString(jwtClaims.getSubject()).getId(),\n                    core.getServiceUserHash(),\n                    core.getOrgUserHash(),\n                    core.getUserPushId(),\n                    deviceResponse.getAuthorizationRequestId(),\n                    deviceResponse.getResponse(),\n                    deviceResponse.getDeviceId(),\n                    deviceResponse.getServicePins(),\n                    null,\n                    null,\n                    null\n            );\n        }\n        return response;\n    }\n\n    @Override\n    public OrganizationV3DirectoriesPostResponse organizationV3DirectoriesPost(\n            OrganizationV3DirectoriesPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException,\n            InvalidCredentialsException, CryptographyError {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/organization\/v3\/directories\", subject, request, true, null);\n        return decryptResponse(response, OrganizationV3DirectoriesPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3DirectoriesPatch(OrganizationV3DirectoriesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/directories\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectoriesGetResponse organizationV3DirectoriesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"GET\", \"\/organization\/v3\/directories\", subject, null, true, null);\n        OrganizationV3DirectoriesGetResponseDirectory[] directories =\n                decryptResponse(response, OrganizationV3DirectoriesGetResponseDirectory[].class);\n        return new OrganizationV3DirectoriesGetResponse(Arrays.asList(directories));\n    }\n\n    @Override\n    public OrganizationV3DirectoriesListPostResponse organizationV3DirectoriesListPost(\n            OrganizationV3DirectoriesListPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                    getHttpResponse(\"POST\", \"\/organization\/v3\/directories\/list\", subject, request, true, null);\n        return new OrganizationV3DirectoriesListPostResponse(Arrays.asList(\n                decryptResponse(httpResponse, OrganizationV3DirectoriesListPostResponseDirectory[].class)));\n    }\n\n    @Override\n    public KeysPostResponse organizationV3DirectoryKeysPost(OrganizationV3DirectoryKeysPostRequest request,\n                                                            EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public KeysListPostResponse organizationV3DirectoryKeysListPost(OrganizationV3DirectoryKeysListPostRequest request,\n                                                                    EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public void organizationV3DirectoryKeysPatch(OrganizationV3DirectoryKeysPatchRequest request,\n                                                 EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3DirectoryKeysDelete(OrganizationV3DirectoryKeysDeleteRequest request,\n                                                  EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectorySdkKeysPostResponse organizationV3DirectorySdkKeysPost(\n            OrganizationV3DirectorySdkKeysPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/sdk-keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, OrganizationV3DirectorySdkKeysPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3DirectorySdkKeysDelete(OrganizationV3DirectorySdkKeysDeleteRequest request,\n                                                     EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/directory\/sdk-keys\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectorySdkKeysListPostResponse organizationV3DirectorySdkKeysListPost(\n            OrganizationV3DirectorySdkKeysListPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/sdk-keys\/list\", subject, request, true, null);\n        final UUID[] sdkKeys = decryptResponse(httpResponse, UUID[].class);\n\n        return new OrganizationV3DirectorySdkKeysListPostResponse(Arrays.asList(sdkKeys));\n    }\n\n    @Override\n    public ServicesPostResponse organizationV3ServicesPost(ServicesPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/services\", subject, request, true, null);\n        return decryptResponse(httpResponse, ServicesPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3ServicesPatch(ServicesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/services\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesListPostResponse organizationV3ServicesListPost(ServicesListPostRequest request,\n                                                                   EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/services\/list\", subject, request, true, null);\n        return new ServicesListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesListPostResponseService[].class)));\n    }\n\n    @Override\n    public ServicesGetResponse organizationV3ServicesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"GET\", \"\/organization\/v3\/services\", subject, null, true, null);\n        return new ServicesGetResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesGetResponseService[].class)));\n    }\n\n    @Override\n    public KeysListPostResponse organizationV3ServiceKeysListPost(ServiceKeysListPostRequest request,\n                                                                  EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public KeysPostResponse organizationV3ServiceKeysPost(ServiceKeysPostRequest request,\n                                                          EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3ServiceKeysPatch(ServiceKeysPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3ServiceKeysDelete(ServiceKeysDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3ServicePolicyPut(ServicePolicyPutRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PUT\", \"\/organization\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n     @Override\n    public Policy organizationV3ServicePolicyItemPost(ServicePolicyItemPostRequest request,\n                                                             EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse response =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/policy\/item\", subject, request, true, null);\n        Policy policy = decryptResponse(response, Policy.class);\n        return policy;\n    }\n\n    @Override\n    public void organizationV3ServicePolicyDelete(ServicePolicyDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesPostResponse directoryV3ServicesPost(ServicesPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/services\", subject, request, true, null);\n        return decryptResponse(httpResponse, ServicesPostResponse.class);\n    }\n\n    @Override\n    public void directoryV3ServicesPatch(ServicesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/directory\/v3\/services\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesListPostResponse directoryV3ServicesListPost(ServicesListPostRequest request,\n                                                                EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/services\/list\", subject, request, true, null);\n        return new ServicesListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesListPostResponseService[].class)));\n    }\n\n    @Override\n    public ServicesGetResponse directoryV3ServicesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"GET\", \"\/directory\/v3\/services\", subject, null, true, null);\n        return new ServicesGetResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesGetResponseService[].class)));\n    }\n\n    @Override\n    public KeysPostResponse directoryV3ServiceKeysPost(ServiceKeysPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public KeysListPostResponse directoryV3ServiceKeysListPost(ServiceKeysListPostRequest request,\n                                                               EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public void directoryV3ServiceKeysDelete(ServiceKeysDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void directoryV3ServiceKeysPatch(ServiceKeysPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void directoryV3ServicePolicyPut(ServicePolicyPutRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PUT\", \"\/directory\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public Policy directoryV3ServicePolicyItemPost(ServicePolicyItemPostRequest request,\n                                                   EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/policy\/item\", subject, request, true, null);\n        Policy policy = decryptResponse(response, Policy.class);\n        return policy;\n    }\n\n    @Override\n    public void directoryV3ServicePolicyDelete(ServicePolicyDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public DirectoryV3TotpPostResponse directoryV3TotpPost(DirectoryV3TotpPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\" , \"\/directory\/v3\/totp\", subject, request, true, null);\n        return decryptResponse(response, DirectoryV3TotpPostResponse.class);\n    }\n\n    @Override\n    public void directoryV3TotpDelete(DirectoryV3TotpDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\" , \"\/directory\/v3\/totp\", subject, request, true, null);\n    }\n\n    protected HttpResponse getHttpResponse(\n            String method, String path, EntityIdentifier subjectEntity, Object transportObject, boolean signRequest,\n            List<Integer> httpStatusCodeWhiteList)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n\n        PublicKey publicKey;\n        String publicKeyFingerprint;\n        Date currentDate;\n        String subject;\n        if (signRequest) {\n            PublicKeyData publicKeyData = getCurrentPublicKeyData();\n            publicKey = publicKeyData.getKey();\n            publicKeyFingerprint = publicKeyData.getFingerprint();\n            currentDate = getCurrentDate();\n            subject = subjectEntity.toString();\n        } else {\n            publicKey = null;\n            publicKeyFingerprint = null;\n            currentDate = null;\n            subject = null;\n        }\n\n        String requestId = UUID.randomUUID().toString();\n        HttpUriRequest request = rbf.create(publicKey, publicKeyFingerprint, currentDate)\n                .setMethod(method)\n                .setPath(path)\n                .setSubject(subject)\n                .setTransportObject(transportObject)\n                .build(requestId);\n        try {\n            HttpResponse response = httpClient.execute(request);\n            if (response == null) {\n                throw new InvalidResponseException(\"No response returned from HTTP client\", null, null);\n            }\n            response = new ReplayHttpResponse(response);\n            if (signRequest) {\n                validateResponseJWT(response, requestId);\n            }\n            throwForStatus(response, httpStatusCodeWhiteList == null ? new ArrayList<Integer>() : httpStatusCodeWhiteList);\n            return response;\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"An I\/O Error Occurred\", e, null);\n        }\n    }\n\n    private void throwForStatus(HttpResponse response, List<Integer> httpStatusCodeWhiteList)\n            throws CommunicationErrorException, InvalidResponseException, CryptographyError {\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCodeWhiteList.contains(statusCode)) {\n            logger.debug(\"Did not throw for status as it was in white list\");\n        } else if (statusCode == 400 || statusCode == 409) {\n            final HttpEntity httpEntity = response.getEntity();\n            if (httpEntity == null || httpEntity.getContentLength() == 0) {\n                throw new InvalidRequestException(\n                        response.getStatusLine().getReasonPhrase(),\n                        null,\n                        \"HTTP-\" + statusCode\n                );\n            } else {\n                com.iovation.launchkey.sdk.transport.domain.Error error = decryptResponse(response, Error.class);\n                throw InvalidRequestException.fromError(error);\n            }\n        } else if (!(statusCode >= 200 && statusCode < 300)) {\n            String message = \"HTTP Error: [\" + String.valueOf(statusCode)\n                    + \"] \" + response.getStatusLine().getReasonPhrase();\n            throw CommunicationErrorException.fromStatusCode(statusCode, message);\n        }\n    }\n\n    protected <T> T decryptResponse(HttpResponse response, Class<T> type)\n            throws InvalidResponseException, CommunicationErrorException, CryptographyError {\n        ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n        try {\n            response.getEntity().writeTo(encrypted);\n            String json = jweService.decrypt(encrypted.toString());\n            return objectMapper.readValue(json, type);\n        } catch (JsonParseException | JsonMappingException e) {\n            throw new InvalidResponseException(\"Unable to parse response as JSON\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"AN IO Error Occurred\", e, null);\n        } catch (JWEFailure jweFailure) {\n            throw new CryptographyError(\"Unable to decrypt response!\", jweFailure);\n        }\n    }\n\n    private <T> T parseJsonResponse(HttpEntity entity, Class<T> valueType)\n            throws InvalidResponseException, CommunicationErrorException {\n        try {\n            return objectMapper.readValue(entity.getContent(), valueType);\n        } catch (JsonParseException | JsonMappingException e) {\n            throw new InvalidResponseException(\"Unable to parse response as JSON\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"AN IO Error Occurred\", e, null);\n        }\n    }\n\n    private void validateResponseJWT(HttpResponse response, String expectedTokenId)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        try {\n\n            final String jwt = getJWT(response);\n            String expectedAudience;\n            if (response.getStatusLine().getStatusCode() == 401) {\n                expectedAudience = \"public\";\n            } else {\n                expectedAudience = issuer.toString();\n            }\n            final JWTClaims claims = validateJWT(expectedTokenId, jwt, expectedAudience);\n            HttpEntity entity = response.getEntity();\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            if (entity != null) entity.writeTo(stream);\n            if (claims.getStatusCode() != response.getStatusLine().getStatusCode())\n                throw new JWTError(\"Status code of response content does not match JWT response status code\", null);\n\n            verifyContentHash(claims, stream, \"response\");\n\n            if ((response.containsHeader(\"Location\") &&\n                            !response.getFirstHeader(\"Location\").getValue().equals(claims.getLocationHeader()))\n                    || (!response.containsHeader(\"Location\") && claims.getLocationHeader() != null)\n            ) throw new JWTError(\"Location header of response content does not match JWT response location\", null);\n\n            if ((response.containsHeader(\"Cache-Control\") &&\n                    !response.getFirstHeader(\"Cache-Control\").getValue().equals(claims.getCacheControlHeader()))\n                || (!response.containsHeader(\"Cache-Control\") && claims.getCacheControlHeader() != null)\n            ) throw new JWTError(\"Cache-Control header of response content does not match JWT response cache\", null);\n\n\n        } catch (JWTError jwtError) {\n            throw new InvalidResponseException(\"Invalid JWT in response!\", jwtError, null);\n        } catch (NoSuchAlgorithmException | IOException e ) {\n            throw new CryptographyError(\"An error occurred validating the body hash\", e);\n        }\n    }\n\n    private void verifyContentHash(JWTClaims claims, ByteArrayOutputStream stream, String type) throws NoSuchAlgorithmException, JWTError {\n        String contentHashAlgorithm = claims.getContentHashAlgorithm();\n        if (stream.size() > 0 && contentHashAlgorithm != null) {\n            String hash;\n            if (claims.getContentHashAlgorithm().equals(\"S256\")) {\n                hash = Hex.encodeHexString(crypto.sha256(stream.toByteArray()));\n            } else if (claims.getContentHashAlgorithm().equals(\"S384\")) {\n                hash = Hex.encodeHexString(crypto.sha384(stream.toByteArray()));\n            } else if (claims.getContentHashAlgorithm().equals(\"S512\")) {\n                hash = Hex.encodeHexString(crypto.sha512(stream.toByteArray()));\n            } else {\n                throw new JWTError(\"Hash of \" + type + \" content uses unsupported algorithm of \" +\n                        claims.getContentHashAlgorithm(), null);\n            }\n            if (claims.getContentHash() == null || !hash.equals(claims.getContentHash()))\n                throw new JWTError(\"Hash of \" + type + \" content does not match JWT \" + type + \" hash\", null);\n        } else if (stream.size() > 0 && claims.getContentHashAlgorithm() == null) {\n            throw new JWTError(\"No content hash algorithm found in JWT and there was content!\", null);\n        } else if (stream.size() == 0 && claims.getContentHashAlgorithm() != null) {\n            throw new JWTError(\"Content hash algorithm found in JWT and there was no content!\", null);\n        } else if (stream.size() == 0 && claims.getContentHash() != null) {\n            throw new JWTError(\"Content hash found in JWT and there was no content!\", null);\n        }\n    }\n\n    private JWTClaims validateJWT(String expectedTokenId, String jwt, String expected_audience)\n            throws JWTError, MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        String keyId = jwtService.getJWTData(jwt).getKeyId();\n        return jwtService.decode(\n                getPublicKeyData(keyId).getKey(), expected_audience, expectedTokenId, getCurrentDate(), jwt);\n    }\n\n    private String getJWT(HttpResponse response) {\n        return response.getFirstHeader(IOV_JWT_HEADER).getValue();\n    }\n\n\n    private PublicKeyData getCurrentPublicKeyData()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        if (currentPublicKeyDataExpires == null || currentPublicKeyDataExpires.before(new Date())) {\n            setCurrentPublicKeyData();\n        }\n        return currentPublicKeyData;\n\n    }\n\n    private synchronized void setCurrentPublicKeyData()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        currentPublicKeyData = getPublicKeyData(null);\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date());\n        calendar.add(Calendar.SECOND, currentPublicKeyTTL);\n        currentPublicKeyDataExpires = calendar.getTime();\n    }\n\n    private PublicKeyData getPublicKeyData(String fingerprint)\n            throws MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        PublicKeyData publicKeyData = null;\n\n        if (fingerprint != null) {\n            String cacheKey = \"LaunchKeyPublicKey:\" + fingerprint;\n            String publicKey = null;\n            try {\n                publicKey = publicKeyCache.get(cacheKey);\n            } catch (CacheException e) {\n                logger.error(\"Unable to retrieve public key from cache. This will degrade performance.\", e);\n            }\n            if (publicKey != null) {\n                try {\n                    publicKeyData = new PublicKeyData(\n                            crypto.getRSAPublicKeyFromPEM(publicKey),\n                            fingerprint\n                    );\n                } catch (IllegalArgumentException e) {\n                    \/\/ The stored key cannot be parsed. Do nothing, the next step will get a new key.\n                    \/\/ If the exception was raised due to a missing algorithm, it will fail in that step as well.\n                }\n            }\n        }\n\n        \/\/ If the key was not in cache or the cached version was not valid,\n        \/\/ get it from the API and store it in the cache\n        if (publicKeyData == null) {\n            PublicV3PublicKeyGetResponse apiKey = publicV3PublicKeyGet(fingerprint);\n            publicKeyData = new PublicKeyData(\n                    crypto.getRSAPublicKeyFromPEM(apiKey.getPublicKey()), apiKey.getPublicKeyFingerprint());\n            try {\n                publicKeyCache.put(\"LaunchKeyPublicKey:\" + apiKey.getPublicKeyFingerprint(), apiKey.getPublicKey());\n            } catch (CacheException e) {\n                logger.error(\"Unable to cache public key. This will degrade performance.\", e);\n            }\n        }\n        return publicKeyData;\n    }\n\n    private Date getCurrentDate()\n            throws MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        if (serverTimeOffsetExpires == null || serverTimeOffsetExpires.before(new Date())) {\n            setServerTimeOffset();\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date());\n        calendar.add(Calendar.MILLISECOND, serverTimeOffset);\n        return calendar.getTime();\n    }\n\n    private synchronized void setServerTimeOffset()\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        Date now = new Date();\n        PublicV3PingGetResponse response = publicV3PingGet();\n        serverTimeOffset = new Long(response.getApiTime().getTime() - now.getTime()).intValue();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(now);\n        calendar.add(Calendar.SECOND, offsetTTL);\n        serverTimeOffsetExpires = calendar.getTime();\n    }\n\n    private class PublicKeyData {\n        private final PublicKey key;\n        private final String fingerprint;\n\n        private PublicKeyData(PublicKey key, String fingerprint) {\n            this.key = key;\n            this.fingerprint = fingerprint;\n        }\n\n        public PublicKey getKey() {\n            return key;\n        }\n\n        public String getFingerprint() {\n            return fingerprint;\n        }\n    }\n}\n","new_contents":"package com.iovation.launchkey.sdk.transport.apachehttp;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.iovation.launchkey.sdk.cache.Cache;\nimport com.iovation.launchkey.sdk.cache.CacheException;\nimport com.iovation.launchkey.sdk.crypto.Crypto;\nimport com.iovation.launchkey.sdk.crypto.jwe.JWEFailure;\nimport com.iovation.launchkey.sdk.crypto.jwe.JWEService;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTClaims;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTData;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTError;\nimport com.iovation.launchkey.sdk.crypto.jwt.JWTService;\nimport com.iovation.launchkey.sdk.domain.policy.LegacyPolicy;\nimport com.iovation.launchkey.sdk.error.*;\nimport com.iovation.launchkey.sdk.transport.Transport;\nimport com.iovation.launchkey.sdk.transport.domain.Error;\nimport com.iovation.launchkey.sdk.transport.domain.*;\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.apache.http.message.BasicHeader;\nimport org.apache.http.message.HeaderGroup;\nimport org.apache.http.util.EntityUtils;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.util.*;\n\npublic class ApacheHttpTransport implements Transport {\n\n    private static final Base64 BASE_64 = new Base64(0);\n    private static final String IOV_JWT_HEADER = \"X-IOV-JWT\";\n    private static int serverTimeOffset = 0;\n    private static Date serverTimeOffsetExpires = null;\n    private final Log logger;\n    private final EntityKeyMap entityKeyMap;\n    private PublicKeyData currentPublicKeyData = null;\n    private Date currentPublicKeyDataExpires = null;\n\n    private final ApiRequestBuilderFactory rbf;\n    private final ObjectMapper objectMapper;\n    private final Crypto crypto;\n    private final HttpClient httpClient;\n    private final JWTService jwtService;\n    private final JWEService jweService;\n    private final Cache publicKeyCache;\n    private final int offsetTTL;\n    private final int currentPublicKeyTTL;\n    private final EntityIdentifier issuer;\n\n\n    public ApacheHttpTransport(HttpClient httpClient, Crypto crypto, ObjectMapper objectMapper,\n                               Cache publicKeyCache, String baseUrl, EntityIdentifier issuer,\n                               JWTService jwtService, JWEService jweService,\n                               int offsetTTL, int currentPublicKeyTTL, EntityKeyMap entityKeyMap\n    ) {\n        this.objectMapper = objectMapper;\n        this.objectMapper.setDateFormat(new StdDateFormat());\n        this.crypto = crypto;\n        this.httpClient = httpClient;\n        this.jwtService = jwtService;\n        this.jweService = jweService;\n        this.publicKeyCache = publicKeyCache;\n        this.entityKeyMap = entityKeyMap;\n        this.offsetTTL = offsetTTL;\n        this.currentPublicKeyTTL = currentPublicKeyTTL;\n        this.issuer = issuer;\n        logger = LogFactory.getLog(getClass());\n        rbf = new ApiRequestBuilderFactory(issuer.toString(), baseUrl, objectMapper, crypto, jwtService, jweService);\n    }\n\n    @Override\n    public PublicV3PingGetResponse publicV3PingGet()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"GET\", \"\/public\/v3\/ping\", null, null, false, null);\n        return parseJsonResponse(response.getEntity(), PublicV3PingGetResponse.class);\n    }\n\n    @Override\n    public PublicV3PublicKeyGetResponse publicV3PublicKeyGet(String publicKeyFingerprint)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n\n        String path = \"\/public\/v3\/public-key\";\n        if (publicKeyFingerprint != null) {\n            path = path + \"\/\" + publicKeyFingerprint;\n        }\n        HttpResponse response = getHttpResponse(\"GET\", path, null, null, false, null);\n        Header keyHeader = response.getFirstHeader(\"X-IOV-KEY-ID\");\n        if (keyHeader == null) {\n            throw new InvalidResponseException(\"Public Key ID header X-IOV-KEY-ID not found in response\", null, null);\n        }\n        try {\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new InvalidResponseException(\"No public key in response\", null, null);\n            }\n            String publicKey = EntityUtils.toString(entity);\n            return new PublicV3PublicKeyGetResponse(publicKey, keyHeader.getValue());\n        } catch (IllegalArgumentException e) {\n            throw new InvalidResponseException(\"Invalid public key in response.\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"Error reading response\", e, null);\n        }\n    }\n\n    @Override\n    public ServiceV3AuthsPostResponse serviceV3AuthsPost(ServiceV3AuthsPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/service\/v3\/auths\", subject, request, true, null);\n        return decryptResponse(response, ServiceV3AuthsPostResponse.class);\n    }\n\n    @Override\n    public ServiceV3AuthsGetResponse serviceV3AuthsGet(UUID authRequestId, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException, AuthorizationRequestTimedOutError,\n            NoKeyFoundException {\n        ServiceV3AuthsGetResponse response;\n        HttpResponse httpResponse;\n\n        String path = \"\/service\/v3\/auths\/\" + authRequestId.toString();\n        try {\n            httpResponse = getHttpResponse(\"GET\", path, subject, null, true, null);\n        } catch (RequestTimedOut e) {\n            throw new AuthorizationRequestTimedOutError();\n        }\n\n        int statusCode = httpResponse.getStatusLine().getStatusCode();\n        if (statusCode == 204) { \/\/ User has not responded\n            response = null;\n        } else { \/\/ Users responded\n            ServiceV3AuthsGetResponseCore apiResponse =\n                    decryptResponse(httpResponse, ServiceV3AuthsGetResponseCore.class);\n\n            EntityIdentifier audience;\n            try {\n                JWTData jwtData = jwtService.getJWTData(getJWT(httpResponse));\n                audience = EntityIdentifier.fromString(jwtData.getAudience());\n            } catch (JWTError jwtError){\n                    throw new CryptographyError(\"Unable to parse JWT to get key info!\", jwtError);\n            }\n            try {\n                if (apiResponse.getJweEncryptedDeviceResponse() != null) {\n                    String decrypted = jweService.decrypt(apiResponse.getJweEncryptedDeviceResponse());\n                    ServiceV3AuthsGetResponseDeviceJWE deviceResponse =\n                            objectMapper.readValue(decrypted, ServiceV3AuthsGetResponseDeviceJWE.class);\n                    response =  new ServiceV3AuthsGetResponse(\n                            audience,\n                            subject.getId(),\n                            apiResponse.getServiceUserHash(),\n                            apiResponse.getOrgUserHash(),\n                            apiResponse.getUserPushId(),\n                            deviceResponse.getAuthorizationRequestId(),\n                            \"AUTHORIZED\".equals(deviceResponse.getType()),\n                            deviceResponse.getDeviceId(),\n                            deviceResponse.getServicePins(),\n                            deviceResponse.getType(),\n                            deviceResponse.getReason(),\n                            deviceResponse.getDenialReason(),\n                            deviceResponse.getAuthPolicy(),\n                            deviceResponse.getAuthMethods()\n                    );\n\n                } else {\n                    RSAPrivateKey key = entityKeyMap.getKey(audience, apiResponse.getPublicKeyId());\n                    byte[] decrypted;\n                    try {\n                        byte[] encrypted = Base64.decodeBase64(apiResponse.getEncryptedDeviceResponse().getBytes());\n                        decrypted = crypto.decryptRSA(encrypted, key);\n                    } catch (Exception e) {\n                        throw new CryptographyError(\"Unable to decrypt device response!\", e);\n                    }\n                    ServiceV3AuthsGetResponseDevice deviceResponse =\n                            objectMapper.readValue(decrypted, ServiceV3AuthsGetResponseDevice.class);\n                    response = new ServiceV3AuthsGetResponse(\n                            audience,\n                            subject.getId(),\n                            apiResponse.getServiceUserHash(),\n                            apiResponse.getOrgUserHash(),\n                            apiResponse.getUserPushId(),\n                            deviceResponse.getAuthorizationRequestId(),\n                            deviceResponse.getResponse(),\n                            deviceResponse.getDeviceId(),\n                            deviceResponse.getServicePins(),\n                            null,\n                            null,\n                            null,\n                            null,\n                            null\n\n                    );\n                }\n            } catch (JsonParseException e) {\n                throw new MarshallingError(\"Unable to parse the decrypted device response!\", e);\n            } catch (JsonMappingException e) {\n                throw new MarshallingError(\"Unable to map the decrypted device response data!\", e);\n            } catch (IOException e) {\n                throw new CommunicationErrorException(\"An I\/O error occurred!\", e, null);\n            } catch (JWEFailure jweFailure) {\n                throw new CryptographyError(\"Unable to decrypt auth_jwe in response!\", jweFailure);\n            }\n        }\n        return response;\n    }\n\n    @Override\n    public void serviceV3AuthsDelete(UUID authRequestId, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError,\n            CryptographyError, InvalidCredentialsException {\n        String path = \"\/service\/v3\/auths\/\" + authRequestId.toString();\n        getHttpResponse(\"DELETE\", path, subject, null, true, null);\n    }\n\n    @Override\n    public void serviceV3SessionsPost(ServiceV3SessionsPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError,\n            CryptographyError, InvalidCredentialsException {\n        getHttpResponse(\"POST\", \"\/service\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    public void serviceV3SessionsDelete(ServiceV3SessionsDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/service\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    public ServiceV3TotpPostResponse serviceV3TotpPost(ServiceV3TotpPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError, InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/service\/v3\/totp\", subject, request, true, null);\n        return decryptResponse(response, ServiceV3TotpPostResponse.class);\n    }\n\n    @Override\n    public DirectoryV3DevicesPostResponse directoryV3DevicesPost(DirectoryV3DevicesPostRequest request,\n                                                                 EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/devices\", subject, request, true, null);\n        return decryptResponse(response, DirectoryV3DevicesPostResponse.class);\n    }\n\n    @Override\n    public DirectoryV3DevicesListPostResponse directoryV3DevicesListPost(DirectoryV3DevicesListPostRequest request,\n                                                                         EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/devices\/list\", subject, request, true, null);\n        DirectoryV3DevicesListPostResponseDevice[] devices =\n                decryptResponse(response, DirectoryV3DevicesListPostResponseDevice[].class);\n        return new DirectoryV3DevicesListPostResponse(Arrays.asList(devices));\n    }\n\n    @Override\n    public void directoryV3devicesDelete(DirectoryV3DevicesDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/devices\", subject, request, true, null);\n    }\n\n    @Override\n    public DirectoryV3SessionsListPostResponse directoryV3SessionsListPost(DirectoryV3SessionsListPostRequest request,\n                                                                           EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/directory\/v3\/sessions\/list\", subject, request, true, null);\n        DirectoryV3SessionsListPostResponseSession[] sessions =\n                decryptResponse(response, DirectoryV3SessionsListPostResponseSession[].class);\n        return new DirectoryV3SessionsListPostResponse(Arrays.asList(sessions));\n    }\n\n    @Override\n    public void directoryV3SessionsDelete(DirectoryV3SessionsDeleteRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/sessions\", subject, request, true, null);\n    }\n\n    @Override\n    @Deprecated\n    public ServerSentEvent handleServerSentEvent(Map<String, List<String>> headers, String body)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException,\n            InvalidCredentialsException, CryptographyError, NoKeyFoundException {\n        return handleServerSentEvent(headers, null, null, body);\n    }\n\n    @Override\n    public ServerSentEvent handleServerSentEvent(Map<String, List<String>> headers, String method, String path, String body)\n        throws CommunicationErrorException, MarshallingError, InvalidResponseException, InvalidCredentialsException,\n            CryptographyError, NoKeyFoundException {\n\n        ServerSentEvent response;\n        HeaderGroup headerGroup = new HeaderGroup();\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            for (String item : entry.getValue()) {\n                headerGroup.addHeader(new BasicHeader(entry.getKey(), item));\n            }\n        }\n        String jwt = headerGroup.getFirstHeader(IOV_JWT_HEADER).getValue();\n        try {\n            JWTClaims jwtClaims = validateJWT(null, jwt, issuer.toString());\n            if (method != null && !method.equals(jwtClaims.getMethod())) {\n                throw new JWTError(\"JWT request method does not match the method provided\", null);\n            }\n            if (path != null && !path.equals(jwtClaims.getPath())) {\n                throw new JWTError(\"JWT request path does not match the path provided\", null);\n            }\n\n            ByteArrayOutputStream bodyStream = new ByteArrayOutputStream();\n            bodyStream.write(body.getBytes());\n            verifyContentHash(jwtClaims, bodyStream, \"request\");\n\n            if (headerGroup.getFirstHeader(\"Content-Type\").getValue().startsWith(\"application\/jose\")) {\n                \/\/ Auths response is encrypted\n                final EntityIdentifier requestingEntity = EntityIdentifier.fromString(jwtClaims.getAudience());\n                final String encryptionKeyId = jweService.getHeaders(body).get(\"kid\");\n                final RSAPrivateKey privateKey = entityKeyMap.getKey(requestingEntity, encryptionKeyId);\n                final String decrypted = jweService.decrypt(body, privateKey);\n\n                ServerSentEventType type = objectMapper.readValue(decrypted, ServerSentEventType.class);\n\n                if (ServerSentEventType.AUTHORIZATION_RESPONSE_WEBHOOK.equals(type.getType())) {\n                    response = handleAuthResponseServerSentEvent(jwtClaims, requestingEntity, privateKey, decrypted);\n                } else if (ServerSentEventType.DEVICE_LINK_COMPLETION_WEBHOOK.equals(type.getType())) {\n                    response = objectMapper.readValue(decrypted, ServerSentEventDeviceLinkCompletion.class);\n                } else {\n                    response = null;\n                    logger.warn(\"Unknown Webhook Type \\\"\" + type.getType() + \"\\\". Did not process.\");\n                }\n            } else {\n                \/\/ Session end is not encrypted\n                response = objectMapper.readValue(body, ServerSentEventUserServiceSessionEnd.class);\n            }\n        } catch (JWTError jwtError) {\n            throw new InvalidRequestException(\"Invalid JWT in the headers!\", jwtError, null);\n        } catch (JWEFailure jweFailure) {\n            throw new InvalidRequestException(\"Unable to decrypt the body!\", jweFailure, null);\n        } catch (JsonParseException e) {\n            throw new InvalidRequestException(\"Unable to parse the decrypted body as JSON!\", e, null);\n        } catch (JsonMappingException e) {\n            throw new InvalidRequestException(\"Unable to map the decrypted body JSON to a Map<String, Object>!\", e,\n                    null);\n        } catch (IOException e) {\n            throw new InvalidRequestException(\"Unable to read the body due to an I\/O error!\", e, null);\n        } catch (NoSuchAlgorithmException e) {\n            throw new InvalidRequestException(\"Invalid hash algorithm\", e, null);\n        }\n        return response;\n    }\n\n    private ServerSentEvent handleAuthResponseServerSentEvent(JWTClaims jwtClaims, EntityIdentifier requestingEntity,\n                                                              RSAPrivateKey privateKey, String decrypted\n    ) throws IOException, JWEFailure {\n        ServerSentEvent response;\n        final ServerSentEventAuthorizationResponseCore core =\n                objectMapper.readValue(decrypted, ServerSentEventAuthorizationResponseCore.class);\n        if (core.getAuthJwe() != null) {\n            final String decryptedDeviceResponse =\n                    jweService.decrypt(core.getAuthJwe(), privateKey);\n            final ServiceV3AuthsGetResponseDeviceJWE deviceResponse =\n                    objectMapper.readValue(decryptedDeviceResponse, ServiceV3AuthsGetResponseDeviceJWE.class);\n            response = new ServerSentEventAuthorizationResponse(\n                    requestingEntity,\n                    EntityIdentifier.fromString(jwtClaims.getSubject()).getId(),\n                    core.getServiceUserHash(),\n                    core.getOrgUserHash(),\n                    core.getUserPushId(),\n                    deviceResponse.getAuthorizationRequestId(),\n                    \"AUTHORIZED\".equals(deviceResponse.getType()),\n                    deviceResponse.getDeviceId(),\n                    deviceResponse.getServicePins(),\n                    deviceResponse.getType(),\n                    deviceResponse.getReason(),\n                    deviceResponse.getDenialReason()\n            );\n        } else {\n            final byte[] decryptedDeviceResponse =\n                    crypto.decryptRSA(BASE_64.decode(core.getAuth().getBytes()), privateKey);\n            final ServiceV3AuthsGetResponseDevice deviceResponse =\n                    objectMapper.readValue(decryptedDeviceResponse, ServiceV3AuthsGetResponseDevice.class);\n            response = new ServerSentEventAuthorizationResponse(\n                    requestingEntity,\n                    EntityIdentifier.fromString(jwtClaims.getSubject()).getId(),\n                    core.getServiceUserHash(),\n                    core.getOrgUserHash(),\n                    core.getUserPushId(),\n                    deviceResponse.getAuthorizationRequestId(),\n                    deviceResponse.getResponse(),\n                    deviceResponse.getDeviceId(),\n                    deviceResponse.getServicePins(),\n                    null,\n                    null,\n                    null\n            );\n        }\n        return response;\n    }\n\n    @Override\n    public OrganizationV3DirectoriesPostResponse organizationV3DirectoriesPost(\n            OrganizationV3DirectoriesPostRequest request, EntityIdentifier subject)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException,\n            InvalidCredentialsException, CryptographyError {\n        HttpResponse response = getHttpResponse(\"POST\", \"\/organization\/v3\/directories\", subject, request, true, null);\n        return decryptResponse(response, OrganizationV3DirectoriesPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3DirectoriesPatch(OrganizationV3DirectoriesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/directories\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectoriesGetResponse organizationV3DirectoriesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"GET\", \"\/organization\/v3\/directories\", subject, null, true, null);\n        OrganizationV3DirectoriesGetResponseDirectory[] directories =\n                decryptResponse(response, OrganizationV3DirectoriesGetResponseDirectory[].class);\n        return new OrganizationV3DirectoriesGetResponse(Arrays.asList(directories));\n    }\n\n    @Override\n    public OrganizationV3DirectoriesListPostResponse organizationV3DirectoriesListPost(\n            OrganizationV3DirectoriesListPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                    getHttpResponse(\"POST\", \"\/organization\/v3\/directories\/list\", subject, request, true, null);\n        return new OrganizationV3DirectoriesListPostResponse(Arrays.asList(\n                decryptResponse(httpResponse, OrganizationV3DirectoriesListPostResponseDirectory[].class)));\n    }\n\n    @Override\n    public KeysPostResponse organizationV3DirectoryKeysPost(OrganizationV3DirectoryKeysPostRequest request,\n                                                            EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public KeysListPostResponse organizationV3DirectoryKeysListPost(OrganizationV3DirectoryKeysListPostRequest request,\n                                                                    EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public void organizationV3DirectoryKeysPatch(OrganizationV3DirectoryKeysPatchRequest request,\n                                                 EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3DirectoryKeysDelete(OrganizationV3DirectoryKeysDeleteRequest request,\n                                                  EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/directory\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectorySdkKeysPostResponse organizationV3DirectorySdkKeysPost(\n            OrganizationV3DirectorySdkKeysPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/sdk-keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, OrganizationV3DirectorySdkKeysPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3DirectorySdkKeysDelete(OrganizationV3DirectorySdkKeysDeleteRequest request,\n                                                     EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/directory\/sdk-keys\", subject, request, true, null);\n    }\n\n    @Override\n    public OrganizationV3DirectorySdkKeysListPostResponse organizationV3DirectorySdkKeysListPost(\n            OrganizationV3DirectorySdkKeysListPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/directory\/sdk-keys\/list\", subject, request, true, null);\n        final UUID[] sdkKeys = decryptResponse(httpResponse, UUID[].class);\n\n        return new OrganizationV3DirectorySdkKeysListPostResponse(Arrays.asList(sdkKeys));\n    }\n\n    @Override\n    public ServicesPostResponse organizationV3ServicesPost(ServicesPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/services\", subject, request, true, null);\n        return decryptResponse(httpResponse, ServicesPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3ServicesPatch(ServicesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/services\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesListPostResponse organizationV3ServicesListPost(ServicesListPostRequest request,\n                                                                   EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/services\/list\", subject, request, true, null);\n        return new ServicesListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesListPostResponseService[].class)));\n    }\n\n    @Override\n    public ServicesGetResponse organizationV3ServicesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"GET\", \"\/organization\/v3\/services\", subject, null, true, null);\n        return new ServicesGetResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesGetResponseService[].class)));\n    }\n\n    @Override\n    public KeysListPostResponse organizationV3ServiceKeysListPost(ServiceKeysListPostRequest request,\n                                                                  EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public KeysPostResponse organizationV3ServiceKeysPost(ServiceKeysPostRequest request,\n                                                          EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public void organizationV3ServiceKeysPatch(ServiceKeysPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3ServiceKeysDelete(ServiceKeysDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void organizationV3ServicePolicyPut(ServicePolicyPutRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PUT\", \"\/organization\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n     @Override\n    public Policy organizationV3ServicePolicyItemPost(ServicePolicyItemPostRequest request,\n                                                             EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse response =\n                getHttpResponse(\"POST\", \"\/organization\/v3\/service\/policy\/item\", subject, request, true, null);\n        Policy policy = decryptResponse(response, Policy.class);\n        return policy;\n    }\n\n    @Override\n    public void organizationV3ServicePolicyDelete(ServicePolicyDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/organization\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesPostResponse directoryV3ServicesPost(ServicesPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/services\", subject, request, true, null);\n        return decryptResponse(httpResponse, ServicesPostResponse.class);\n    }\n\n    @Override\n    public void directoryV3ServicesPatch(ServicesPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/directory\/v3\/services\", subject, request, true, null);\n    }\n\n    @Override\n    public ServicesListPostResponse directoryV3ServicesListPost(ServicesListPostRequest request,\n                                                                EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/services\/list\", subject, request, true, null);\n        return new ServicesListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesListPostResponseService[].class)));\n    }\n\n    @Override\n    public ServicesGetResponse directoryV3ServicesGet(EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"GET\", \"\/directory\/v3\/services\", subject, null, true, null);\n        return new ServicesGetResponse(\n                Arrays.asList(decryptResponse(httpResponse, ServicesGetResponseService[].class)));\n    }\n\n    @Override\n    public KeysPostResponse directoryV3ServiceKeysPost(ServiceKeysPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n        return decryptResponse(httpResponse, KeysPostResponse.class);\n    }\n\n    @Override\n    public KeysListPostResponse directoryV3ServiceKeysListPost(ServiceKeysListPostRequest request,\n                                                               EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        final HttpResponse httpResponse =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/keys\/list\", subject, request, true, null);\n        return new KeysListPostResponse(\n                Arrays.asList(decryptResponse(httpResponse, KeysListPostResponsePublicKey[].class)));\n    }\n\n    @Override\n    public void directoryV3ServiceKeysDelete(ServiceKeysDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void directoryV3ServiceKeysPatch(ServiceKeysPatchRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PATCH\", \"\/directory\/v3\/service\/keys\", subject, request, true, null);\n    }\n\n    @Override\n    public void directoryV3ServicePolicyPut(ServicePolicyPutRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"PUT\", \"\/directory\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public Policy directoryV3ServicePolicyItemPost(ServicePolicyItemPostRequest request,\n                                                   EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response =\n                getHttpResponse(\"POST\", \"\/directory\/v3\/service\/policy\/item\", subject, request, true, null);\n        Policy policy = decryptResponse(response, Policy.class);\n        return policy;\n    }\n\n    @Override\n    public void directoryV3ServicePolicyDelete(ServicePolicyDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\", \"\/directory\/v3\/service\/policy\", subject, request, true, null);\n    }\n\n    @Override\n    public DirectoryV3TotpPostResponse directoryV3TotpPost(DirectoryV3TotpPostRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        HttpResponse response = getHttpResponse(\"POST\" , \"\/directory\/v3\/totp\", subject, request, true, null);\n        return decryptResponse(response, DirectoryV3TotpPostResponse.class);\n    }\n\n    @Override\n    public void directoryV3TotpDelete(DirectoryV3TotpDeleteRequest request, EntityIdentifier subject)\n            throws CryptographyError, InvalidResponseException, CommunicationErrorException, MarshallingError,\n            InvalidCredentialsException {\n        getHttpResponse(\"DELETE\" , \"\/directory\/v3\/totp\", subject, request, true, null);\n    }\n\n    protected HttpResponse getHttpResponse(\n            String method, String path, EntityIdentifier subjectEntity, Object transportObject, boolean signRequest,\n            List<Integer> httpStatusCodeWhiteList)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n\n        PublicKey publicKey;\n        String publicKeyFingerprint;\n        Date currentDate;\n        String subject;\n        if (signRequest) {\n            PublicKeyData publicKeyData = getCurrentPublicKeyData();\n            publicKey = publicKeyData.getKey();\n            publicKeyFingerprint = publicKeyData.getFingerprint();\n            currentDate = getCurrentDate();\n            subject = subjectEntity.toString();\n        } else {\n            publicKey = null;\n            publicKeyFingerprint = null;\n            currentDate = null;\n            subject = null;\n        }\n\n        String requestId = UUID.randomUUID().toString();\n        HttpUriRequest request = rbf.create(publicKey, publicKeyFingerprint, currentDate)\n                .setMethod(method)\n                .setPath(path)\n                .setSubject(subject)\n                .setTransportObject(transportObject)\n                .build(requestId);\n        try {\n            HttpResponse response = httpClient.execute(request);\n            if (response == null) {\n                throw new InvalidResponseException(\"No response returned from HTTP client\", null, null);\n            }\n            response = new ReplayHttpResponse(response);\n            if (signRequest) {\n                validateResponseJWT(response, requestId);\n            }\n            throwForStatus(response, httpStatusCodeWhiteList == null ? new ArrayList<Integer>() : httpStatusCodeWhiteList);\n            return response;\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"An I\/O Error Occurred\", e, null);\n        }\n    }\n\n    private void throwForStatus(HttpResponse response, List<Integer> httpStatusCodeWhiteList)\n            throws CommunicationErrorException, InvalidResponseException, CryptographyError {\n        final int statusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCodeWhiteList.contains(statusCode)) {\n            logger.debug(\"Did not throw for status as it was in white list\");\n        } else if (statusCode == 400 || statusCode == 409) {\n            final HttpEntity httpEntity = response.getEntity();\n            if (httpEntity == null || httpEntity.getContentLength() == 0) {\n                throw new InvalidRequestException(\n                        response.getStatusLine().getReasonPhrase(),\n                        null,\n                        \"HTTP-\" + statusCode\n                );\n            } else {\n                com.iovation.launchkey.sdk.transport.domain.Error error = decryptResponse(response, Error.class);\n                throw InvalidRequestException.fromError(error);\n            }\n        } else if (!(statusCode >= 200 && statusCode < 300)) {\n            String message = \"HTTP Error: [\" + String.valueOf(statusCode)\n                    + \"] \" + response.getStatusLine().getReasonPhrase();\n            throw CommunicationErrorException.fromStatusCode(statusCode, message);\n        }\n    }\n\n    protected <T> T decryptResponse(HttpResponse response, Class<T> type)\n            throws InvalidResponseException, CommunicationErrorException, CryptographyError {\n        ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n        try {\n            response.getEntity().writeTo(encrypted);\n            String json = jweService.decrypt(encrypted.toString());\n            return objectMapper.readValue(json, type);\n        } catch (JsonParseException | JsonMappingException e) {\n            throw new InvalidResponseException(\"Unable to parse response as JSON\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"AN IO Error Occurred\", e, null);\n        } catch (JWEFailure jweFailure) {\n            throw new CryptographyError(\"Unable to decrypt response!\", jweFailure);\n        }\n    }\n\n    private <T> T parseJsonResponse(HttpEntity entity, Class<T> valueType)\n            throws InvalidResponseException, CommunicationErrorException {\n        try {\n            return objectMapper.readValue(entity.getContent(), valueType);\n        } catch (JsonParseException | JsonMappingException e) {\n            throw new InvalidResponseException(\"Unable to parse response as JSON\", e, null);\n        } catch (IOException e) {\n            throw new CommunicationErrorException(\"AN IO Error Occurred\", e, null);\n        }\n    }\n\n    private void validateResponseJWT(HttpResponse response, String expectedTokenId)\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        try {\n\n            final String jwt = getJWT(response);\n\n            \/\/ TODO: Determine how we want to deal with non-public audience from API when 401 occurs\n            \/\/ String expectedAudience;\n            \/\/ if (response.getStatusLine().getStatusCode() == 401) {\n            \/\/     System.out.println(\"Made it where we expected\");\n            \/\/     expectedAudience = \"public\";\n            \/\/ } else {\n            \/\/     expectedAudience = issuer.toString();\n            \/\/ }\n            \/\/ final JWTClaims claims = validateJWT(expectedTokenId, jwt, expectedAudience);\n\n            final JWTClaims claims = validateJWT(expectedTokenId, jwt, issuer.toString());\n            HttpEntity entity = response.getEntity();\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            if (entity != null) entity.writeTo(stream);\n            if (claims.getStatusCode() != response.getStatusLine().getStatusCode())\n                throw new JWTError(\"Status code of response content does not match JWT response status code\", null);\n\n            verifyContentHash(claims, stream, \"response\");\n\n            if ((response.containsHeader(\"Location\") &&\n                            !response.getFirstHeader(\"Location\").getValue().equals(claims.getLocationHeader()))\n                    || (!response.containsHeader(\"Location\") && claims.getLocationHeader() != null)\n            ) throw new JWTError(\"Location header of response content does not match JWT response location\", null);\n\n            if ((response.containsHeader(\"Cache-Control\") &&\n                    !response.getFirstHeader(\"Cache-Control\").getValue().equals(claims.getCacheControlHeader()))\n                || (!response.containsHeader(\"Cache-Control\") && claims.getCacheControlHeader() != null)\n            ) throw new JWTError(\"Cache-Control header of response content does not match JWT response cache\", null);\n\n\n        } catch (JWTError jwtError) {\n            throw new InvalidResponseException(\"Invalid JWT in response!\", jwtError, null);\n        } catch (NoSuchAlgorithmException | IOException e ) {\n            throw new CryptographyError(\"An error occurred validating the body hash\", e);\n        }\n    }\n\n    private void verifyContentHash(JWTClaims claims, ByteArrayOutputStream stream, String type) throws NoSuchAlgorithmException, JWTError {\n        String contentHashAlgorithm = claims.getContentHashAlgorithm();\n        if (stream.size() > 0 && contentHashAlgorithm != null) {\n            String hash;\n            if (claims.getContentHashAlgorithm().equals(\"S256\")) {\n                hash = Hex.encodeHexString(crypto.sha256(stream.toByteArray()));\n            } else if (claims.getContentHashAlgorithm().equals(\"S384\")) {\n                hash = Hex.encodeHexString(crypto.sha384(stream.toByteArray()));\n            } else if (claims.getContentHashAlgorithm().equals(\"S512\")) {\n                hash = Hex.encodeHexString(crypto.sha512(stream.toByteArray()));\n            } else {\n                throw new JWTError(\"Hash of \" + type + \" content uses unsupported algorithm of \" +\n                        claims.getContentHashAlgorithm(), null);\n            }\n            if (claims.getContentHash() == null || !hash.equals(claims.getContentHash()))\n                throw new JWTError(\"Hash of \" + type + \" content does not match JWT \" + type + \" hash\", null);\n        } else if (stream.size() > 0 && claims.getContentHashAlgorithm() == null) {\n            throw new JWTError(\"No content hash algorithm found in JWT and there was content!\", null);\n        } else if (stream.size() == 0 && claims.getContentHashAlgorithm() != null) {\n            throw new JWTError(\"Content hash algorithm found in JWT and there was no content!\", null);\n        } else if (stream.size() == 0 && claims.getContentHash() != null) {\n            throw new JWTError(\"Content hash found in JWT and there was no content!\", null);\n        }\n    }\n\n    private JWTClaims validateJWT(String expectedTokenId, String jwt, String expected_audience)\n            throws JWTError, MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        String keyId = jwtService.getJWTData(jwt).getKeyId();\n        return jwtService.decode(\n                getPublicKeyData(keyId).getKey(), expected_audience, expectedTokenId, getCurrentDate(), jwt);\n    }\n\n    private String getJWT(HttpResponse response) {\n        return response.getFirstHeader(IOV_JWT_HEADER).getValue();\n    }\n\n\n    private PublicKeyData getCurrentPublicKeyData()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        if (currentPublicKeyDataExpires == null || currentPublicKeyDataExpires.before(new Date())) {\n            setCurrentPublicKeyData();\n        }\n        return currentPublicKeyData;\n\n    }\n\n    private synchronized void setCurrentPublicKeyData()\n            throws CommunicationErrorException, MarshallingError, InvalidResponseException, CryptographyError,\n            InvalidCredentialsException {\n        currentPublicKeyData = getPublicKeyData(null);\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date());\n        calendar.add(Calendar.SECOND, currentPublicKeyTTL);\n        currentPublicKeyDataExpires = calendar.getTime();\n    }\n\n    private PublicKeyData getPublicKeyData(String fingerprint)\n            throws MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        PublicKeyData publicKeyData = null;\n\n        if (fingerprint != null) {\n            String cacheKey = \"LaunchKeyPublicKey:\" + fingerprint;\n            String publicKey = null;\n            try {\n                publicKey = publicKeyCache.get(cacheKey);\n            } catch (CacheException e) {\n                logger.error(\"Unable to retrieve public key from cache. This will degrade performance.\", e);\n            }\n            if (publicKey != null) {\n                try {\n                    publicKeyData = new PublicKeyData(\n                            crypto.getRSAPublicKeyFromPEM(publicKey),\n                            fingerprint\n                    );\n                } catch (IllegalArgumentException e) {\n                    \/\/ The stored key cannot be parsed. Do nothing, the next step will get a new key.\n                    \/\/ If the exception was raised due to a missing algorithm, it will fail in that step as well.\n                }\n            }\n        }\n\n        \/\/ If the key was not in cache or the cached version was not valid,\n        \/\/ get it from the API and store it in the cache\n        if (publicKeyData == null) {\n            PublicV3PublicKeyGetResponse apiKey = publicV3PublicKeyGet(fingerprint);\n            publicKeyData = new PublicKeyData(\n                    crypto.getRSAPublicKeyFromPEM(apiKey.getPublicKey()), apiKey.getPublicKeyFingerprint());\n            try {\n                publicKeyCache.put(\"LaunchKeyPublicKey:\" + apiKey.getPublicKeyFingerprint(), apiKey.getPublicKey());\n            } catch (CacheException e) {\n                logger.error(\"Unable to cache public key. This will degrade performance.\", e);\n            }\n        }\n        return publicKeyData;\n    }\n\n    private Date getCurrentDate()\n            throws MarshallingError, InvalidResponseException, CommunicationErrorException, CryptographyError,\n            InvalidCredentialsException {\n        if (serverTimeOffsetExpires == null || serverTimeOffsetExpires.before(new Date())) {\n            setServerTimeOffset();\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date());\n        calendar.add(Calendar.MILLISECOND, serverTimeOffset);\n        return calendar.getTime();\n    }\n\n    private synchronized void setServerTimeOffset()\n            throws CommunicationErrorException, InvalidResponseException, MarshallingError, CryptographyError,\n            InvalidCredentialsException {\n        Date now = new Date();\n        PublicV3PingGetResponse response = publicV3PingGet();\n        serverTimeOffset = new Long(response.getApiTime().getTime() - now.getTime()).intValue();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(now);\n        calendar.add(Calendar.SECOND, offsetTTL);\n        serverTimeOffsetExpires = calendar.getTime();\n    }\n\n    private class PublicKeyData {\n        private final PublicKey key;\n        private final String fingerprint;\n\n        private PublicKeyData(PublicKey key, String fingerprint) {\n            this.key = key;\n            this.fingerprint = fingerprint;\n        }\n\n        public PublicKey getKey() {\n            return key;\n        }\n\n        public String getFingerprint() {\n            return fingerprint;\n        }\n    }\n}\n","subject":"","message":"Add single purpose key specific integration tests (#112)\n\n* Add single purpose key specific tests, update integration test suite to require a dual use, encryption, and signature key, ensure expected audience is not modified in JWT\r\n\r\n* Simplify single purpose key test when attempting to use encryption key to sign\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"launchkey-java","url":"https:\/\/github.com\/iovation\/launchkey-java","stars":9,"test_cases":{},"commit":"41217512630cebe38b0b4792afe602d3137a70fc","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"launchkey-java","url":"https:\/\/github.com\/iovation\/launchkey-java","stars":9,"test_cases":{},"commit":"63ef12877a1937043e06f72ef577496f0d6e4268","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
