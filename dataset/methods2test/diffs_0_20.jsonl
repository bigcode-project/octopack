{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"14167df6ccf4974d5b6c1d1d3860e5d104f0fd15","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"14167df6ccf4974d5b6c1d1d3860e5d104f0fd15","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"78d49a06d93dad641a810b5703f8ef024c60e24c","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"cf1902d1d8af1e1033ae8591c07239f0f223560e","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"4463e43a8ebc4f3f2cfd858fac840e87ef3a1a94","old_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/ErrorResponseBodyTest.java","new_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/ErrorResponseBodyTest.java","old_contents":"","new_contents":"package com.nike.riposte.server.error.handler;\n\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Tests the default methods of {@link ErrorResponseBody}.\n *\n * @author Nic Munroe\n *\/\npublic class ErrorResponseBodyTest {\n    @Test\n    public void bodyToSerialize_returns_same_instance_by_default() {\n        ErrorResponseBody instance = () -> \"someErrorId\";\n        assertThat(instance.bodyToSerialize()).isSameAs(instance);\n    }\n}","subject":"","message":"Clean up docs and tests for PR #99\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"53ce403c64a196fed429114ad8982a609dc223df","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"551ded88856e6dc6732c201716a5145238ce04d6","old_file":"riposte-core\/src\/test\/java\/com\/nike\/riposte\/server\/testutils\/ComponentTestUtils.java","new_file":"riposte-core\/src\/test\/java\/com\/nike\/riposte\/server\/testutils\/ComponentTestUtils.java","old_contents":"package com.nike.riposte.server.testutils;\n\nimport com.nike.backstopper.apierror.ApiError;\nimport com.nike.backstopper.model.DefaultErrorContractDTO;\nimport com.nike.internal.util.Pair;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport org.apache.commons.lang3.RandomUtils;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Deflater;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.Inflater;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.CharsetUtil;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static java.util.Arrays.stream;\nimport static org.apache.commons.lang3.StringUtils.containsOnly;\nimport static org.apache.commons.lang3.StringUtils.split;\nimport static org.apache.commons.lang3.StringUtils.substringAfter;\nimport static org.apache.commons.lang3.StringUtils.substringBefore;\nimport static org.apache.commons.lang3.StringUtils.substringBetween;\nimport static org.apache.commons.lang3.StringUtils.substringsBetween;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Helper methods for working with component tests.\n *\n * @author Nic Munroe\n *\/\npublic class ComponentTestUtils {\n\n    private static final String HEADER_SEPARATOR = \":\";\n    private static final String payloadDictionary = \"aBcDefGhiJkLmN@#$%\";\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static int findFreePort() throws IOException {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            return serverSocket.getLocalPort();\n        }\n    }\n\n    public static String generatePayload(int payloadSize) {\n        return generatePayload(payloadSize, payloadDictionary);\n    }\n\n    public static String generatePayload(int payloadSize, String dictionary) {\n        StringBuilder payload = new StringBuilder();\n\n        for(int i = 0; i < payloadSize; i++) {\n            int randomInt = RandomUtils.nextInt(0, dictionary.length() - 1);\n            payload.append(dictionary.charAt(randomInt));\n        }\n\n        return payload.toString();\n    }\n\n    public static ByteBuf createByteBufPayload(int payloadSize) {\n        return Unpooled.wrappedBuffer(generatePayload(payloadSize).getBytes(UTF_8));\n    }\n\n    public static byte[] gzipPayload(String payload) {\n        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bytesOut)) {\n            byte[] payloadBytes = payload.getBytes(UTF_8);\n            gzipOutputStream.write(payloadBytes);\n            gzipOutputStream.finish();\n            return bytesOut.toByteArray();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String ungzipPayload(byte[] compressed) {\n        try {\n            if ((compressed == null) || (compressed.length == 0)) {\n                throw new RuntimeException(\"Null\/empty compressed payload. is_null=\" + (compressed == null));\n            }\n\n            final StringBuilder outStr = new StringBuilder();\n            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(compressed));\n            final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(gis, \"UTF-8\"));\n\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                outStr.append(line);\n            }\n\n            return outStr.toString();\n        }\n        catch(IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static byte[] deflatePayload(String payload) {\n        Deflater deflater = new Deflater(6, false);\n        byte[] payloadBytes = payload.getBytes(UTF_8);\n        deflater.setInput(payloadBytes);\n        deflater.finish();\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!deflater.finished()) {\n            int count = deflater.deflate(buffer);\n            outputStream.write(buffer, 0, count);\n        }\n\n        return outputStream.toByteArray();\n    }\n\n    public static String inflatePayload(byte[] compressed) {\n        Inflater inflater = new Inflater();\n        inflater.setInput(compressed);\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!inflater.finished()) {\n            try {\n                int count = inflater.inflate(buffer);\n                outputStream.write(buffer, 0, count);\n            }\n            catch (DataFormatException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return new String(outputStream.toByteArray(), UTF_8);\n    }\n\n    public static String base64Encode(byte[] bytes) {\n        return Base64.getEncoder().encodeToString(bytes);\n    }\n\n    public static byte[] base64Decode(String encodedStr) {\n        return Base64.getDecoder().decode(encodedStr);\n    }\n\n    public enum CompressionType {\n        GZIP(ComponentTestUtils::gzipPayload,\n             ComponentTestUtils::ungzipPayload,\n             HttpHeaders.Values.GZIP),\n        DEFLATE(ComponentTestUtils::deflatePayload,\n                ComponentTestUtils::inflatePayload,\n                HttpHeaders.Values.DEFLATE),\n        IDENTITY(s -> s.getBytes(UTF_8),\n                 b -> new String(b, UTF_8),\n                 HttpHeaders.Values.IDENTITY);\n\n        private final Function<String, byte[]> compressionFunction;\n        private final Function<byte[], String> decompressionFunction;\n        public final String contentEncodingHeaderValue;\n\n        CompressionType(Function<String, byte[]> compressionFunction,\n                        Function<byte[], String> decompressionFunction,\n                        String contentEncodingHeaderValue) {\n            this.compressionFunction = compressionFunction;\n            this.decompressionFunction = decompressionFunction;\n            this.contentEncodingHeaderValue = contentEncodingHeaderValue;\n        }\n\n        public byte[] compress(String s) {\n            return compressionFunction.apply(s);\n        }\n\n        public String decompress(byte[] compressed) {\n            return decompressionFunction.apply(compressed);\n        }\n    }\n\n    public static Bootstrap createNettyHttpClientBootstrap() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup())\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ChannelPipeline p = ch.pipeline();\n                         p.addLast(new HttpClientCodec());\n                         p.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                         p.addLast(\"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                                 throw new RuntimeException(\"Client response handler was not setup before the call\");\n                             }\n                         });\n                     }\n                 });\n\n        return bootstrap;\n    }\n\n    public static Channel connectNettyHttpClientToLocalServer(Bootstrap bootstrap, int port) throws InterruptedException {\n        return bootstrap.connect(\"localhost\", port).sync().channel();\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(Channel ch) {\n        return setupNettyHttpClientResponseHandler(ch, null);\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(\n        Channel ch, Consumer<ChannelPipeline> pipelineAdjuster\n    ) {\n        CompletableFuture<NettyHttpClientResponse> responseFromServerFuture = new CompletableFuture<>();\n        ch.pipeline().replace(\"clientResponseHandler\", \"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)\n                throws Exception {\n                if (msg instanceof FullHttpResponse) {\n                    \/\/ Store the proxyServer response for asserting on later.\n                    responseFromServerFuture.complete(new NettyHttpClientResponse((FullHttpResponse) msg));\n                } else {\n                    \/\/ Should never happen.\n                    throw new RuntimeException(\"Received unexpected message type: \" + msg.getClass());\n                }\n            }\n        });\n\n        if (pipelineAdjuster != null)\n            pipelineAdjuster.accept(ch.pipeline());\n        \n        return responseFromServerFuture;\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n        return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n\n        CompletableFuture<NettyHttpClientResponse> responseFuture = setupNettyHttpClientResponseHandler(ch, pipelineAdjuster);\n\n        \/\/ Send the request.\n        ch.writeAndFlush(request);\n\n        \/\/ Wait for the response to be received\n        return responseFuture.get(incompleteCallTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    public static class NettyHttpClientResponse {\n        public final int statusCode;\n        public final HttpHeaders headers;\n        public final String payload;\n        public final byte[] payloadBytes;\n        public final FullHttpResponse fullHttpResponse;\n\n        public NettyHttpClientResponse(FullHttpResponse fullHttpResponse) {\n            this.statusCode = fullHttpResponse.getStatus().code();\n            this.headers = fullHttpResponse.headers();\n            ByteBuf content = fullHttpResponse.content();\n            this.payloadBytes = new byte[content.readableBytes()];\n            content.getBytes(content.readerIndex(), this.payloadBytes);\n            this.payload = new String(this.payloadBytes, UTF_8);\n            this.fullHttpResponse = fullHttpResponse;\n        }\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        return executeRequest(request, port, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        Bootstrap bootstrap = createNettyHttpClientBootstrap();\n        try {\n            \/\/ Connect to the proxyServer.\n            Channel ch = connectNettyHttpClientToLocalServer(bootstrap, port);\n\n            try {\n                return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, pipelineAdjuster);\n            }\n            finally {\n                ch.close();\n            }\n        } finally {\n            bootstrap.group().shutdownGracefully();\n        }\n    }\n\n    public static NettyHttpClientRequestBuilder request() {\n        return new NettyHttpClientRequestBuilder();\n    }\n\n    public static class NettyHttpClientRequestBuilder {\n        private HttpMethod method;\n        private String uri;\n        private String payload;\n        private HttpHeaders headers = new DefaultHttpHeaders();\n        private Consumer<ChannelPipeline> pipelineAdjuster;\n\n        public NettyHttpClientRequestBuilder withMethod(HttpMethod method) {\n            this.method = method;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withUri(String uri) {\n            this.uri = uri;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withPaylod(String payload) {\n            this.payload = payload;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withKeepAlive() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withConnectionClose() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeader(String key, Object value) {\n            this.headers.set(key, value);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeaders(Iterable<Pair<String, Object>> headers) {\n            for (Pair<String, Object> header : headers) {\n                withHeader(header.getKey(), header.getValue());\n            }\n            return this;\n        }\n\n        @SafeVarargs\n        public final NettyHttpClientRequestBuilder withHeaders(Pair<String, Object>... headers) {\n            return withHeaders(Arrays.asList(headers));\n        }\n\n        public NettyHttpClientRequestBuilder withPipelineAdjuster(Consumer<ChannelPipeline> pipelineAdjuster) {\n            this.pipelineAdjuster = pipelineAdjuster;\n            return this;\n        }\n\n        public FullHttpRequest build() {\n            ByteBuf content;\n            if (payload != null)\n                content = Unpooled.copiedBuffer(payload, CharsetUtil.UTF_8);\n            else\n                content = Unpooled.buffer(0);\n\n            DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, method, uri, content);\n\n            if (headers != null) \n                request.headers().set(headers);\n\n            return request;\n        }\n\n        public NettyHttpClientResponse execute(int port, long incompleteCallTimeoutMillis) throws Exception {\n            return executeRequest(build(), port, incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n\n        public NettyHttpClientResponse execute(Channel ch, long incompleteCallTimeoutMillis) throws InterruptedException, ExecutionException, TimeoutException {\n            return executeNettyHttpClientCall(ch, build(), incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n    }\n\n    public static void verifyErrorReceived(String response, int responseStatusCode, ApiError expectedApiError) throws IOException {\n        assertThat(responseStatusCode).isEqualTo(expectedApiError.getHttpStatusCode());\n        DefaultErrorContractDTO responseAsError = objectMapper.readValue(response, DefaultErrorContractDTO.class);\n        assertThat(responseAsError.errors).hasSize(1);\n        assertThat(responseAsError.errors.get(0).code).isEqualTo(expectedApiError.getErrorCode());\n        assertThat(responseAsError.errors.get(0).message).isEqualTo(expectedApiError.getMessage());\n        assertThat(responseAsError.errors.get(0).metadata).isEqualTo(expectedApiError.getMetadata());\n    }\n\n    public static String extractBodyFromRawRequest(String request) {\n        return substringAfter(request.toString(), \"\\r\\n\\r\\n\"); \/\/body start after \\r\\n\\r\\n combo\n    }\n\n    public static String extractFullBodyFromChunks(String downstreamBody) {\n        return stream(substringsBetween(downstreamBody, \"\\r\\n\", \"\\r\\n\")) \/\/get all chunks\n                .filter(chunk -> containsOnly(chunk, payloadDictionary)) \/\/filter out chunk sizes\n                .collect(Collectors.joining());\n    }\n\n    public static Map<String, Object> extractHeaders(String requestHeaderString) {\n        String concatHeaders = substringBetween(requestHeaderString, \"HTTP\/1.1\\r\\n\", \"\\r\\n\\r\\n\");\n\n        Map<String, Object> extractedHeaders = new HashMap<>();\n\n        for (String concatHeader : split(concatHeaders, \"\\r\\n\")) {\n            extractedHeaders.put(substringBefore(concatHeader, HEADER_SEPARATOR).trim(), substringAfter(concatHeader, HEADER_SEPARATOR).trim());\n        }\n\n        return extractedHeaders;\n    }\n}\n","new_contents":"package com.nike.riposte.server.testutils;\n\nimport com.nike.backstopper.apierror.ApiError;\nimport com.nike.backstopper.model.DefaultErrorContractDTO;\nimport com.nike.internal.util.Pair;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport org.apache.commons.lang3.RandomUtils;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Deflater;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.Inflater;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.CharsetUtil;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static org.apache.commons.lang3.StringUtils.split;\nimport static org.apache.commons.lang3.StringUtils.substringAfter;\nimport static org.apache.commons.lang3.StringUtils.substringBefore;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n\/**\n * Helper methods for working with component tests.\n *\n * @author Nic Munroe\n *\/\npublic class ComponentTestUtils {\n\n    private static final String HEADER_SEPARATOR = \":\";\n    private static final String payloadDictionary = \"aBcDefGhiJkLmN@#$%\";\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static int findFreePort() throws IOException {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            return serverSocket.getLocalPort();\n        }\n    }\n\n    public static String generatePayload(int payloadSize) {\n        return generatePayload(payloadSize, payloadDictionary);\n    }\n\n    public static String generatePayload(int payloadSize, String dictionary) {\n        StringBuilder payload = new StringBuilder();\n\n        for(int i = 0; i < payloadSize; i++) {\n            int randomInt = RandomUtils.nextInt(0, dictionary.length() - 1);\n            payload.append(dictionary.charAt(randomInt));\n        }\n\n        return payload.toString();\n    }\n\n    public static ByteBuf createByteBufPayload(int payloadSize) {\n        return Unpooled.wrappedBuffer(generatePayload(payloadSize).getBytes(UTF_8));\n    }\n\n    public static byte[] gzipPayload(String payload) {\n        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bytesOut)) {\n            byte[] payloadBytes = payload.getBytes(UTF_8);\n            gzipOutputStream.write(payloadBytes);\n            gzipOutputStream.finish();\n            return bytesOut.toByteArray();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String ungzipPayload(byte[] compressed) {\n        try {\n            if ((compressed == null) || (compressed.length == 0)) {\n                throw new RuntimeException(\"Null\/empty compressed payload. is_null=\" + (compressed == null));\n            }\n\n            final StringBuilder outStr = new StringBuilder();\n            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(compressed));\n            final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(gis, \"UTF-8\"));\n\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                outStr.append(line);\n            }\n\n            return outStr.toString();\n        }\n        catch(IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static byte[] deflatePayload(String payload) {\n        Deflater deflater = new Deflater(6, false);\n        byte[] payloadBytes = payload.getBytes(UTF_8);\n        deflater.setInput(payloadBytes);\n        deflater.finish();\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!deflater.finished()) {\n            int count = deflater.deflate(buffer);\n            outputStream.write(buffer, 0, count);\n        }\n\n        return outputStream.toByteArray();\n    }\n\n    public static String inflatePayload(byte[] compressed) {\n        Inflater inflater = new Inflater();\n        inflater.setInput(compressed);\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        while (!inflater.finished()) {\n            try {\n                int count = inflater.inflate(buffer);\n                outputStream.write(buffer, 0, count);\n            }\n            catch (DataFormatException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return new String(outputStream.toByteArray(), UTF_8);\n    }\n\n    public static String base64Encode(byte[] bytes) {\n        return Base64.getEncoder().encodeToString(bytes);\n    }\n\n    public static byte[] base64Decode(String encodedStr) {\n        return Base64.getDecoder().decode(encodedStr);\n    }\n\n    public enum CompressionType {\n        GZIP(ComponentTestUtils::gzipPayload,\n             ComponentTestUtils::ungzipPayload,\n             HttpHeaders.Values.GZIP),\n        DEFLATE(ComponentTestUtils::deflatePayload,\n                ComponentTestUtils::inflatePayload,\n                HttpHeaders.Values.DEFLATE),\n        IDENTITY(s -> s.getBytes(UTF_8),\n                 b -> new String(b, UTF_8),\n                 HttpHeaders.Values.IDENTITY);\n\n        private final Function<String, byte[]> compressionFunction;\n        private final Function<byte[], String> decompressionFunction;\n        public final String contentEncodingHeaderValue;\n\n        CompressionType(Function<String, byte[]> compressionFunction,\n                        Function<byte[], String> decompressionFunction,\n                        String contentEncodingHeaderValue) {\n            this.compressionFunction = compressionFunction;\n            this.decompressionFunction = decompressionFunction;\n            this.contentEncodingHeaderValue = contentEncodingHeaderValue;\n        }\n\n        public byte[] compress(String s) {\n            return compressionFunction.apply(s);\n        }\n\n        public String decompress(byte[] compressed) {\n            return decompressionFunction.apply(compressed);\n        }\n    }\n\n    public static Bootstrap createNettyHttpClientBootstrap() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup())\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ChannelPipeline p = ch.pipeline();\n                         p.addLast(new HttpClientCodec());\n                         p.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                         p.addLast(\"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                                 throw new RuntimeException(\"Client response handler was not setup before the call\");\n                             }\n                         });\n                     }\n                 });\n\n        return bootstrap;\n    }\n\n    public static Channel connectNettyHttpClientToLocalServer(Bootstrap bootstrap, int port) throws InterruptedException {\n        return bootstrap.connect(\"localhost\", port).sync().channel();\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(Channel ch) {\n        return setupNettyHttpClientResponseHandler(ch, null);\n    }\n\n    public static CompletableFuture<NettyHttpClientResponse> setupNettyHttpClientResponseHandler(\n        Channel ch, Consumer<ChannelPipeline> pipelineAdjuster\n    ) {\n        CompletableFuture<NettyHttpClientResponse> responseFromServerFuture = new CompletableFuture<>();\n        ch.pipeline().replace(\"clientResponseHandler\", \"clientResponseHandler\", new SimpleChannelInboundHandler<HttpObject>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)\n                throws Exception {\n                if (msg instanceof FullHttpResponse) {\n                    \/\/ Store the proxyServer response for asserting on later.\n                    responseFromServerFuture.complete(new NettyHttpClientResponse((FullHttpResponse) msg));\n                } else {\n                    \/\/ Should never happen.\n                    throw new RuntimeException(\"Received unexpected message type: \" + msg.getClass());\n                }\n            }\n        });\n\n        if (pipelineAdjuster != null)\n            pipelineAdjuster.accept(ch.pipeline());\n        \n        return responseFromServerFuture;\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n        return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeNettyHttpClientCall(\n        Channel ch, FullHttpRequest request, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws ExecutionException, InterruptedException, TimeoutException {\n\n        CompletableFuture<NettyHttpClientResponse> responseFuture = setupNettyHttpClientResponseHandler(ch, pipelineAdjuster);\n\n        \/\/ Send the request.\n        ch.writeAndFlush(request);\n\n        \/\/ Wait for the response to be received\n        return responseFuture.get(incompleteCallTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    public static class NettyHttpClientResponse {\n        public final int statusCode;\n        public final HttpHeaders headers;\n        public final String payload;\n        public final byte[] payloadBytes;\n        public final FullHttpResponse fullHttpResponse;\n\n        public NettyHttpClientResponse(FullHttpResponse fullHttpResponse) {\n            this.statusCode = fullHttpResponse.getStatus().code();\n            this.headers = fullHttpResponse.headers();\n            ByteBuf content = fullHttpResponse.content();\n            this.payloadBytes = new byte[content.readableBytes()];\n            content.getBytes(content.readerIndex(), this.payloadBytes);\n            this.payload = new String(this.payloadBytes, UTF_8);\n            this.fullHttpResponse = fullHttpResponse;\n        }\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        return executeRequest(request, port, incompleteCallTimeoutMillis, null);\n    }\n\n    public static NettyHttpClientResponse executeRequest(\n        FullHttpRequest request, int port, long incompleteCallTimeoutMillis, Consumer<ChannelPipeline> pipelineAdjuster\n    ) throws InterruptedException, TimeoutException, ExecutionException {\n        Bootstrap bootstrap = createNettyHttpClientBootstrap();\n        try {\n            \/\/ Connect to the proxyServer.\n            Channel ch = connectNettyHttpClientToLocalServer(bootstrap, port);\n\n            try {\n                return executeNettyHttpClientCall(ch, request, incompleteCallTimeoutMillis, pipelineAdjuster);\n            }\n            finally {\n                ch.close();\n            }\n        } finally {\n            bootstrap.group().shutdownGracefully();\n        }\n    }\n\n    public static NettyHttpClientRequestBuilder request() {\n        return new NettyHttpClientRequestBuilder();\n    }\n\n    public static class NettyHttpClientRequestBuilder {\n        private HttpMethod method;\n        private String uri;\n        private String payload;\n        private HttpHeaders headers = new DefaultHttpHeaders();\n        private Consumer<ChannelPipeline> pipelineAdjuster;\n\n        public NettyHttpClientRequestBuilder withMethod(HttpMethod method) {\n            this.method = method;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withUri(String uri) {\n            this.uri = uri;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withPaylod(String payload) {\n            this.payload = payload;\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withKeepAlive() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withConnectionClose() {\n            headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeader(String key, Object value) {\n            this.headers.set(key, value);\n            return this;\n        }\n\n        public NettyHttpClientRequestBuilder withHeaders(Iterable<Pair<String, Object>> headers) {\n            for (Pair<String, Object> header : headers) {\n                withHeader(header.getKey(), header.getValue());\n            }\n            return this;\n        }\n\n        @SafeVarargs\n        public final NettyHttpClientRequestBuilder withHeaders(Pair<String, Object>... headers) {\n            return withHeaders(Arrays.asList(headers));\n        }\n\n        public NettyHttpClientRequestBuilder withPipelineAdjuster(Consumer<ChannelPipeline> pipelineAdjuster) {\n            this.pipelineAdjuster = pipelineAdjuster;\n            return this;\n        }\n\n        public FullHttpRequest build() {\n            ByteBuf content;\n            if (payload != null)\n                content = Unpooled.copiedBuffer(payload, CharsetUtil.UTF_8);\n            else\n                content = Unpooled.buffer(0);\n\n            DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, method, uri, content);\n\n            if (headers != null) \n                request.headers().set(headers);\n\n            return request;\n        }\n\n        public NettyHttpClientResponse execute(int port, long incompleteCallTimeoutMillis) throws Exception {\n            return executeRequest(build(), port, incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n\n        public NettyHttpClientResponse execute(Channel ch, long incompleteCallTimeoutMillis) throws InterruptedException, ExecutionException, TimeoutException {\n            return executeNettyHttpClientCall(ch, build(), incompleteCallTimeoutMillis, pipelineAdjuster);\n        }\n    }\n\n    public static void verifyErrorReceived(String response, int responseStatusCode, ApiError expectedApiError) throws IOException {\n        assertThat(responseStatusCode).isEqualTo(expectedApiError.getHttpStatusCode());\n        DefaultErrorContractDTO responseAsError = objectMapper.readValue(response, DefaultErrorContractDTO.class);\n        assertThat(responseAsError.errors).hasSize(1);\n        assertThat(responseAsError.errors.get(0).code).isEqualTo(expectedApiError.getErrorCode());\n        assertThat(responseAsError.errors.get(0).message).isEqualTo(expectedApiError.getMessage());\n        assertThat(responseAsError.errors.get(0).metadata).isEqualTo(expectedApiError.getMetadata());\n    }\n\n    public static String extractBodyFromRawRequestOrResponse(String request) {\n        return substringAfter(request, \"\\r\\n\\r\\n\"); \/\/body start after \\r\\n\\r\\n combo\n    }\n\n    public static String extractFullBodyFromChunks(String chunkedBody) {\n        if (!chunkedBody.contains(\"\\r\\n\")) {\n            return chunkedBody;\n        }\n\n        \/\/ https:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec3.html#sec3.6.1\n        String[] chunksWithSizes = chunkedBody.split(\"\\r\\n\");\n        boolean nextChunkIsChunkSize = true;\n        StringBuilder finalResultMinusChunkMetadata = new StringBuilder();\n        for (String chunk : chunksWithSizes) {\n            if (!nextChunkIsChunkSize) {\n                \/\/ This is not metadata - it is actual body payload.\n                finalResultMinusChunkMetadata.append(chunk);\n            }\n\n            \/\/ Toggle our \"next is metadata\" flag, as according to the RFC it should alternate between\n            \/\/      chunk-size and chunk-data.\n            nextChunkIsChunkSize = !nextChunkIsChunkSize;\n        }\n\n        return finalResultMinusChunkMetadata.toString();\n    }\n\n    public static HttpHeaders extractHeaders(String rawRequestOrResponseString) {\n        int indexOfFirstCrlf = rawRequestOrResponseString.indexOf(\"\\r\\n\");\n        int indexOfBodySeparator = rawRequestOrResponseString.indexOf(\"\\r\\n\\r\\n\");\n\n        if (indexOfFirstCrlf == -1 || indexOfBodySeparator == -1) {\n            throw new IllegalArgumentException(\"The given rawRequestOrResponseString does not appear to be a valid HTTP message\");\n        }\n\n        String concatHeaders = rawRequestOrResponseString.substring(indexOfFirstCrlf + \"\\r\\n\".length(), indexOfBodySeparator);\n\n        HttpHeaders extractedHeaders = new DefaultHttpHeaders();\n\n        for (String concatHeader : split(concatHeaders, \"\\r\\n\")) {\n            extractedHeaders.add(substringBefore(concatHeader, HEADER_SEPARATOR).trim(), substringAfter(concatHeader, HEADER_SEPARATOR).trim());\n        }\n\n        return extractedHeaders;\n    }\n\n    public static Map<String, List<String>> headersToMap(HttpHeaders headers) {\n        Map<String, List<String>> result = new LinkedHashMap<>();\n        headers.names().forEach(headerKey -> result.put(headerKey, headers.getAll(headerKey)));\n        return result;\n    }\n}\n","subject":"","message":"Remove forced chunking on ProxyRouterEndpoint responses\n\nAlso fix bug of content-type being set on ProxyRouterEndpoint responses, and fix some RFC conformity issues for StandardEndpoints around always-empty-payload status codes and content-length header\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"b545aaadbbcee127af4d46b2a913a1d1b01f779b","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"2a5004d5256b878a63b4a47b28e44662ffa10e12","old_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/impl\/DelegatedErrorResponseBodyTest.java","new_file":"riposte-spi\/src\/test\/java\/com\/nike\/riposte\/server\/error\/handler\/impl\/DelegatedErrorResponseBodyTest.java","old_contents":"","new_contents":"package com.nike.riposte.server.error.handler.impl;\n\nimport org.junit.Test;\n\nimport java.util.UUID;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.catchThrowable;\n\n\/**\n * Tests the functionality of {@link DelegatedErrorResponseBody}.\n *\n * @author Nic Munroe\n *\/\npublic class DelegatedErrorResponseBodyTest {\n\n    @Test\n    public void constructor_sets_fields_as_expected() {\n        \/\/ given\n        String errorId = UUID.randomUUID().toString();\n        Object someObject = new Object();\n\n        \/\/ when\n        DelegatedErrorResponseBody impl = new DelegatedErrorResponseBody(errorId, someObject);\n\n        \/\/ then\n        assertThat(impl.errorId).isEqualTo(errorId);\n        assertThat(impl.errorId()).isEqualTo(errorId);\n        assertThat(impl.bodyToSerialize).isSameAs(someObject);\n        assertThat(impl.bodyToSerialize()).isSameAs(someObject);\n    }\n\n    @Test\n    public void constructor_throws_IllegalArgumentException_if_passed_null_errorId() {\n        \/\/ when\n        Throwable ex = catchThrowable(() -> new DelegatedErrorResponseBody(null, new Object()));\n\n        \/\/ then\n        assertThat(ex)\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"errorId cannot be null.\");\n    }\n\n}\n","subject":"","message":"Add DelegatedErrorResponseBody\n\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"riposte","url":"https:\/\/github.com\/Nike-Inc\/riposte","stars":115,"test_cases":{},"commit":"9e6ee00c5975ffe31cbae3d6bf49d550c0fa969d","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"9ce98981f705ea6274168e651b2faf95e2030baf","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"9ce98981f705ea6274168e651b2faf95e2030baf","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"394342a7f31538e5009c29c8b4f9ecd6b91403cb","old_file":"flowable\/src\/main\/java\/io\/reactivex\/flowable\/Flowable.java","new_file":"flowable\/src\/main\/java\/io\/reactivex\/flowable\/Flowable.java","old_contents":"\/**\n * Copyright (c) 2016-present, RxJava Contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n * the License for the specific language governing permissions and limitations under the License.\n *\/\npackage io.reactivex.flowable;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\nimport org.reactivestreams.*;\n\nimport hu.akarnokd.reactivestreams.extensions.*;\nimport io.reactivex.common.*;\nimport io.reactivex.common.annotations.*;\nimport io.reactivex.common.exceptions.Exceptions;\nimport io.reactivex.common.functions.*;\nimport io.reactivex.common.internal.functions.*;\nimport io.reactivex.common.internal.schedulers.ImmediateThinScheduler;\nimport io.reactivex.common.internal.utils.*;\nimport io.reactivex.flowable.internal.operators.*;\nimport io.reactivex.flowable.internal.subscribers.*;\nimport io.reactivex.flowable.subscribers.*;\n\n\/**\n * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,\n * intermediate operators and the ability to consume reactive dataflows.\n * <p>\n * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators\n * therefore accept general {@code Publisher}s directly and allow direct interoperation with other\n * Reactive-Streams implementations.\n * <p>\n * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},\n * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have\n * overloads that allow setting their internal buffer size explicitly.\n * <p>\n * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:\n * <p>\n * <img width=\"640\" height=\"317\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/legend.png\" alt=\"\">\n * <p>\n * For more information see the <a href=\"http:\/\/reactivex.io\/documentation\/Publisher.html\">ReactiveX\n * documentation<\/a>.\n *\n * @param <T>\n *            the type of the items emitted by the Flowable\n *\/\npublic abstract class Flowable<T> implements Publisher<T> {\n    \/** The default buffer size. *\/\n    static final int BUFFER_SIZE;\n    static {\n        BUFFER_SIZE = Math.max(16, Integer.getInteger(\"rx2.buffer-size\", 128));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an Iterable of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an Iterable of Publishers sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(null, sources));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an array of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an array of Publisher sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> ambArray(Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        int len = sources.length;\n        if (len == 0) {\n            return empty();\n        } else\n        if (len == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(sources, null));\n    }\n\n    \/**\n     * Returns the default internal buffer size used by most async operators.\n     * <p>The value can be overridden via system parameter {@code rx2.buffer-size}\n     * <em>before<\/em> the Flowable class is loaded.\n     * @return the default internal buffer size.\n     *\/\n    public static int bufferSize() {\n        return BUFFER_SIZE;\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Function<? super Object[], ? extends R> combiner, Publisher<? extends T>... sources) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publisher, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Publisher\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            int bufferSize, Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize);\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines two source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from either of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return combineLatest(f, source1, source2);\n    }\n\n    \/**\n     * Combines three source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);\n    }\n\n    \/**\n     * Combines four source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Combines five source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Combines six source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Combines seven source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Combines eight source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Combines nine source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <T9> the element type of the ninth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param source9\n     *            the ninth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Concatenates elements of each Publisher provided via an Iterable sequence into a single sequence\n     * of elements without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the common value type of the sources\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Flowable instance\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        \/\/ unlike general sources, fromIterable can only throw on a boundary because it is consumed only there\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), 2, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {\n        return concat(sources, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param prefetch\n     *            the number of Publishers to prefetch from the sources sequence.\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by two Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return concatArray(source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by three Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the three source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return concatArray(source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by four Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @param source4\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the four source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return concatArray(source1, source2, source3, source4);\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources.\n     * <p>\n     * Note: named this way because of overload conflict with concat(Publisher&lt;Publisher&gt).\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Publisher instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, false));\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources and delays errors from any of them\n     * till all terminate.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Flowable instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, true));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {\n        return concatArrayEager(bufferSize(), bufferSize(), sources);\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE\n     *                       is interpreted as indication to subscribe to all sources at once\n     * @param prefetch the number of elements to prefetch from each Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\n     * one after the other, one at a time and delays any errors till the all inner Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity());\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatDelayError(sources, bufferSize(), true);\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @param prefetch the number of elements to prefetch from the outer Publisher\n     * @param tillTheEnd if true exceptions from the outer and all inner Publishers are delayed to the end\n     *                   if false, exception from the outer Publisher is delayed till the current Publisher terminates\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {\n        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and the inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Provides an API (via a cold Flowable) that bridges the reactive world with the callback-style,\n     * generally non-backpressured world.\n     * <p>\n     * Example:\n     * <pre><code>\n     * Flowable.&lt;Event&gt;create(emitter -&gt; {\n     *     Callback listener = new Callback() {\n     *         &#64;Override\n     *         public void onEvent(Event e) {\n     *             emitter.onNext(e);\n     *             if (e.isLast()) {\n     *                 emitter.onComplete();\n     *             }\n     *         }\n     *\n     *         &#64;Override\n     *         public void onFailure(Exception e) {\n     *             emitter.onError(e);\n     *         }\n     *     };\n     *\n     *     AutoCloseable c = api.someMethod(listener);\n     *\n     *     emitter.setCancellable(c::close);\n     *\n     * }, BackpressureStrategy.BUFFER);\n     * <\/code><\/pre>\n     * <p>\n     * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The\n     * rest of its methods are thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior is determined by the {@code mode} parameter.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code create} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type\n     * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}\n     * @param mode the backpressure mode to apply if the downstream Subscriber doesn't request (fast) enough\n     * @return the new Flowable instance\n     * @see FlowableOnSubscribe\n     * @see BackpressureStrategy\n     * @see Cancellable\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        ObjectHelper.requireNonNull(mode, \"mode is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCreate<T>(source, mode));\n    }\n\n    \/**\n     * Returns a Flowable that calls a Publisher factory to create a Publisher for each new Subscriber\n     * that subscribes. That is, for each subscriber, the actual Publisher that subscriber observes is\n     * determined by the factory function.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defer.png\" alt=\"\">\n     * <p>\n     * The defer Subscriber allows you to defer or delay emitting items from a Publisher until such time as an\n     * Subscriber subscribes to the Publisher. This allows a {@link Subscriber} to easily obtain updates or a\n     * refreshed version of the sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}\n     *  returned by the {@code supplier}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            the Publisher factory function to invoke for each {@link Subscriber} that subscribes to the\n     *            resulting Publisher\n     * @param <T>\n     *            the type of the items emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given\n     *         Publisher factory function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defer.html\">ReactiveX operators documentation: Defer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> defer(Callable<? extends Publisher<? extends T>> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDefer<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits no items to the {@link Subscriber} and immediately invokes its\n     * {@link Subscriber#onComplete onComplete} method.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/empty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code empty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that emits no items to the {@link Subscriber} but immediately invokes the\n     *         {@link Subscriber}'s {@link Subscriber#onComplete() onComplete} method\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Empty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> empty() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            a Callable factory to return a Throwable for each individual Subscriber\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"errorSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableError<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param throwable\n     *            the particular Throwable to pass to {@link Subscriber#onError onError}\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(final Throwable throwable) {\n        ObjectHelper.requireNonNull(throwable, \"throwable is null\");\n        return error(Functions.justCallable(throwable));\n    }\n\n    \/**\n     * Converts an Array into a Publisher that emits the items in the Array.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code array}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of elements\n     * @param <T>\n     *            the type of items in the Array and the type of items to be emitted by the resulting Publisher\n     * @return a Flowable that emits each item in the source Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromArray(T... items) {\n        ObjectHelper.requireNonNull(items, \"items is null\");\n        if (items.length == 0) {\n            return empty();\n        }\n        if (items.length == 1) {\n            return just(items[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromArray<T>(items));\n    }\n\n    \/**\n     * Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then\n     * emits the value returned from that function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/fromCallable.png\" alt=\"\">\n     * <p>\n     * This allows you to defer the execution of the function you specify until a Subscriber subscribes to the\n     * Publisher. That is to say, it makes the function \"lazy.\"\n     * <dl>\n     *   <dt><b>Backpressure:<\/b><\/dt>\n     *   <dd>The operator honors backpressure from downstream.<\/dd>\n     *   <dt><b>Scheduler:<\/b><\/dt>\n     *   <dd>{@code fromCallable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this\n     *         function only when a Subscriber subscribes to the Publisher that {@code fromCallable} returns\n     * @param <T>\n     *         the type of the item emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given function\n     * @see #defer(Callable)\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromCallable(Callable<? extends T> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromCallable<T>(supplier));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, 0L, null));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, timeout, unit));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.s.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"cast\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts an {@link Iterable} sequence into a Publisher that emits the items in the sequence.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code iterable}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source\n     *            the source {@link Iterable} sequence\n     * @param <T>\n     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the\n     *            resulting Publisher\n     * @return a Flowable that emits each item in the source {@link Iterable} sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromIterable<T>(source));\n    }\n\n    \/**\n     * Converts an arbitrary Reactive-Streams Publisher into a Flowable if not already a\n     * Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and its behavior is determined by the\n     *  backpressure behavior of the wrapped publisher.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type of the flow\n     * @param source the Publisher to convert\n     * @return the new Flowable instance\n     * @throws NullPointerException if publisher is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> source) {\n        if (source instanceof Flowable) {\n            return RxJavaFlowablePlugins.onAssembly((Flowable<T>)source);\n        }\n        ObjectHelper.requireNonNull(source, \"publisher is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(source));\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateless and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the generated value type\n     * @param generator the Consumer called whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> generate(final Consumer<Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(Functions.nullSupplier(),\n                FlowableInternalHelper.<T, Object>simpleGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator,\n            Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), disposeState);\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {\n        return generate(initialState, generator, Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator, Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(initialState, \"initialState is null\");\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        ObjectHelper.requireNonNull(disposeState, \"disposeState is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGenerate<T, S>(initialState, generator, disposeState));\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.p.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) {\n        return interval(initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.ps.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @param scheduler\n     *            the Scheduler on which the waiting happens and items are emitted\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter, while running on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream\n     *  is not ready to receive the next value.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long period, TimeUnit unit) {\n        return interval(period, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time, on a\n     * specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @param scheduler\n     *            the Scheduler to use for scheduling the items\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {\n        return interval(period, period, unit, scheduler);\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {\n        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>you provide the {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @param scheduler the target scheduler where the values and terminal signals will be emitted\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0L) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0L) {\n            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a single item and then completes.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.png\" alt=\"\">\n     * <p>\n     * To convert any object into a Publisher that emits that object, pass that object into the {@code just}\n     * method.\n     * <p>\n     * This is similar to the {@link #fromArray(java.lang.Object[])} method, except that {@code from} will convert\n     * an {@link Iterable} object into a Publisher that emits each of the items in the Iterable, one at a\n     * time, while the {@code just} method converts an Iterable into a Publisher that emits the entire\n     * Iterable as a single item.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to emit\n     * @param <T>\n     *            the type of that item\n     * @return a Flowable that emits {@code value} as a single item and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJust<T>(item));\n    }\n\n    \/**\n     * Converts two items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n\n        return fromArray(item1, item2);\n    }\n\n    \/**\n     * Converts three items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n\n        return fromArray(item1, item2, item3);\n    }\n\n    \/**\n     * Converts four items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n\n        return fromArray(item1, item2, item3, item4);\n    }\n\n    \/**\n     * Converts five items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5);\n    }\n\n    \/**\n     * Converts six items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6);\n    }\n\n    \/**\n     * Converts seven items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7);\n    }\n\n    \/**\n     * Converts eight items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);\n    }\n\n    \/**\n     * Converts nine items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);\n    }\n\n    \/**\n     * Converts ten items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param item10\n     *            tenth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth item is null\");\n        ObjectHelper.requireNonNull(item10, \"The tenth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {\n        return merge(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 1.1.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens an Array of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.io.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers in the Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);\n    }\n\n    \/**\n     * Flattens four Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true);\n    }\n\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return mergeDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 2.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Flowable, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged Publishers\n     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from\n     * propagating that error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if both merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the two source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged\n     * Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain\n     * from propagating that error notification until all of the merged Publishers have finished emitting\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);\n    }\n\n\n    \/**\n     * Flattens four Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any of\n     * the merged Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}\n     * will refrain from propagating that error notification until all of the merged Publishers have finished\n     * emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);\n    }\n\n    \/**\n     * Returns a Flowable that never sends any items or notifications to a {@link Subscriber}.\n     * <p>\n     * <img width=\"640\" height=\"185\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/never.png\" alt=\"\">\n     * <p>\n     * This Publisher is useful primarily for testing purposes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code never} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of items (not) emitted by the Publisher\n     * @return a Flowable that never emits any items or sends any notifications to a {@link Subscriber}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Never<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> never() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Integers within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code range} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Integer in the sequence\n     * @param count\n     *            the number of sequential Integers to generate\n     * @return a Flowable that emits a range of sequential Integers\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Integer.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Integer> range(int start, int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return empty();\n        } else\n        if (count == 1) {\n            return just(start);\n        } else\n        if ((long)start + (count - 1) > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Integer overflow\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRange(start, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Longs within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Long in the sequence\n     * @param count\n     *            the number of sequential Longs to generate\n     * @return a Flowable that emits a range of sequential Longs\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Long.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Long> rangeLong(long start, long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0) {\n            return empty();\n        }\n\n        if (count == 1) {\n            return just(start);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRangeLong(start, count));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Flowable that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual) {\n        return sequenceEqual(source1, source2, isEqual, bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(isEqual, \"isEqual is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSequenceEqual<T>(source1, source2, isEqual, bufferSize));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param bufferSize\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return switchOnNextDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param prefetch\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single {@code 0L}\n     * @param unit\n     *            time units to use for {@code delay}\n     * @return a Flowable that emits {@code 0L} after a specified delay, and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> timer(long delay, TimeUnit unit) {\n        return timer(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     * completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single 0L\n     * @param unit\n     *            time units to use for {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for scheduling the item\n     * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     *         completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));\n    }\n\n    \/**\n     * Create a Flowable by wrapping a Publisher <em>which has to be implemented according\n     * to the Reactive-Streams specification by handling backpressure and\n     * cancellation correctly; no safeguards are provided by the Flowable itself<\/em>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure and the behavior is determined by the\n     *  provided Publisher implementation.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type emitted\n     * @param onSubscribe the Publisher instance to wrap\n     * @return the new Flowable instance\n     * @throws IllegalArgumentException if {@code onSubscribe} is a subclass of {@code Flowable}; such\n     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}\n     * instead.\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        if (onSubscribe instanceof Flowable) {\n            throw new IllegalArgumentException(\"unsafeCreate(Flowable) should be upgraded\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of on cancellation.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {\n        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of just before\n     * termination if you have set {@code disposeEagerly} to {@code true} and cancellation does not occur\n     * before termination. Otherwise resource disposal will occur on cancellation.  Eager disposal is\n     * particularly appropriate for a synchronous Publisher that reuses resources. {@code disposeAction} will\n     * only be called once per subscription.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @param eager\n     *            if {@code true} then disposal will happen either on cancellation or just before emission of\n     *            a terminal event ({@code onComplete} or {@code onError}).\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier,\n                    Consumer<? super D> resourceDisposer, boolean eager) {\n        ObjectHelper.requireNonNull(resourceSupplier, \"resourceSupplier is null\");\n        ObjectHelper.requireNonNull(sourceSupplier, \"sourceSupplier is null\");\n        ObjectHelper.requireNonNull(resourceDisposer, \"disposer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common value type\n     * @param <R> the zipped result type\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * <i>n<\/i> items emitted, in sequence, by the <i>n<\/i> Publishers emitted by a specified Publisher.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the Publishers emitted\n     * by the source Publisher; the second item emitted by the new Publisher will be the result of the\n     * function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancel the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(just(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the value type of the inner Publishers\n     * @param <R> the zipped result type\n     * @param sources\n     *            a Publisher of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the Publishers emitted by\n     *            {@code ws}, results in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,\n            final Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return fromPublisher(sources).toList().flatMap((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);\n    }\n\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @param bufferSize the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * three items emitted, in sequence, by three other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new\n     * Publisher will be the result of the function applied to the second item emitted by {@code o1}, the\n     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * four items emitted, in sequence, by four other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * five items emitted, in sequence, by five other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and\n     * the first item emitted by {@code o5}; the second item emitted by the new Publisher will be the result of\n     * the function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * six items emitted, in sequence, by six other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * seven items emitted, in sequence, by seven other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * eight items emitted, in sequence, by eight other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * nine items emitted, in sequence, by nine other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <T9> the value type of the ninth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param source9\n     *            a ninth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {\n\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an array of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;\n     * a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param <R> the result type\n     * @param sources\n     *            an array of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper,\n            boolean delayError, int bufferSize, Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     *\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @param <T> the common source value type\n     * @param <R> the zipped result type\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipIterable(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> zipper, boolean delayError,\n            int bufferSize) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError));\n    }\n\n    \/\/ ***************************************************************************************************\n    \/\/ Instance operators\n    \/\/ ***************************************************************************************************\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source\n     * Publisher satisfy a condition.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/all.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code all} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item and returns a Boolean\n     * @return a Single that emits {@code true} if all items emitted by the source Publisher satisfy the\n     *         predicate; otherwise, {@code false}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/all.html\">ReactiveX operators documentation: All<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> all(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAll<T>(this, predicate));\n    }\n\n    \/**\n     * Mirrors the Publisher (current or provided) that first either emits an item or sends a termination\n     * notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher competing to react first. A subscription to this provided Publisher will occur after subscribing\n     *            to the current Publisher.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ambWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return ambArray(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a\n     * specified condition, otherwise {@code false}. <em>Note:<\/em> this always emits {@code false} if the\n     * source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/exists.png\" alt=\"\">\n     * <p>\n     * In Rx.Net this is the {@code any} Subscriber but we renamed it in RxJava to better match Java naming\n     * idioms.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code any} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the condition to test items emitted by the source Publisher\n     * @return a Single that emits a Boolean that indicates whether any item emitted by the source\n     *         Publisher satisfies the {@code predicate}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> any(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAny<T>(this, predicate));\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if it emits no items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the first item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst() {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the first item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst(T defaultItem) {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Invokes a method on each item emitted by this {@code Flowable} and blocks until the Flowable\n     * completes.\n     * <p>\n     * <em>Note:<\/em> This will block even if the underlying Flowable is asynchronous.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.forEach.png\" alt=\"\">\n     * <p>\n     * This is similar to {@link Flowable#subscribe(Subscriber)}, but it blocks. Because it blocks it does not\n     * need the {@link Subscriber#onComplete()} or {@link Subscriber#onError(Throwable)} methods. If the\n     * underlying Flowable terminates with an error, rather than calling {@code onError}, this method will\n     * throw an exception.\n     *\n     * <p>The difference between this method and {@link #subscribe(Consumer)} is that the {@code onNext} action\n     * is executed on the emission thread instead of the current thread.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the {@link Consumer} to invoke for each item emitted by the {@code Flowable}\n     * @throws RuntimeException\n     *             if an error occurs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX documentation: Subscribe<\/a>\n     * @see #subscribe(Consumer)\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingForEach(Consumer<? super T> onNext) {\n        Iterator<T> it = blockingIterable().iterator();\n        while (it.hasNext()) {\n            try {\n                onNext.accept(it.next());\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                ((Disposable)it).dispose();\n                throw ExceptionHelper.wrapOrThrow(e);\n            }\n        }\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable() {\n        return blockingIterable(bufferSize());\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize the number of items to prefetch from the current Flowable\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return new BlockingFlowableIterable<T>(this, bufferSize);\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if this {@code Flowable} emits no items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the last item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast() {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the last item emitted by the {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast(T defaultItem) {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},\n     * waiting if necessary for one to become available.\n     * <p>\n     * If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,\n     * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.\n     * <p>\n     * Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}\n     * event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an Iterable that always returns the latest item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingLatest() {\n        return new BlockingFlowableLatest<T>(this);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that always returns the item most recently emitted by this\n     * {@code Flowable}.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.mostRecent.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialItem\n     *            the initial item that the {@link Iterable} sequence will yield if this\n     *            {@code Flowable} has not yet emitted an item\n     * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}\n     *         has most recently emitted\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingMostRecent(T initialItem) {\n        return new BlockingFlowableMostRecent<T>(this, initialItem);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, then\n     * returns that item.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.next.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} that blocks upon each iteration until this {@code Flowable} emits\n     *         a new item, whereupon the Iterable returns that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingNext() {\n        return new BlockingFlowableNext<T>(this);\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item, otherwise\n     * throw a {@code NoSuchElementException}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the single item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle() {\n        return singleOrError().blockingLast();\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item; if it emits\n     * more than one item, throw an {@code IllegalArgumentException}; if it emits no items, return a default\n     * value.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the single item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle(T defaultItem) {\n        return single(defaultItem).blockingLast();\n    }\n\n    \/**\n     * Returns a {@link Future} representing the single value emitted by this {@code Flowable}.\n     * <p>\n     * If the {@link Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an\n     * {@link java.lang.IllegalArgumentException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}\n     * will receive an {@link java.util.NoSuchElementException}.\n     * <p>\n     * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toBlocking().toFuture()}.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toFuture.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Future} that expects a single item to be emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Future<T> toFuture() {\n        return subscribeWith(new FutureSubscriber<T>());\n    }\n\n    \/**\n     * Runs the source observable to a terminal event, ignoring any values and rethrowing any exception.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe() {\n        FlowableBlockingSubscribe.subscribe(this);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @param onComplete the callback action for the completion event.\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);\n    }\n\n    \/**\n     * Subscribes to the source and calls the Subscriber methods <strong>on the current thread<\/strong>.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The supplied {@code Subscriber} determines how backpressure is applied.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * The cancellation and backpressure is composed through.\n     * @param subscriber the subscriber to forward events and calls to in the current thread\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Subscriber<? super T> subscriber) {\n        FlowableBlockingSubscribe.subscribe(this, subscriber);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count) {\n        return buffer(count, count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count, int skip) {\n        return buffer(count, skip, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {\n        return buffer(count, count, bufferSupplier);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits\n     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {\n        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,\n            Scheduler scheduler, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {\n        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) {\n        return buffer(timespan, unit, Schedulers.computation(), count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {\n        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @param restartTimerOnMaxSize if true the time window is restarted when the max capacity of the current buffer\n     *            is reached\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(\n            long timespan, TimeUnit unit,\n            Scheduler scheduler, int count,\n            Callable<U> bufferSupplier,\n            boolean restartTimerOnMaxSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument and on the specified {@code scheduler}. When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing> Flowable<List<T>> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {\n        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {\n        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param initialCapacity\n     *            the initial capacity of each buffer chunk\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     * @see #buffer(Publisher)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.<T>asCallable());\n\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundaryIndicatorSupplier, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cache() {\n        return cacheWithInitialCapacity(16);\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * <p>\n     * <em>Note:<\/em> The capacity hint is not an upper bound on cache size. For that, consider\n     * {@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.\n     *\n     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher, converted to the specified\n     * type.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output value type cast to\n     * @param clazz\n     *            the target class type that {@code cast} will cast the items emitted by the source Publisher\n     *            into before emitting them from the resulting Publisher\n     * @return a Flowable that emits each item from the source Publisher after converting it to the\n     *         specified type\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> cast(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return map(Functions.castFunction(clazz));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collect} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItemSupplier\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItemSupplier, \"initialItemSupplier is null\");\n        ObjectHelper.requireNonNull(collector, \"collector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCollect<T, U>(this, initialItemSupplier, collector));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collectInto} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItem\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collectInto(final U initialItem, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItem, \"initialItem is null\");\n        return collect(Functions.justCallable(initialItem), collector);\n    }\n\n    \/**\n     * Transform a Publisher by applying a particular Transformer function to it.\n     * <p>\n     * This method operates on the Publisher itself whereas {@link #lift} operates on the Publisher's\n     * Subscribers or Subscribers.\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@link #lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with the backpressure behavior which only depends\n     *  on what kind of {@code Publisher} the transformer returns.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code compose} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the output Publisher\n     * @param composer implements the function that transforms the source Publisher\n     * @return the source Publisher, transformed by the transformer function\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {\n        return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, \"composer is null\")).apply(this));\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMap(mapper, 2);\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapEager(mapper, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean tillTheEnd) {\n        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch\n     *               the number of elements to prefetch from each source Publisher\n     * @param tillTheEnd\n     *               if true, exceptions from the current Flowable and all the inner Publishers are delayed until\n     *               all of them terminate, if false, exception from the current Flowable is delayed until the\n     *               currently running Publisher terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, prefetch));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted from the current Publisher, then the next, one after\n     * the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be concatenated after the current\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> concatWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concat(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether the source Publisher emitted a\n     * specified item.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/contains.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code contains} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to search for in the emissions from the source Publisher\n     * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,\n     *         or {@code false} if the source Publisher completes without emitting that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> contains(final Object item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return any(Functions.equalsWith(item));\n    }\n\n    \/**\n     * Returns a Single that counts the total number of items emitted by the source Publisher and emits\n     * this count as a 64-bit Long.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/longCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code count} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a\n     *         64-bit Long item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/count.html\">ReactiveX operators documentation: Count<\/a>\n     * @see #count()\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Long> count() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCount<T>(this));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by another item within a computed debounce duration.\n     * <p>\n     * <img width=\"640\" height=\"425\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the {@code debounceSelector} to mark\n     *      boundaries.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the debounce value type (ignored)\n     * @param debounceIndicator\n     *            function to retrieve a sequence that indicates the throttle duration for each item\n     * @return a Flowable that omits items emitted by the source Publisher that are followed by another item\n     *         within a computed debounce duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {\n        ObjectHelper.requireNonNull(debounceIndicator, \"debounceIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on\n     * each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the {@link TimeUnit} for the timeout\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires on a specified\n     * Scheduler. The timer resets on each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the unit of time for the specified timeout\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or a specified default item\n     * if the source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defaultIfEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, this operator is guaranteed to honor backpressure from downstream.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as well; if the rule is violated,\n     *  a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the item to emit if the source Publisher emits no items\n     * @return a Flowable that emits either the specified default item if the source Publisher emits no\n     *         items, or the items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defaultifempty.html\">ReactiveX operators documentation: DefaultIfEmpty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> defaultIfEmpty(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"item is null\");\n        return switchIfEmpty(just(defaultItem));\n    }\n\n    \/**\n     * Returns a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     * per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.o.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the function are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the item delay value type (ignored)\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     *         per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelayIndicator) {\n        ObjectHelper.requireNonNull(itemDelayIndicator, \"itemDelayIndicator is null\");\n        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit) {\n        return delay(delay, unit, Schedulers.computation(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {\n        return delay(delay, unit, Schedulers.computation(), delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delay(delay, unit, scheduler, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelay<T>(this, Math.max(0L, delay), unit, scheduler, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to and emissions from the source Publisher via another\n     * Publisher on a per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.oo.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the functions are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the subscription delay value type (ignored)\n     * @param <V>\n     *            the item delay value type (ignored)\n     * @param subscriptionIndicator\n     *            a function that returns a Publisher that triggers the subscription to the source Publisher\n     *            once it emits any item\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the subscription and emissions of the source Publisher via another\n     *         Publisher on a per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,\n            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {\n        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to this Publisher\n     * until the other Publisher emits an element or completes normally.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator forwards the backpressure requests to this Publisher once\n     *  the subscription happens and requests Long.MAX_VALUE from the other Publisher<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the value type of the other Publisher, irrelevant\n     * @param subscriptionIndicator the other Publisher that should trigger the subscription\n     *        to this Publisher.\n     * @return a Flowable that delays the subscription to this Publisher\n     *         until the other Publisher emits an element or completes normally.\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delaySubscription(Publisher<U> subscriptionIndicator) {\n        ObjectHelper.requireNonNull(subscriptionIndicator, \"subscriptionIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, subscriptionIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @return a Flowable that delays the subscription to the source Publisher by the given amount\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit) {\n        return delaySubscription(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time,\n     * both waiting and subscribing on a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the Scheduler on which the waiting and subscription will happen\n     * @return a Flowable that delays the subscription to the source Publisher by a given\n     *         amount, waiting and subscribing on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delaySubscription(timer(delay, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the\n     * {@link Notification} objects emitted by the source Publisher into the items or notifications they\n     * represent.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/dematerialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code dematerialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T2> the output value type\n     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Dematerialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T2> Flowable<T2> dematerialize() {\n        @SuppressWarnings(\"unchecked\")\n        Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDematerialize<T2>(m));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits only those items emitted by the source Publisher that are distinct from\n     *         each other\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinct() {\n        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {\n        return distinct(keySelector, Functions.<K>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @param collectionSupplier\n     *            function called for each individual Subscriber to return a Collection subtype for holding the extracted\n     *            keys and whose add() method's return indicates uniqueness.\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,\n            Callable<? extends Collection<? super K>> collectionSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged() {\n        return distinctUntilChanged(Functions.identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors, according to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items from the source Publisher whose keys are distinct from\n     *         those of their immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors when compared with each other via the provided comparator function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparer the function that receives the previous item and the current item and is\n     *                   expected to return true if the two are equal, thus skipping the current value.\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {\n        ObjectHelper.requireNonNull(comparer, \"comparer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));\n    }\n\n    \/**\n     * Calls the specified action after this Flowable signals onError or onCompleted or gets cancelled by\n     * the downstream.\n     * <p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action\n     * is executed once per subscription.\n     * <p>Note that the {@code onFinally} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onFinally the action called when this Flowable terminates or gets cancelled\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doFinally(Action onFinally) {\n        ObjectHelper.requireNonNull(onFinally, \"onFinally is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));\n    }\n\n    \/**\n     * Calls the specified consumer with the current item after this item has been emitted to the downstream.\n     * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onAfterNext the Consumer that will be called after emitting an item from upstream to the downstream\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {\n        ObjectHelper.requireNonNull(onAfterNext, \"onAfterNext is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));\n    }\n\n    \/**\n     * Registers an {@link Action} to be called when this Publisher invokes either\n     * {@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/finallyDo.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onAfterTerminate\n     *            an {@link Action} to be invoked when the source Publisher finishes\n     * @return a Flowable that emits the same items as the source Publisher, then invokes the\n     *         {@link Action}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doOnTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, onAfterTerminate);\n    }\n\n    \/**\n     * Calls the cancel {@code Action} if the downstream cancels the sequence.\n     * <p>\n     * The action is shared between subscriptions and thus may be called concurrently from multiple\n     * threads; the action must be thread safe.\n     * <p>\n     * If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,\n     * sometimes as a {@code CompositeException} if there were multiple exceptions along the way.\n     * <p>\n     * Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnUnsubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure\n     *  behavior is preserved between its upstream and its downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onCancel\n     *            the action that gets called when the source {@code Publisher}'s Subscription is cancelled\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnCancel(Action onCancel) {\n        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnComplete.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onComplete\n     *            the action to invoke when the source Publisher calls {@code onComplete}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnComplete(Action onComplete) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                onComplete, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same type\n     * passes through, before forwarding them to downstream.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Action onAfterTerminate) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action for each item it emits.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNotification\n     *            the action to invoke for each item emitted by the source Publisher\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {\n        ObjectHelper.requireNonNull(onNotification, \"consumer is null\");\n        return doOnEach(\n                Functions.notificationOnNext(onNotification),\n                Functions.notificationOnError(onNotification),\n                Functions.notificationOnComplete(onNotification),\n                Functions.EMPTY_ACTION\n            );\n    }\n\n    \/**\n     * Modifies the source Publisher so that it notifies a Subscriber for each item and terminal event it emits.\n     * <p>\n     * In case the {@code onError} of the supplied Subscriber throws, the downstream will receive a composite\n     * exception containing the original exception and the exception thrown by {@code onError}. If either the\n     * {@code onNext} or the {@code onComplete} method of the supplied Subscriber throws, the downstream will be\n     * terminated and will receive this thrown exception.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param subscriber\n     *            the Subscriber to be notified about onNext, onError and onComplete events on its\n     *            respective methods before the actual downstream Subscriber gets notified.\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {\n        ObjectHelper.requireNonNull(subscriber, \"subscriber is null\");\n        return doOnEach(\n                FlowableInternalHelper.subscriberOnNext(subscriber),\n                FlowableInternalHelper.subscriberOnError(subscriber),\n                FlowableInternalHelper.subscriberOnComplete(subscriber),\n                Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action if it calls {@code onError}.\n     * <p>\n     * In case the {@code onError} action throws, the downstream will receive a composite exception containing\n     * the original exception and the exception thrown by {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onError\n     *            the action to invoke if the source Publisher calls {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {\n        return doOnEach(Functions.emptyConsumer(), onError,\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of\n     * the sequence (subscription, cancellation, requesting).\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *              a Consumer called with the Subscription sent via Subscriber.onSubscribe()\n     * @param onRequest\n     *              a LongConsumer called with the request amount sent via Subscription.request()\n     * @param onCancel\n     *              called when the downstream cancels the Subscription via cancel()\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,\n            final LongConsumer onRequest, final Action onCancel) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");\n        ObjectHelper.requireNonNull(onCancel, \"onCancel is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onNext}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the action to invoke when the source Publisher calls {@code onNext}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {\n        return doOnEach(onNext, Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it receives a\n     * request for more items.\n     * <p>\n     * <b>Note:<\/b> This operator is for tracing the internal behavior of back-pressure request\n     * patterns and generally intended for debugging use.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     * <dt><b>Scheduler:<\/b><\/dt>\n     * <dd>{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onRequest\n     *            the action that gets called when a Subscriber requests items from this\n     *            {@code Publisher}\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators\n     *      documentation: Do<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnRequest(LongConsumer onRequest) {\n        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from\n     * its subscribers. Each subscription will result in an invocation of the given action except when the\n     * source {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke\n     * the given action for the first subscription.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnSubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *            the Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}\n     * @return the source {@code Publisher} modified so as to call this Consumer when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {\n        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete} or\n     * {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnTerminate.png\" alt=\"\">\n     * <p>\n     * This differs from {@code doAfterTerminate} in that this happens <em>before<\/em> the {@code onComplete} or\n     * {@code onError} notification.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onTerminate\n     *            the action to invoke when the source Publisher calls {@code onComplete} or {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doAfterTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnTerminate(final Action onTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),\n                onTerminate, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from\n     * this Flowable or completes if this Flowable sequence has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Maybe that emits a single item: the item at the specified position in the sequence of\n     *         those emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable, or a default item if that index is out of range.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @param defaultItem\n     *            the default item\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index, T defaultItem) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable or signals a {@link NoSuchElementException} if this Flowable has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAtOrError(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, true));\n    }\n\n    \/**\n     * Filters items emitted by a Publisher by only emitting those that satisfy a specified predicate.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/filter.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code filter} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates each item emitted by the source Publisher, returning {@code true}\n     *            if it passes the filter\n     * @return a Flowable that emits only those items emitted by the source Publisher that the filter\n     *         evaluates as {@code true}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFilter<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Maybe that emits only the very first item emitted by this Flowable or\n     * completes if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstElement.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstElement() {\n        return elementAt(0);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable, or a default\n     * item if this Flowable completes without emitting anything.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/first.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code first} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher doesn't emit anything\n     * @return a Single that emits only the very first item from the source, or a default item if the\n     *         source Publisher completes without emitting any items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> first(T defaultItem) {\n        return elementAt(0, defaultItem);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable or\n     * signals a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstOrError() {\n        return elementAtOrError(0);\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return flatMap(mapper, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {\n        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {\n        return flatMap(mapper, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from each inner Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items,\n     * while limiting the maximum number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier,\n            int maxConcurrency) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(\n                this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        return flatMap(mapper, combiner, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     * <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner functions\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors) {\n        return flatMap(mapper, combiner, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, combiner, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from the inner Publishers.\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {\n        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return flatMapIterable(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of applying a function to the pair of values from the source\n     * Publisher and an Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and the source {@code Publisher}s is\n     *  consumed in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the collection element type\n     * @param <V>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for each item emitted by the source\n     *            Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @return a Flowable that emits the items returned by {@code resultSelector} for each item in the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the element type of the inner Iterable sequences\n     * @param <V>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element.\n     * <p>\n     * Alias to {@link #subscribe(Consumer)}\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Consumer} to execute for each item.\n     * @return\n     *            a Disposable that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEach(Consumer<? super T> onNext) {\n        return subscribe(onNext);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element until the\n     * onNext Predicate returns false.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext) {\n        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and error events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {\n        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and the terminal events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @param onComplete\n     *            {@link Action} to execute when completion is signalled.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,\n            final Action onComplete) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n\n        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);\n        subscribe(s);\n        return s;\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {\n        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {\n        return groupBy(keySelector, Functions.<T>identity(), delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector) {\n        return groupBy(keySelector, valueSelector, false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector, boolean delayError) {\n        return groupBy(keySelector, valueSelector, delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @param bufferSize\n     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that correlates two Publishers when they overlap in time and groups the results.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupJoin.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupJoin} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the other Publisher to correlate items from the source Publisher with\n     * @param leftEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the source Publisher\n     * @param rightEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the {@code right} Publisher\n     * @param resultSelector\n     *            a function that takes an item emitted by each Publisher and returns the value to be emitted\n     *            by the resulting Publisher\n     * @return a Flowable that emits items based on combining those items emitted by the source Publishers\n     *         whose durations overlap\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n    \/**\n     * Hides the identity of this Flowable and its Subscription.\n     * <p>Allows hiding extra features such as {@link Processor}'s\n     * {@link Subscriber} methods or preventing certain identity-based\n     * optimizations (fusion).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure, the behavior is determined by the upstream's\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     *\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> hide() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableHide<T>(this));\n    }\n\n    \/**\n     * Ignores all items emitted by the source Publisher and only calls {@code onComplete} or {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ignoreElements.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator ignores backpressure as it doesn't emit any elements and consumes the source {@code Publisher}\n     *  in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is\n     *         called by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/ignoreelements.html\">ReactiveX operators documentation: IgnoreElements<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ignoreElements() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if the source Publisher is empty, otherwise {@code false}.\n     * <p>\n     * In Rx.Net this is negated as the {@code any} Subscriber but we renamed this in RxJava to better match Java\n     * naming idioms.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/isEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code isEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits a Boolean\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> isEmpty() {\n        return all(Functions.alwaysFalse());\n    }\n\n    \/**\n     * Correlates the items emitted by two Publishers based on overlapping durations.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/join_.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code join} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the second Publisher to join items from\n     * @param leftEnd\n     *            a function to select a duration for each item emitted by the source Publisher, used to\n     *            determine overlap\n     * @param rightEnd\n     *            a function to select a duration for each item emitted by the {@code right} Publisher, used to\n     *            determine overlap\n     * @param resultSelector\n     *            a function that computes an item to be emitted by the resulting Publisher for any two\n     *            overlapping items emitted by the two Publishers\n     * @return a Flowable that emits items correlating to items emitted by the source Publishers that have\n     *         overlapping durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n\n    \/**\n     * Returns a Maybe that emits the last item emitted by this Flowable or completes if\n     * this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable, or a default item\n     * if this Flowable completes without emitting any items.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code last} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher is empty\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> last(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable or signals\n     * a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"236\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, true));\n    }\n\n    \/**\n     * <strong>This method requires advanced knowledge about building operators; please consider\n     * other standard composition methods first;<\/strong>\n     * Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass\n     * the values of the current Publisher through the Operator function.\n     * <p>\n     * In other words, this allows chaining Subscribers together on a Publisher for acting on the values within\n     * the Publisher.\n     * <p> {@code\n     * Publisher.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()\n     * }\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@code lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The {@code Operator} instance provided is responsible to be backpressure-aware or\n     *  document the fact that the consumer of the returned {@code Publisher} has to apply one of\n     *  the {@code onBackpressureXXX} operators.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output value type\n     * @param lifter the Operator that implements the Publisher-operating function to be applied to the source\n     *             Publisher\n     * @return a Flowable that is the result of applying the lifted Operator to the source Publisher\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {\n        ObjectHelper.requireNonNull(lifter, \"lifter is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLift<R, T>(this, lifter));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified function to each item emitted by the source Publisher and\n     * emits the results of these function applications.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/map.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output type\n     * @param mapper\n     *            a function to apply to each item emitted by the Publisher\n     * @return a Flowable that emits the items from the source Publisher, transformed by the specified\n     *         function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMap<T, R>(this, mapper));\n    }\n\n    \/**\n     * Returns a Flowable that represents all of the emissions <em>and<\/em> notifications from the source\n     * Publisher into emissions marked with their original types within {@link Notification} objects.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/materialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects it from the source {@code Publisher}.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits items that are the result of materializing the items and notifications\n     *         of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Materialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Notification<T>> materialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMaterialize<T>(this));\n    }\n\n    \/**\n     * Flattens this and another Publisher into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code mergeWith} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> mergeWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return merge(this, other);\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of {@link #bufferSize()} slots.\n     *\n     * <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly\n     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler, boolean)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) {\n        return observeOn(scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @param bufferSize the size of the buffer.\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n\n    \/**\n     * Filters the items emitted by a Publisher, only emitting those of the specified type.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ofClass.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output type\n     * @param clazz\n     *            the class type to filter the items emitted by the source Publisher\n     * @return a Flowable that emits items from the source Publisher of type {@code clazz}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> ofType(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return filter(Functions.isInstanceOf(clazz)).cast(clazz);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer() {\n        return onBackpressureBuffer(bufferSize(), false, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(boolean delayError) {\n        return onBackpressureBuffer(bufferSize(), delayError, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity) {\n        return onBackpressureBuffer(capacity, false, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) {\n        return onBackpressureBuffer(capacity, delayError, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) {\n        ObjectHelper.verifyPositive(capacity, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, Functions.EMPTY_ACTION));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,\n            Action onOverflow) {\n        ObjectHelper.requireNonNull(onOverflow, \"onOverflow is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, onOverflow));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) {\n        return onBackpressureBuffer(capacity, false, false, onOverflow);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will behave as determined\n     * by {@code overflowStrategy} if the buffer capacity is exceeded.\n     *\n     * <ul>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR} (default) will {@code onError} dropping all undelivered items,\n     *     cancelling the source, and notifying the producer with {@code onOverflow}. <\/li>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST} will drop any new items emitted by the producer while\n     *     the buffer is full, without generating any {@code onError}.  Each drop will however invoke {@code onOverflow}\n     *     to signal the overflow to the producer.<\/li>j\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST} will drop the oldest items in the buffer in order to make\n     *     room for newly emitted ones. Overflow will not generate an{@code onError}, but each drop will invoke\n     *     {@code onOverflow} to signal the overflow to the producer.<\/li>\n     * <\/ul>\n     *\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @param overflowStrategy how should the {@code Publisher} react to buffer overflows.  Null is not allowed.\n     * @return the source {@code Flowable} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {\n        ObjectHelper.requireNonNull(overflowStrategy, \"strategy is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBufferStrategy<T>(this, capacity, onOverflow, overflowStrategy));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {\n        ObjectHelper.requireNonNull(onDrop, \"onDrop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to\n     * hold onto the latest value and emit that on request.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.latest.png\" alt=\"\">\n     * <p>\n     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that\n     * the downstream is not blocking while requesting more values.\n     * <p>\n     * Note that if the upstream Publisher does support backpressure, this operator ignores that capability\n     * and doesn't propagate any backpressure requests from downstream.\n     * <p>\n     * Note that due to the nature of how backpressure requests are propagated through subscribeOn\/observeOn,\n     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified so that it emits the most recently-received item upon request\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureLatest() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureLatest<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass a function that returns a Publisher ({@code resumeFunction}) to\n     * {@code onErrorResumeNext}, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to the Publisher returned from\n     * {@code resumeFunction}, which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an error happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  a {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param resumeFunction\n     *            a function that returns a Publisher that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {\n        ObjectHelper.requireNonNull(resumeFunction, \"resumeFunction is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onErrorResumeNext} method, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which\n     * will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,\n     * because no Publisher necessarily invokes {@code onError}, the Subscriber may never know that an error\n     * happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher source that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return onErrorResumeNext(Functions.justFunction(next));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param valueSupplier\n     *            a function that returns a single value that will be emitted along with a regular onComplete in case\n     *            the current Flowable signals an onError event\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {\n        ObjectHelper.requireNonNull(valueSupplier, \"valueSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorReturn<T>(this, valueSupplier));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the value that is emitted along with a regular onComplete in case the current\n     *            Flowable signals an exception\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturnItem(final T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return onErrorReturn(Functions.justFunction(item));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an {@link java.lang.Exception}.\n     * <p>\n     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}\n     * or {@link java.lang.Error} but lets those continue through.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onExceptionResumeNextViaPublisher.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an exception that prevents it from emitting the expected item\n     * to its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onExceptionResumeNext} method changes\n     * this behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onExceptionResumeNext} method, if the original Publisher encounters an exception, instead of\n     * invoking its Subscriber's {@code onError} method, it will instead relinquish control to\n     * {@code resumeSequence} which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an exception happened.\n     * <p>\n     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher that will take over if the source Publisher encounters\n     *            an exception\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, Functions.justFunction(next), true));\n    }\n\n    \/**\n     * Nulls out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Flowable which out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onTerminateDetach() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDetach<T>(this));\n    }\n\n    \/**\n     * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel() {\n        return ParallelFlowable.from(this);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        return ParallelFlowable.from(this, parallelism);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion and\n     * uses the defined per-'rail' prefetch amount.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @param prefetch the number of items each 'rail' should prefetch\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism, int prefetch) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return ParallelFlowable.from(this, parallelism, prefetch);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish() {\n        return publish(bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        return publish(selector, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<? extends R>> selector, int prefetch) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowablePublishMulticast<T, R>(this, selector, prefetch, false));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowablePublish.create(this, bufferSize);\n    }\n\n    \/**\n     * Requests {@code n} initially from the upstream and then 75% of {@code n} subsequently\n     * after 75% of {@code n} values have been emitted to the downstream.\n     *\n     * <p>This operator allows preventing the downstream to trigger unbounded mode via {@code request(Long.MAX_VALUE)}\n     * or compensate for the per-item overhead of small and frequent requests.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects backpressure from upstream and honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param n the initial request amount, further request will happen after 75% of this value\n     * @return the Publisher that rebatches request amounts from downstream\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> rebatchRequests(int n) {\n        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);\n    }\n\n    \/**\n     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * and emits the final result from the final call to your function as its sole item.\n     * <p>\n     * If the source is empty, a {@code NoSuchElementException} is signalled.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduce.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be used in the next accumulator call\n     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by\n     *         the source Flowable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduce<T>(this, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seed\n     *            the initial (seed) accumulator value\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seed, \"seed is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceSeed<T, R>(this, seed, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduceWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seedSupplier\n     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceWith<T, R>(this, seedSupplier, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher indefinitely.\n     * <p>\n     * <img width=\"640\" height=\"309\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher repeatedly and in sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat() {\n        return repeat(Long.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     * {@code count} times.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param times\n     *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty\n     *            sequence\n     * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     *         {@code count} times\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat(long times) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        if (times == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeat<T>(this, times));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher until\n     * the provided stop function returns true.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stop\n     *                a boolean supplier that is called when the current Flowable completes and unless it returns\n     *                false, the current Flowable is resubscribed\n     * @return the new Flowable instance\n     * @throws NullPointerException\n     *             if {@code stop} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatUntil(BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatUntil<T>(this, stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of\n     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will\n     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeatWhen.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.\n     * @return the source Publisher modified with repeat logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatWhen<T>(this, handler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher\n     * that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its\n     *         items to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay() {\n        return FlowableReplay.createFrom(this);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on the items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @return a Flowable that emits items that are the results of invoking the selector on a\n     *         {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying {@code bufferSize} notifications.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     *         replaying no more than {@code bufferSize} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {\n        return replay(selector, bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(\n                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying a maximum of {@code bufferSize} items.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param scheduler\n     *            the Scheduler on which the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying no more than {@code bufferSize} notifications\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),\n                FlowableInternalHelper.replayFunction(selector, scheduler)\n        );\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"435\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ft.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {\n        return replay(selector, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fs.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param scheduler\n     *            the Scheduler where the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),\n                FlowableInternalHelper.replayFunction(selector, scheduler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items emitted by that Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay(final int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {\n        return replay(bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A\n     * Connectable Publisher resembles an ordinary Publisher, except that it does not begin emitting items\n     * when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is used as a time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param scheduler\n     *            the scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted by the Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(bufferSize), scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(long time, TimeUnit unit) {\n        return replay(time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.create(this, time, unit, scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * will replay all of its items and notifications to any future {@link Subscriber} on the given\n     * {@link Scheduler}. A Connectable Publisher resembles an ordinary Publisher, except that it does not\n     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the Scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     *         will replay all of its items and notifications to any future {@link Subscriber} on the given\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(), scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * (infinite retry count).\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher rather than propagating the {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry() {\n        return retry(Long.MAX_VALUE, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * and the predicate returns true for that specific exception and retry count.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the predicate that determines if a resubscription may happen in case of a specific exception\n     *            and retry count\n     * @return the source Publisher modified with retry logic\n     * @see #retry()\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryBiPredicate<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * up to a specified number of retries.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher for a maximum of {@code count} resubscriptions rather than propagating the\n     * {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of retry attempts before failing\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long count) {\n        return retry(count, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Retries at most times or until the predicate returns false, whichever happens first.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param times the number of times to repeat\n     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate));\n    }\n\n    \/**\n     * Retries the current Flowable if the predicate returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {\n        return retry(Long.MAX_VALUE, predicate);\n    }\n\n    \/**\n     * Retries until the given stop function returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param stop the function that should return true to stop retrying\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryUntil(final BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onError}. An {@code onError} notification from the source will result in the emission of a\n     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call\n     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retryWhen.f.png\" alt=\"\">\n     *\n     * Example:\n     *\n     * This retries 3 times, each time incrementing the number of seconds it waits.\n     *\n     * <pre><code>\n     *  Publisher.create((Subscriber<? super String> s) -> {\n     *      System.out.println(\"subscribing\");\n     *      s.onError(new RuntimeException(\"always fails\"));\n     *  }).retryWhen(attempts -> {\n     *      return attempts.zipWith(Publisher.range(1, 3), (n, i) -> i).flatMap(i -> {\n     *          System.out.println(\"delay retry by \" + i + \" second(s)\");\n     *          return Publisher.timer(i, TimeUnit.SECONDS);\n     *      });\n     *  }).blockingForEach(System.out::println);\n     * <\/code><\/pre>\n     *\n     * Output is:\n     *\n     * <pre> {@code\n     * subscribing\n     * delay retry by 1 second(s)\n     * subscribing\n     * delay retry by 2 second(s)\n     * subscribing\n     * delay retry by 3 second(s)\n     * subscribing\n     * } <\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the\n     *            retry\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryWhen(\n            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryWhen<T>(this, handler));\n    }\n\n    \/**\n     * Subscribes to the current Flowable and wraps the given Subscriber into a SafeSubscriber\n     * (if not already a SafeSubscriber) that\n     * deals with exceptions thrown by a misbehaving Subscriber (that doesn't follow the\n     * Reactive-Streams specification).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>This operator leaves the reactive world and the backpressure behavior depends on the Subscriber's behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the incoming Subscriber instance\n     * @throws NullPointerException if s is null\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void safeSubscribe(Subscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        if (s instanceof SafeSubscriber) {\n            subscribe((SafeSubscriber<? super T>)s);\n        } else {\n            subscribe(new SafeSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> sample(long period, TimeUnit unit) {\n        return sample(period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) {\n        return sample(period, unit, Schedulers.computation(), emitLast);\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler\n     * and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.nolast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> sample(Publisher<U> sampler) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher\n     * and optionally emit the very last upstream item when the upstream or other Publisher complete.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final <U> Flowable<T> sample(Publisher<U> sampler, boolean emitLast) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scan.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits the results of each call to the accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> scan(BiFunction<T, T, T> accumulator) {\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScan<T>(this, accumulator));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param initialValue\n     *            the initial (seed) accumulator item\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(initialValue, \"seed is null\");\n        return scanWith(Functions.justCallable(initialValue), accumulator);\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <p>\n     * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scanWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param seedSupplier\n     *            a Callable that returns the initial (seed) accumulator item for each individual Subscriber\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));\n    }\n\n    \/**\n     * Forces a Publisher's emissions and notifications to be serialized and for it to obey\n     * <a href=\"http:\/\/reactivex.io\/documentation\/contract.html\">the Publisher contract<\/a> in other ways.\n     * <p>\n     * It is possible for a Publisher to invoke its Subscribers' methods asynchronously, perhaps from\n     * different threads. This could make such a Publisher poorly-behaved, in that it might try to invoke\n     * {@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call\n     * {@code onNext} from two different threads concurrently. You can force such a Publisher to be\n     * well-behaved and sequential by applying the {@code serialize} method to it.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/synchronize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code serialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Publisher} that is guaranteed to be well-behaved and to make only serialized calls to\n     *         its Subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/serialize.html\">ReactiveX operators documentation: Serialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> serialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSerialized<T>(this));\n    }\n\n    \/**\n     * Returns a new {@link Publisher} that multicasts (shares) the original {@link Publisher}. As long as\n     * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.\n     * When all subscribers have cancelled it will cancel the source {@link Publisher}.\n     * <p>\n     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount()}.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishRefCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure and and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator will signal a {@code MissingBackpressureException} to\n     *  its {@code Subscriber}s.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code share} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@code Publisher} that upon connection causes the source {@code Publisher} to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/refcount.html\">ReactiveX operators documentation: RefCount<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> share() {\n        return publish().refCount();\n    }\n\n    \/**\n     * Returns a Maybe that completes if this Flowable is empty, signals one item if this Flowable\n     * signals exactly one item or signals an {@code IllegalArgumentException} if this Flowable signals\n     * more than one item.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Maybe that emits the single item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher\n     * emits only a single item, or a default item if the source Publisher emits no items. If the source\n     * Publisher emits more than one item, an {@code IllegalArgumentException} is signalled instead.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code single} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to emit if the source Publisher emits no item\n     * @return a Single that emits the single item emitted by the source Publisher, or a default item if\n     *         the source Publisher is empty\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> single(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by this Flowable, if this Flowable\n     * emits only a single item, otherwise\n     * if this Flowable completes without emitting any items a {@link NoSuchElementException} will be signalled and\n     * if this Flowable emits more than one item, an {@code IllegalArgumentException} will be signalled.\n     * <p>\n     * <img width=\"640\" height=\"205\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, true));\n    }\n\n    \/**\n     * Returns a Flowable that skips the first {@code count} items emitted by the source Publisher and emits\n     * the remainder.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the number of items to skip\n     * @return a Flowable that is identical to the source Publisher except that it does not emit the first\n     *         {@code count} items that the source Publisher emits\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long count) {\n        if (count <= 0L) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkip<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skip} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} elapses and the emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long time, TimeUnit unit) {\n        return skipUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * on a specified {@link Scheduler} elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for the timed skipping<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} on which the timed wait happens\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that drops a specified number of items from the end of the sequence emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.png\" alt=\"\">\n     * <p>\n     * This Subscriber accumulates a queue long enough to store the first {@code count} items. As more items are\n     * received, items are taken from the front of the queue and emitted by the returned Publisher. This causes\n     * such items to be delayed.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of items to drop from the end of the source sequence\n     * @return a Flowable that emits the items emitted by the source Publisher except for the dropped ones\n     *         at the end\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit) {\n        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) {\n        return skipLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use to track the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return skipLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be skipped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        \/\/ the internal buffer holds pairs of (timestamp, value) so double the default buffer size\n        int s = bufferSize << 1;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that skips items emitted by the source Publisher until a second Publisher emits\n     * an item.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param other\n     *            the second Publisher that has to emit an item before the source Publisher's elements begin\n     *            to be mirrored by the resulting Publisher\n     * @return a Flowable that skips items from the source Publisher until the second Publisher emits an\n     *         item, then emits the remaining items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipuntil.html\">ReactiveX operators documentation: SkipUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> skipUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that skips all items emitted by the source Publisher as long as a specified\n     * condition holds true, but emits all further source items as soon as the condition becomes false.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function to test each item emitted from the source Publisher\n     * @return a Flowable that begins emitting items emitted by the source Publisher when the specified\n     *         predicate becomes false\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipwhile.html\">ReactiveX operators documentation: SkipWhile<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));\n    }\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted() {\n        return toList().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order based on a specified comparison function.\n     *\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param sortFunction\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Iterable} before it begins to emit items\n     * emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            an Iterable that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Iterable<? extends T> items) {\n        return concatArray(fromIterable(items), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Publisher} before it begins to emit\n     * items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Publisher} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concatArray(other, this);\n    }\n\n    \/**\n     * Returns a Flowable that emits a specified item before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param value\n     *            the item to emit first\n     * @return a Flowable that emits the specified item before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(T value) {\n        ObjectHelper.requireNonNull(value, \"item is null\");\n        return concatArray(just(value), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the specified items before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWithArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of values to emit first\n     * @return a Flowable that emits the specified items before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWithArray(T... items) {\n        Flowable<T> fromArray = fromArray(items);\n        if (fromArray == empty()) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return concatArray(fromArray, this);\n    }\n\n    \/**\n     * Ensures that the event flow between the upstream and downstream follow\n     * the Reactive-Streams 1.0 specification by honoring the 3 additional rules\n     * (which are omitted in standard operators due to performance reasons).\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns<\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel<\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException)<\/li>\n     * <\/ul>\n     * In addition, if rule \u00a72.12 (onSubscribe must be called at most once) is violated,\n     * the sequence is cancelled an onError(IllegalStateException) is emitted.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code strict} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     * @since 2.0.5 - experimental\n     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    @CheckReturnValue\n    @Deprecated\n    public final Flowable<T> strict() {\n        return this;\n    }\n\n    \/**\n     * Subscribes to a Publisher and ignores {@code onNext} and {@code onComplete} emissions.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe() {\n        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides a callback to handle the items it emits.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext) {\n        return subscribe(onNext, Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error\n     * notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete) {\n        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @param onSubscribe\n     *             the {@code Consumer} that receives the upstream's Subscription\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Consumer<? super Subscription> onSubscribe) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n\n        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);\n\n        subscribe(ls);\n\n        return ls;\n    }\n\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Override\n    public final void subscribe(Subscriber<? super T> s) {\n        if (s instanceof RelaxedSubscriber) {\n            subscribe((RelaxedSubscriber<? super T>)s);\n        } else {\n            ObjectHelper.requireNonNull(s, \"s is null\");\n            subscribe(new StrictSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Establish a connection between this Flowable and the given RelaxedSubscriber and\n     * start streaming events based on the demand of the RelaxedSubscriber.\n     * <p>\n     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n     * <p>\n     * Each {@link Subscription} will work for only a single {@link RelaxedSubscriber}.\n     * <p>\n     * If the same {@link RelaxedSubscriber} instance is subscribed to multiple {@link Flowable}s and\/or the\n     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}\n     * methods manually.\n     * <p>\n     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal\n     * the error via {@link RelaxedSubscriber#onError(Throwable)}.\n     * <p>\n     * This subscribe method relaxes the following Reactive-Streams rules:\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns.\n     *     <b>RelaxedSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.<\/b><\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel.\n     *     <b>Calling request() or cancel() is NOP at this point.<\/b><\/li>\n     * <li>\u00a72.12: onSubscribe must be called at most once on the same instance.\n     *     <b>RelaxedSubscriber reuse is not checked and if happens, it is the responsibility of\n     *     the RelaxedSubscriber to ensure proper serialization of its onXXX methods.<\/b><\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException).\n     *     <b>Non-positive requests signal via RxJavaFlowablePlugins.onError and the stream is not affected.<\/b><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code RelaxedSubscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the RelaxedSubscriber that will consume signals from this Flowable\n     * @since 2.0.7 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final void subscribe(RelaxedSubscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        try {\n            Subscriber<? super T> z = RxJavaFlowablePlugins.onSubscribe(this, s);\n\n            ObjectHelper.requireNonNull(z, \"Plugin returned null Subscriber\");\n\n            subscribeActual(z);\n        } catch (NullPointerException e) { \/\/ NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            \/\/ can't call onError because no way to know if a Subscription has been set or not\n            \/\/ can't call onSubscribe because the call might have set a Subscription already\n            RxJavaCommonPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n\n    \/**\n     * Operator implementations (both source and intermediate) should implement this method that\n     * performs the necessary business logic.\n     * <p>There is no need to call any of the plugin hooks on the current Flowable instance or\n     * the Subscriber.\n     * @param s the incoming Subscriber, never null\n     *\/\n    protected abstract void subscribeActual(Subscriber<? super T> s);\n\n    \/**\n     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given\n     * Subscriber as is.\n     * <p>Usage example:\n     * <pre><code>\n     * Flowable&lt;Integer> source = Flowable.range(1, 10);\n     * CompositeDisposable composite = new CompositeDisposable();\n     *\n     * ResourceSubscriber&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n     *     \/\/ ...\n     * };\n     *\n     * composite.add(source.subscribeWith(rs));\n     * <\/code><\/pre>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code Subscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <E> the type of the Subscriber to use and return\n     * @param subscriber the Subscriber (subclass) to use and return, not null\n     * @return the input {@code subscriber}\n     * @throws NullPointerException if {@code subscriber} is null\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n        subscribe(subscriber);\n        return subscriber;\n    }\n\n    \/**\n     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/subscribeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform subscription actions on\n     * @return the source Publisher modified so that its subscriptions happen on the\n     *         specified {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #observeOn\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or the items of an alternate\n     * Publisher if the source Publisher is empty.\n     * <img width=\"640\" height=\"255\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchifempty.png\" alt=\"\">\n     * <p\/>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, the alternate {@code Publisher} is expected to honor backpressure.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as instead.\n     *  In either case, if violated, a {@code MissingBackpressureException} <em>may<\/em> get\n     *  signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *              the alternate Publisher to subscribe to if the source does not emit any items\n     * @return  a Publisher that emits the items emitted by the source Publisher or the items of an\n     *          alternate Publisher if the source Publisher is empty.\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMap(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, false);\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMapDelayError(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, true);\n    }\n\n    <R> Flowable<R> switchMap0(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize, boolean delayError) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchMap<T, R>(this, mapper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.png\" alt=\"\">\n     * <p>\n     * This method returns a Publisher that will invoke a subscribing {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking\n     * {@link Subscriber#onComplete onComplete}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior in case the first request is smaller than the {@code count}. Otherwise, the source {@code Publisher}\n     *  is consumed in an unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @return a Flowable that emits only the first {@code count} items emitted by the source Publisher, or\n     *         all of the items from the source Publisher if that Publisher emits fewer than {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> take(long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTake<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time runs\n     * out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> take(long time, TimeUnit unit) {\n        return takeUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time (on a\n     * specified Scheduler) runs out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler used for time source\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out,\n     *         according to the specified Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream if the {@code count} is non-zero; ignores\n     *  backpressure if the {@code count} is zero as it doesn't signal any values.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit from the end of the sequence of items emitted by the source\n     *            Publisher\n     * @return a Flowable that emits at most the last {@code count} items emitted by the source Publisher\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n        } else\n        if (count == 1) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastOne<T>(this));\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {\n        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(count, time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit) {\n        return takeLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) {\n        return takeLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return takeLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher, checks the specified predicate\n     * for each item, and then completes when the condition is satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.p.png\" alt=\"\">\n     * <p>\n     * The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition is\n     * evaluated <em>after<\/em> the item is emitted.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstream\n     *  source and the downstream consumer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stopPredicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that first emits items emitted by the source Publisher, checks the specified\n     *         condition after each item, and then completes when the condition is satisfied.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     * @see Flowable#takeWhile(Predicate)\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {\n        ObjectHelper.requireNonNull(stopPredicate, \"stopPredicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher until a second Publisher\n     * emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items\n     *            from the source Publisher\n     * @param <U>\n     *            the type of items emitted by {@code other}\n     * @return a Flowable that emits the items emitted by the source Publisher until such time as {@code other} emits its first item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> takeUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher so long as each item satisfied a\n     * specified condition, and then completes as soon as this condition is not satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that emits the items from the source Publisher so long as each item satisfies the\n     *         condition defined by {@code predicate}, then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\">ReactiveX operators documentation: TakeWhile<\/a>\n     * @see Flowable#takeUntil(Predicate)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param windowDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code windowDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {\n        return throttleFirst(windowDuration, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the windows are managed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param skipDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code skipDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {\n        return sample(intervalDuration, unit);\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the duration is governed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {\n        return sample(intervalDuration, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window, where the time window is governed by a specified\n     * Scheduler.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {\n        return debounce(timeout, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval() {\n        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(Scheduler scheduler) {\n        return timeInterval(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {\n        return timeInterval(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if an item emitted by the source Publisher doesn't arrive within a window of\n     * time after the emission of the previous item, where that period of time is measured by a Publisher that\n     * is a function of the previous item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout3.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source\n     *            Publisher and that determines the timeout window for the subsequent item\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if an item emitted by the source Publisher takes longer to arrive than\n     *         the time window defined by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        return timeout0(null, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but that switches to a fallback Publisher if\n     * an item emitted by the source Publisher doesn't arrive within a window of time after the emission of the\n     * previous item, where that period of time is measured by a Publisher that is a function of the previous\n     * item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout4.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher, for each item emitted by the source Publisher, that\n     *            determines the timeout window for the subsequent item\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to mirroring a fallback Publisher\n     *         if an item emitted by the source Publisher takes longer to arrive than the time window defined\n     *         by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator, Flowable<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(null, itemTimeoutIndicator, other);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher terminates and notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between emitted items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument.\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {\n        return timeout0(timeout, timeUnit, null, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param other\n     *            the fallback Publisher to use in case of a timeout\n     * @return the source Publisher modified to switch to the fallback Publisher in case of a timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration\n     * starting from its predecessor, the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to run the timeout timers on\n     * @param other\n     *            the Publisher to use as the fallback in case of a timeout\n     * @return the source Publisher modified so that it will switch to the fallback Publisher in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the\n     * specified timeout duration starting from its predecessor, the resulting Publisher terminates and\n     * notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the Scheduler to run the timeout timers on\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {\n        return timeout0(timeout, timeUnit, null, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if either the first item emitted by the source Publisher or any subsequent item\n     * doesn't arrive within time windows defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher that determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within\n     *         the time windows specified by the timeout selectors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutIndicator is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but switches to a fallback Publisher if either\n     * the first item emitted by the source Publisher or any subsequent item doesn't arrive within time windows\n     * defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher which determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to the {@code other} Publisher if\n     *         either the first item emitted by the source Publisher or any subsequent item doesn't arrive\n     *         within time windows defined by the timeout selectors\n     * @throws NullPointerException\n     *             if {@code itemTimeoutIndicator} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutSelector is null\");\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, other);\n    }\n\n    private Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,\n            Scheduler scheduler) {\n        ObjectHelper.requireNonNull(timeUnit, \"timeUnit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other));\n    }\n\n    private <U, V> Flowable<T> timeout0(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(itemTimeoutIndicator, \"itemTimeoutIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeout<T, U, V>(this, firstTimeoutIndicator, itemTimeoutIndicator, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp() {\n        return timestamp(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {\n        return timestamp(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp(TimeUnit unit) {\n        return timestamp(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return map(Functions.<T>timestampWith(unit, scheduler));\n    }\n\n    \/**\n     * Calls the specified converter function during assembly time and returns its resulting value.\n     * <p>\n     * This allows fluent conversion to any other type.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The backpressure behavior depends on what happens in the {@code converter} function.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code to} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the resulting object type\n     * @param converter the function that receives the current Flowable instance and returns a value\n     * @return the value returned by the function\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> R to(Function<? super Flowable<T>, R> converter) {\n        try {\n            return ObjectHelper.requireNonNull(converter, \"converter is null\").apply(this);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, ArrayListSupplier.<T>asCallable()));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *         the number of elements expected from the current Flowable\n     * @return a Flowable that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList(final int capacityHint) {\n        ObjectHelper.verifyPositive(capacityHint, \"capacityHint\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the subclass of a collection of Ts\n     * @param collectionSupplier\n     *               the Callable returning the collection (for each individual Subscriber) to be filled in\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> toList(Callable<U> collectionSupplier) {\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, U>(this, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing all items emitted by the source Publisher,\n     * mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return collect(HashMapSupplier.<K, T>asCallable(), Functions.toMapKeySelector(keySelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing values corresponding to items emitted by the\n     * source Publisher, mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain a single entry that\n     * corresponds to the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @param valueSelector\n     *            the function that extracts the value from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(HashMapSupplier.<K, V>asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains keys and values extracted from the items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the Map\n     * @param valueSelector\n     *            the function that extracts the value from the source items to be used as value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Flowable that emits a single item: a Map that contains the mapped items emitted by the\n     *         source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, V>> mapSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of items emitted by the\n     * source Publisher keyed by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from the source items to be used as key in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {\n        Function<T, T> valueSelector = Functions.identity();\n        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of values extracted by a\n     * specified {@code valueSelector} function from items emitted by the source Publisher, keyed by a\n     * specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as key in the HashMap\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as value in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {\n        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from\n     * items emitted by the source Publisher, and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @param collectionFactory\n     *            the function that returns a Collection instance for a particular key to be used in the Map\n     * @return a Single that emits a single item: a Map that contains the collection of mapped items from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, Collection<V>>> mapSupplier,\n            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.requireNonNull(mapSupplier, \"mapSupplier is null\");\n        ObjectHelper.requireNonNull(collectionFactory, \"collectionFactory is null\");\n        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items\n     * emitted by the source Publisher and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Single that emits a single item: a Map that contains a list items mapped from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            Callable<Map<K, Collection<V>>> mapSupplier\n            ) {\n        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList() {\n        return toSortedList(Functions.naturalComparator());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList().map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList(capacityHint).map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Flowable that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Flowable that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(int capacityHint) {\n        return toSortedList(Functions.naturalComparator(), capacityHint);\n    }\n\n    \/**\n     * Modifies the source Publisher so that subscribers will cancel it on a specified\n     * {@link Scheduler}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform cancellation actions on\n     * @return the source Publisher modified so that its cancellations happen on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current window and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows, each containing at most\n     *         {@code count} items from the source Publisher\n     * @throws IllegalArgumentException if either count is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count) {\n        return window(count, count, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip) {\n        return window(count, skip, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {\n        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return window(timespan, timeskip, unit, scheduler, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.verifyPositive(timespan, \"timespan\");\n        ObjectHelper.verifyPositive(timeskip, \"timeskip\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping windows representing items emitted by the\n     *         source Publisher during fixed, consecutive durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) {\n        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count) {\n        return window(timespan, unit, Schedulers.computation(), count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count, boolean restart) {\n        return window(timespan, unit, Schedulers.computation(), count, restart);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows containing items emitted by the\n     *         source Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler) {\n        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count) {\n        return window(timespan, unit, scheduler, count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count, boolean restart) {\n        return window(timespan, unit, scheduler, count, restart, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(\n            long timespan, TimeUnit unit, Scheduler scheduler,\n            long count, boolean restart, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator) {\n        return window(boundaryIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundaryIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator) {\n        return window(openingIndicator, closingIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return window(boundaryIndicatorSupplier, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));\n    }\n\n    \/**\n     * Merges the specified Publisher into this Publisher sequence by using the {@code resultSelector}\n     * function only when the source Publisher (this instance) emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/withLatestFrom.png\" alt=\"\">\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure: the backpressure support\n     *  depends on the upstream and downstream's backpressure behavior. The other Publisher\n     *  is consumed in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator, by default, doesn't run any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param <R> the result type of the combination\n     * @param other\n     *            the other Publisher\n     * @param combiner\n     *            the function to call when this Publisher emits an item and the other Publisher has already\n     *            emitted an item, to generate the item to be emitted by the resulting Publisher\n     * @return a Flowable that merges the specified Publisher into this Publisher by using the\n     *         {@code resultSelector} function only when the source Publisher sequence (this instance) emits an\n     *         item\n     * @since 2.0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> withLatestFrom(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFrom<T, U, R>(this, combiner, other));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> source1, Publisher<T2> source2,\n            Function3<? super T, ? super T1, ? super T2, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3,\n            Function4<? super T, ? super T1, ? super T2, ? super T3, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <T4> the fourth other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param source4 the fourth other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, T4, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3, Publisher<T4> source4,\n            Function5<? super T, ? super T1, ? super T2, ? super T3, ? super T4, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the array of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Publisher<?>[] others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the iterable of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Iterable<? extends Publisher<?>> others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and a specified Iterable sequence.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.i.png\" alt=\"\">\n     * <p>\n     * Note that the {@code other} Iterable is evaluated as items are observed from the source Publisher; it is\n     * not pre-consumed. This allows you to zip infinite streams on either side.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items in the {@code other} Iterable\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the Iterable sequence\n     * @param zipper\n     *            a function that combines the pairs of items from the Publisher and the Iterable to generate\n     *            the items to be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Iterable\n     *         sequence and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return zip(this, other, zipper);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {\n        return zip(this, other, zipper, delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {\n        return zip(this, other, zipper, delayError, bufferSize);\n    }\n\n    \/\/ -------------------------------------------------------------------------\n    \/\/ Fluent test support, super handy and reduces test preparation boilerplate\n    \/\/ -------------------------------------------------------------------------\n    \/**\n     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber consumes this Flowable in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test() { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>();\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount,\n     * optionally cancels it before the subscription and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @param cancel should the TestSubscriber be cancelled before the subscription?\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest, boolean cancel) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        if (cancel) {\n            ts.cancel();\n        }\n        subscribe(ts);\n        return ts;\n    }\n\n}\n","new_contents":"\/**\n * Copyright (c) 2016-present, RxJava Contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n * the License for the specific language governing permissions and limitations under the License.\n *\/\npackage io.reactivex.flowable;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\nimport org.reactivestreams.*;\n\nimport hu.akarnokd.reactivestreams.extensions.*;\nimport io.reactivex.common.*;\nimport io.reactivex.common.annotations.*;\nimport io.reactivex.common.exceptions.Exceptions;\nimport io.reactivex.common.functions.*;\nimport io.reactivex.common.internal.functions.*;\nimport io.reactivex.common.internal.schedulers.ImmediateThinScheduler;\nimport io.reactivex.common.internal.utils.*;\nimport io.reactivex.flowable.internal.operators.*;\nimport io.reactivex.flowable.internal.subscribers.*;\nimport io.reactivex.flowable.subscribers.*;\n\n\/**\n * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,\n * intermediate operators and the ability to consume reactive dataflows.\n * <p>\n * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators\n * therefore accept general {@code Publisher}s directly and allow direct interoperation with other\n * Reactive-Streams implementations.\n * <p>\n * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},\n * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have\n * overloads that allow setting their internal buffer size explicitly.\n * <p>\n * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:\n * <p>\n * <img width=\"640\" height=\"317\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/legend.png\" alt=\"\">\n * <p>\n * For more information see the <a href=\"http:\/\/reactivex.io\/documentation\/Publisher.html\">ReactiveX\n * documentation<\/a>.\n *\n * @param <T>\n *            the type of the items emitted by the Flowable\n *\/\npublic abstract class Flowable<T> implements Publisher<T> {\n    \/** The default buffer size. *\/\n    static final int BUFFER_SIZE;\n    static {\n        BUFFER_SIZE = Math.max(1, Integer.getInteger(\"rx2.buffer-size\", 128));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an Iterable of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an Iterable of Publishers sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(null, sources));\n    }\n\n    \/**\n     * Mirrors the one Publisher in an array of several Publishers that first either emits an item or sends\n     * a termination notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param sources\n     *            an array of Publisher sources competing to react first. A subscription to each Publisher will\n     *            occur in the same order as in this Iterable.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> ambArray(Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        int len = sources.length;\n        if (len == 0) {\n            return empty();\n        } else\n        if (len == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAmb<T>(sources, null));\n    }\n\n    \/**\n     * Returns the default internal buffer size used by most async operators.\n     * <p>The value can be overridden via system parameter {@code rx2.buffer-size}\n     * <em>before<\/em> the Flowable class is loaded.\n     * @return the default internal buffer size.\n     *\/\n    public static int bufferSize() {\n        return BUFFER_SIZE;\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Function<? super Object[], ? extends R> combiner, Publisher<? extends T>... sources) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatest(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publisher, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Publisher\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,\n            int bufferSize, Publisher<? extends T>... sources) {\n        return combineLatestDelayError(sources, combiner, bufferSize);\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner) {\n        return combineLatestDelayError(sources, combiner, bufferSize());\n    }\n\n    \/**\n     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of\n     * the source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function and delays any error from the sources until\n     * all source Publishers terminate.\n     * <p>\n     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the\n     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a\n     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the common base type of source values\n     * @param <R>\n     *            the result type\n     * @param sources\n     *            the collection of source Publishers\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @param bufferSize\n     *            the internal buffer size and prefetch amount applied to every source Flowable\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> combiner, int bufferSize) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true));\n    }\n\n    \/**\n     * Combines two source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from either of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return combineLatest(f, source1, source2);\n    }\n\n    \/**\n     * Combines three source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);\n    }\n\n    \/**\n     * Combines four source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Combines five source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Combines six source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Combines seven source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Combines eight source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Combines nine source Publishers by emitting an item that aggregates the latest values of each of the\n     * source Publishers each time an item is received from any of the source Publishers, where this\n     * aggregation is defined by a specified function.\n     * <p>\n     * If any of the sources never produces an item but only terminates (normally or with an error), the\n     * resulting sequence terminates immediately (normally or with all the errors accumulated till that point).\n     * If that input source is also synchronous, other sources after it will not be subscribed to.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/combineLatest.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s\n     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal\n     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the element type of the first source\n     * @param <T2> the element type of the second source\n     * @param <T3> the element type of the third source\n     * @param <T4> the element type of the fourth source\n     * @param <T5> the element type of the fifth source\n     * @param <T6> the element type of the sixth source\n     * @param <T7> the element type of the seventh source\n     * @param <T8> the element type of the eighth source\n     * @param <T9> the element type of the ninth source\n     * @param <R> the combined output type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            the second source Publisher\n     * @param source3\n     *            the third source Publisher\n     * @param source4\n     *            the fourth source Publisher\n     * @param source5\n     *            the fifth source Publisher\n     * @param source6\n     *            the sixth source Publisher\n     * @param source7\n     *            the seventh source Publisher\n     * @param source8\n     *            the eighth source Publisher\n     * @param source9\n     *            the ninth source Publisher\n     * @param combiner\n     *            the aggregation function used to combine the items emitted by the source Publishers\n     * @return a Flowable that emits items that are the result of combining the items emitted by the source\n     *         Publishers by means of the given aggregation function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            Publisher<? extends T3> source3, Publisher<? extends T4> source4,\n            Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Concatenates elements of each Publisher provided via an Iterable sequence into a single sequence\n     * of elements without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the common value type of the sources\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Flowable instance\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        \/\/ unlike general sources, fromIterable can only throw on a boundary because it is consumed only there\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), 2, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {\n        return concat(sources, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source\n     * Publisher, one after the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param prefetch\n     *            the number of Publishers to prefetch from the sources sequence.\n     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by\n     *         {@code Publishers}, one after the other, without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by two Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return concatArray(source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by three Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the three source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return concatArray(source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by four Publishers, one after the other, without\n     * interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be concatenated\n     * @param source2\n     *            a Publisher to be concatenated\n     * @param source3\n     *            a Publisher to be concatenated\n     * @param source4\n     *            a Publisher to be concatenated\n     * @return a Flowable that emits items emitted by the four source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concat(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return concatArray(source1, source2, source3, source4);\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources.\n     * <p>\n     * Note: named this way because of overload conflict with concat(Publisher&lt;Publisher&gt).\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Publisher instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, false));\n    }\n\n    \/**\n     * Concatenates a variable number of Publisher sources and delays errors from any of them\n     * till all terminate.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param sources the array of sources\n     * @param <T> the common base value type\n     * @return the new Flowable instance\n     * @throws NullPointerException if sources is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        } else\n        if (sources.length == 1) {\n            return fromPublisher(sources[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatArray<T>(sources, true));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {\n        return concatArrayEager(bufferSize(), bufferSize(), sources);\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, the operator will signal a\n     *  {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE\n     *                       is interpreted as indication to subscribe to all sources at once\n     * @param prefetch the number of elements to prefetch from each Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\n     * one after the other, one at a time and delays any errors till the all inner Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\n     *  sources are expected to honor backpressure as well. If the outer violates this, a\n     *  {@code MissingBackpressureException} is signalled. If any of the inner {@code Publisher}s violates\n     *  this, it <em>may<\/em> throw an {@code IllegalStateException} when an inner {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Iterable sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return fromIterable(sources).concatMapDelayError((Function)Functions.identity());\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatDelayError(sources, bufferSize(), true);\n    }\n\n    \/**\n     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,\n     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} fully supports backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources the Publisher sequence of Publishers\n     * @param prefetch the number of elements to prefetch from the outer Publisher\n     * @param tillTheEnd if true exceptions from the outer and all inner Publishers are delayed to the end\n     *                   if false, exception from the outer Publisher is delayed till the current Publisher terminates\n     * @return the new Publisher with the concatenating behavior\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {\n        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * emitted source Publishers as they are observed. The operator buffers the values emitted by these\n     * Publishers and then drains them in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and the inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {\n        return concatEager(sources, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Concatenates a sequence of Publishers eagerly into a single stream of values.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them\n     * in order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream and both the outer and inner Publishers are\n     *  expected to support backpressure. Violating this assumption, the operator will\n     *  signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type\n     * @param sources a sequence of Publishers that need to be eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE\n     *                       is interpreted as all inner Publishers can be active at the same time\n     * @param prefetch the number of elements to prefetch from each inner Publisher source\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Provides an API (via a cold Flowable) that bridges the reactive world with the callback-style,\n     * generally non-backpressured world.\n     * <p>\n     * Example:\n     * <pre><code>\n     * Flowable.&lt;Event&gt;create(emitter -&gt; {\n     *     Callback listener = new Callback() {\n     *         &#64;Override\n     *         public void onEvent(Event e) {\n     *             emitter.onNext(e);\n     *             if (e.isLast()) {\n     *                 emitter.onComplete();\n     *             }\n     *         }\n     *\n     *         &#64;Override\n     *         public void onFailure(Exception e) {\n     *             emitter.onError(e);\n     *         }\n     *     };\n     *\n     *     AutoCloseable c = api.someMethod(listener);\n     *\n     *     emitter.setCancellable(c::close);\n     *\n     * }, BackpressureStrategy.BUFFER);\n     * <\/code><\/pre>\n     * <p>\n     * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The\n     * rest of its methods are thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior is determined by the {@code mode} parameter.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code create} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type\n     * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}\n     * @param mode the backpressure mode to apply if the downstream Subscriber doesn't request (fast) enough\n     * @return the new Flowable instance\n     * @see FlowableOnSubscribe\n     * @see BackpressureStrategy\n     * @see Cancellable\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        ObjectHelper.requireNonNull(mode, \"mode is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCreate<T>(source, mode));\n    }\n\n    \/**\n     * Returns a Flowable that calls a Publisher factory to create a Publisher for each new Subscriber\n     * that subscribes. That is, for each subscriber, the actual Publisher that subscriber observes is\n     * determined by the factory function.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defer.png\" alt=\"\">\n     * <p>\n     * The defer Subscriber allows you to defer or delay emitting items from a Publisher until such time as an\n     * Subscriber subscribes to the Publisher. This allows a {@link Subscriber} to easily obtain updates or a\n     * refreshed version of the sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}\n     *  returned by the {@code supplier}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            the Publisher factory function to invoke for each {@link Subscriber} that subscribes to the\n     *            resulting Publisher\n     * @param <T>\n     *            the type of the items emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given\n     *         Publisher factory function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defer.html\">ReactiveX operators documentation: Defer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> defer(Callable<? extends Publisher<? extends T>> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDefer<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits no items to the {@link Subscriber} and immediately invokes its\n     * {@link Subscriber#onComplete onComplete} method.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/empty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code empty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that emits no items to the {@link Subscriber} but immediately invokes the\n     *         {@link Subscriber}'s {@link Subscriber#onComplete() onComplete} method\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Empty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> empty() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *            a Callable factory to return a Throwable for each individual Subscriber\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"errorSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableError<T>(supplier));\n    }\n\n    \/**\n     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the\n     * Subscriber subscribes to it.\n     * <p>\n     * <img width=\"640\" height=\"190\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/error.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param throwable\n     *            the particular Throwable to pass to {@link Subscriber#onError onError}\n     * @param <T>\n     *            the type of the items (ostensibly) emitted by the Publisher\n     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when\n     *         the Subscriber subscribes to it\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Throw<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> error(final Throwable throwable) {\n        ObjectHelper.requireNonNull(throwable, \"throwable is null\");\n        return error(Functions.justCallable(throwable));\n    }\n\n    \/**\n     * Converts an Array into a Publisher that emits the items in the Array.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code array}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of elements\n     * @param <T>\n     *            the type of items in the Array and the type of items to be emitted by the resulting Publisher\n     * @return a Flowable that emits each item in the source Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromArray(T... items) {\n        ObjectHelper.requireNonNull(items, \"items is null\");\n        if (items.length == 0) {\n            return empty();\n        }\n        if (items.length == 1) {\n            return just(items[0]);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromArray<T>(items));\n    }\n\n    \/**\n     * Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then\n     * emits the value returned from that function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/fromCallable.png\" alt=\"\">\n     * <p>\n     * This allows you to defer the execution of the function you specify until a Subscriber subscribes to the\n     * Publisher. That is to say, it makes the function \"lazy.\"\n     * <dl>\n     *   <dt><b>Backpressure:<\/b><\/dt>\n     *   <dd>The operator honors backpressure from downstream.<\/dd>\n     *   <dt><b>Scheduler:<\/b><\/dt>\n     *   <dd>{@code fromCallable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param supplier\n     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this\n     *         function only when a Subscriber subscribes to the Publisher that {@code fromCallable} returns\n     * @param <T>\n     *         the type of the item emitted by the Publisher\n     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given function\n     * @see #defer(Callable)\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromCallable(Callable<? extends T> supplier) {\n        ObjectHelper.requireNonNull(supplier, \"supplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromCallable<T>(supplier));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, 0L, null));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {\n        ObjectHelper.requireNonNull(future, \"future is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromFuture<T>(future, timeout, unit));\n    }\n\n    \/**\n     * Converts a {@link Future} into a Publisher, with a timeout on the Future.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <p>\n     * <em>Important note:<\/em> This Publisher is blocking; you cannot cancel it.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param timeout\n     *            the maximum time to wait before calling {@code get}\n     * @param unit\n     *            the {@link TimeUnit} of the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.Future.s.png\" alt=\"\">\n     * <p>\n     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the\n     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}\n     * method.\n     * <p>\n     * Unlike 1.x, cancelling the Flowable won't cancel the future. If necessary, one can use composition to achieve the\n     * cancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param future\n     *            the source {@link Future}\n     * @param scheduler\n     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as\n     *            {@link Schedulers#io()} that can block and wait on the Future\n     * @param <T>\n     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by\n     *            the resulting Publisher\n     * @return a Flowable that emits the item from the source {@link Future}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @SuppressWarnings({ \"cast\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return fromFuture((Future<T>)future).subscribeOn(scheduler);\n    }\n\n    \/**\n     * Converts an {@link Iterable} sequence into a Publisher that emits the items in the sequence.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and iterates the given {@code iterable}\n     *  on demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source\n     *            the source {@link Iterable} sequence\n     * @param <T>\n     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the\n     *            resulting Publisher\n     * @return a Flowable that emits each item in the source {@link Iterable} sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/from.html\">ReactiveX operators documentation: From<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromIterable<T>(source));\n    }\n\n    \/**\n     * Converts an arbitrary Reactive-Streams Publisher into a Flowable if not already a\n     * Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and its behavior is determined by the\n     *  backpressure behavior of the wrapped publisher.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type of the flow\n     * @param source the Publisher to convert\n     * @return the new Flowable instance\n     * @throws NullPointerException if publisher is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> source) {\n        if (source instanceof Flowable) {\n            return RxJavaFlowablePlugins.onAssembly((Flowable<T>)source);\n        }\n        ObjectHelper.requireNonNull(source, \"publisher is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(source));\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateless and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the generated value type\n     * @param generator the Consumer called whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> generate(final Consumer<Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(Functions.nullSupplier(),\n                FlowableInternalHelper.<T, Object>simpleGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator),\n                Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator,\n            Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), disposeState);\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {\n        return generate(initialState, generator, Functions.emptyConsumer());\n    }\n\n    \/**\n     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code generate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <S> the type of the per-Subscriber state\n     * @param <T> the generated value type\n     * @param initialState the Callable to generate the initial state for each Subscriber\n     * @param generator the Function called with the current state whenever a particular downstream Subscriber has\n     * requested a value. The callback then should call {@code onNext}, {@code onError} or\n     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for\n     * the next invocation. Signalling multiple {@code onNext}\n     * in a call will make the operator signal {@code IllegalStateException}.\n     * @param disposeState the Consumer that is called with the current state when the generator\n     * terminates the sequence or it gets cancelled\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator, Consumer<? super S> disposeState) {\n        ObjectHelper.requireNonNull(initialState, \"initialState is null\");\n        ObjectHelper.requireNonNull(generator, \"generator is null\");\n        ObjectHelper.requireNonNull(disposeState, \"disposeState is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGenerate<T, S>(initialState, generator, disposeState));\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.p.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) {\n        return interval(initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers\n     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.ps.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param initialDelay\n     *            the initial delay time to wait before emitting the first value of 0L\n     * @param period\n     *            the period of time between emissions of the subsequent numbers\n     * @param unit\n     *            the time unit for both {@code initialDelay} and {@code period}\n     * @param scheduler\n     *            the Scheduler on which the waiting happens and items are emitted\n     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever increasing numbers after\n     *         each {@code period} of time thereafter, while running on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     * @since 1.0.12\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream\n     *  is not ready to receive the next value.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> interval(long period, TimeUnit unit) {\n        return interval(period, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequential number every specified interval of time, on a\n     * specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/interval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator generates values based on time and ignores downstream backpressure which\n     *  may lead to {@code MissingBackpressureException} at some point in the chain.\n     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the period size in time units (see below)\n     * @param unit\n     *            time units to use for the interval size\n     * @param scheduler\n     *            the Scheduler to use for scheduling the items\n     * @return a Flowable that emits a sequential number each time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/interval.html\">ReactiveX operators documentation: Interval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {\n        return interval(period, period, unit, scheduler);\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {\n        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Signals a range of long values, the first after some initial delay and the rest periodically after.\n     * <p>\n     * The sequence completes immediately after the last value (start + count - 1) has been reached.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>you provide the {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param start that start value of the range\n     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.\n     * @param initialDelay the initial delay before signalling the first value (the start)\n     * @param period the period between subsequent values\n     * @param unit the unit of measure of the initialDelay and period amounts\n     * @param scheduler the target scheduler where the values and terminal signals will be emitted\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0L) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0L) {\n            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits a single item and then completes.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.png\" alt=\"\">\n     * <p>\n     * To convert any object into a Publisher that emits that object, pass that object into the {@code just}\n     * method.\n     * <p>\n     * This is similar to the {@link #fromArray(java.lang.Object[])} method, except that {@code from} will convert\n     * an {@link Iterable} object into a Publisher that emits each of the items in the Iterable, one at a\n     * time, while the {@code just} method converts an Iterable into a Publisher that emits the entire\n     * Iterable as a single item.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to emit\n     * @param <T>\n     *            the type of that item\n     * @return a Flowable that emits {@code value} as a single item and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJust<T>(item));\n    }\n\n    \/**\n     * Converts two items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n\n        return fromArray(item1, item2);\n    }\n\n    \/**\n     * Converts three items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n\n        return fromArray(item1, item2, item3);\n    }\n\n    \/**\n     * Converts four items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n\n        return fromArray(item1, item2, item3, item4);\n    }\n\n    \/**\n     * Converts five items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5);\n    }\n\n    \/**\n     * Converts six items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6);\n    }\n\n    \/**\n     * Converts seven items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7);\n    }\n\n    \/**\n     * Converts eight items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);\n    }\n\n    \/**\n     * Converts nine items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);\n    }\n\n    \/**\n     * Converts ten items into a Publisher that emits those items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/just.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item1\n     *            first item\n     * @param item2\n     *            second item\n     * @param item3\n     *            third item\n     * @param item4\n     *            fourth item\n     * @param item5\n     *            fifth item\n     * @param item6\n     *            sixth item\n     * @param item7\n     *            seventh item\n     * @param item8\n     *            eighth item\n     * @param item9\n     *            ninth item\n     * @param item10\n     *            tenth item\n     * @param <T>\n     *            the type of these items\n     * @return a Flowable that emits each item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/just.html\">ReactiveX operators documentation: Just<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {\n        ObjectHelper.requireNonNull(item1, \"The first item is null\");\n        ObjectHelper.requireNonNull(item2, \"The second item is null\");\n        ObjectHelper.requireNonNull(item3, \"The third item is null\");\n        ObjectHelper.requireNonNull(item4, \"The fourth item is null\");\n        ObjectHelper.requireNonNull(item5, \"The fifth item is null\");\n        ObjectHelper.requireNonNull(item6, \"The sixth item is null\");\n        ObjectHelper.requireNonNull(item7, \"The seventh item is null\");\n        ObjectHelper.requireNonNull(item8, \"The eighth item is null\");\n        ObjectHelper.requireNonNull(item9, \"The ninth item is null\");\n        ObjectHelper.requireNonNull(item10, \"The tenth item is null\");\n\n        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {\n        return merge(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by\n     * those Publishers, without any transformation, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.oo.png\" alt=\"\">\n     * <p>\n     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the\n     *         {@code source} Publisher\n     * @throws IllegalArgumentException\n     *             if {@code maxConcurrency} is less than or equal to 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 1.1.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);\n    }\n\n    \/**\n     * Flattens an Array of Publishers into one Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.io.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers in the Array\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);\n    }\n\n    \/**\n     * Flattens four Publishers into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code merge} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> merge(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true);\n    }\n\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the array of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @param bufferSize\n     *            the number of items to prefetch from each inner Publisher\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed\n     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return mergeDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to\n     * receive all successfully emitted items from all of the source Publishers without being interrupted by\n     * an error notification from one of them, while limiting the\n     * number of concurrent subscriptions to these Publishers.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            a Publisher that emits Publishers\n     * @param maxConcurrency\n     *            the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the\n     *         {@code source} Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     * @since 2.0\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {\n        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);\n    }\n\n    \/**\n     * Flattens an array of Publishers into one Flowable, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an\n     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that\n     * error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param sources\n     *            the Iterable of Publishers\n     * @return a Flowable that emits items that are the result of flattening the items emitted by the\n     *         Publishers in the Iterable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources) {\n        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);\n    }\n\n    \/**\n     * Flattens two Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from each of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged Publishers\n     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from\n     * propagating that error notification until all of the merged Publishers have finished emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if both merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the two source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);\n    }\n\n    \/**\n     * Flattens three Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged\n     * Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain\n     * from propagating that error notification until all of the merged Publishers have finished emitting\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);\n    }\n\n\n    \/**\n     * Flattens four Publishers into one Publisher, in a way that allows a Subscriber to receive all\n     * successfully emitted items from all of the source Publishers without being interrupted by an error\n     * notification from one of them.\n     * <p>\n     * This behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any of\n     * the merged Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}\n     * will refrain from propagating that error notification until all of the merged Publishers have finished\n     * emitting items.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeDelayError.png\" alt=\"\">\n     * <p>\n     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only\n     * invoke the {@code onError} method of its Subscribers once.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element base type\n     * @param source1\n     *            a Publisher to be merged\n     * @param source2\n     *            a Publisher to be merged\n     * @param source3\n     *            a Publisher to be merged\n     * @param source4\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items that are emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> mergeDelayError(\n            Publisher<? extends T> source1, Publisher<? extends T> source2,\n            Publisher<? extends T> source3, Publisher<? extends T> source4) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);\n    }\n\n    \/**\n     * Returns a Flowable that never sends any items or notifications to a {@link Subscriber}.\n     * <p>\n     * <img width=\"640\" height=\"185\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/never.png\" alt=\"\">\n     * <p>\n     * This Publisher is useful primarily for testing purposes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This source doesn't produce any elements and effectively ignores downstream backpressure.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code never} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T>\n     *            the type of items (not) emitted by the Publisher\n     * @return a Flowable that never emits any items or sends any notifications to a {@link Subscriber}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/empty-never-throw.html\">ReactiveX operators documentation: Never<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Flowable<T> never() {\n        return RxJavaFlowablePlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Integers within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code range} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Integer in the sequence\n     * @param count\n     *            the number of sequential Integers to generate\n     * @return a Flowable that emits a range of sequential Integers\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Integer.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Integer> range(int start, int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return empty();\n        } else\n        if (count == 1) {\n            return just(start);\n        } else\n        if ((long)start + (count - 1) > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Integer overflow\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRange(start, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits a sequence of Longs within a specified range.\n     * <p>\n     * <img width=\"640\" height=\"195\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/range.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param start\n     *            the value of the first Long in the sequence\n     * @param count\n     *            the number of sequential Longs to generate\n     * @return a Flowable that emits a range of sequential Longs\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n     *             {@code Long.MAX_VALUE}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/range.html\">ReactiveX operators documentation: Range<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static Flowable<Long> rangeLong(long start, long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0) {\n            return empty();\n        }\n\n        if (count == 1) {\n            return just(start);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRangeLong(start, count));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Flowable that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual) {\n        return sequenceEqual(source1, source2, isEqual, bufferSize());\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified\n     * equality function.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param isEqual\n     *            a function used to compare items emitted by each Publisher\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences\n     *         are the same according to the specified function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,\n            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(isEqual, \"isEqual is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSequenceEqual<T>(source1, source2, isEqual, bufferSize));\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the\n     * same by comparing the items emitted by each Publisher pairwise.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sequenceEqual.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors downstream backpressure and expects both of its sources\n     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param source1\n     *            the first Publisher to compare\n     * @param source2\n     *            the second Publisher to compare\n     * @param bufferSize\n     *            the number of items to prefetch from the first and second source Publisher\n     * @param <T>\n     *            the type of items emitted by each Publisher\n     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sequenceequal.html\">ReactiveX operators documentation: SequenceEqual<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {\n        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param bufferSize\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.\n     * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     *\/\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {\n        return fromPublisher(sources).switchMap((Function)Functions.identity());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources) {\n        return switchOnNextDelayError(sources, bufferSize());\n    }\n\n    \/**\n     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the\n     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchDo.png\" alt=\"\">\n     * <p>\n     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of\n     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items\n     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items\n     * from the earlier-emitted Publisher and begins emitting items from the new one.\n     * <p>\n     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.\n     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the item type\n     * @param sources\n     *            the source Publisher that emits Publishers\n     * @param prefetch\n     *            the number of items to prefetch from the inner Publishers\n     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/switch.html\">ReactiveX operators documentation: Switch<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single {@code 0L}\n     * @param unit\n     *            time units to use for {@code delay}\n     * @return a Flowable that emits {@code 0L} after a specified delay, and then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public static Flowable<Long> timer(long delay, TimeUnit unit) {\n        return timer(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     * completes.\n     * <p>\n     * <img width=\"640\" height=\"200\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timer.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate\n     *      it should slow the timer or use something like {@link #onBackpressureDrop}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the initial delay before emitting a single 0L\n     * @param unit\n     *            time units to use for {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for scheduling the item\n     * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then\n     *         completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timer.html\">ReactiveX operators documentation: Timer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));\n    }\n\n    \/**\n     * Create a Flowable by wrapping a Publisher <em>which has to be implemented according\n     * to the Reactive-Streams specification by handling backpressure and\n     * cancellation correctly; no safeguards are provided by the Flowable itself<\/em>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure and the behavior is determined by the\n     *  provided Publisher implementation.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <T> the value type emitted\n     * @param onSubscribe the Publisher instance to wrap\n     * @return the new Flowable instance\n     * @throws IllegalArgumentException if {@code onSubscribe} is a subclass of {@code Flowable}; such\n     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}\n     * instead.\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        if (onSubscribe instanceof Flowable) {\n            throw new IllegalArgumentException(\"unsafeCreate(Flowable) should be upgraded\");\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of on cancellation.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {\n        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);\n    }\n\n    \/**\n     * Constructs a Publisher that creates a dependent resource object which is disposed of just before\n     * termination if you have set {@code disposeEagerly} to {@code true} and cancellation does not occur\n     * before termination. Otherwise resource disposal will occur on cancellation.  Eager disposal is\n     * particularly appropriate for a synchronous Publisher that reuses resources. {@code disposeAction} will\n     * only be called once per subscription.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/using.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure and otherwise depends on the\n     *  backpressure support of the Publisher returned by the {@code resourceFactory}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the element type of the generated Publisher\n     * @param <D> the type of the resource associated with the output sequence\n     * @param resourceSupplier\n     *            the factory function to create a resource object that depends on the Publisher\n     * @param sourceSupplier\n     *            the factory function to create a Publisher\n     * @param resourceDisposer\n     *            the function that will dispose of the resource\n     * @param eager\n     *            if {@code true} then disposal will happen either on cancellation or just before emission of\n     *            a terminal event ({@code onComplete} or {@code onError}).\n     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/using.html\">ReactiveX operators documentation: Using<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,\n            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier,\n                    Consumer<? super D> resourceDisposer, boolean eager) {\n        ObjectHelper.requireNonNull(resourceSupplier, \"resourceSupplier is null\");\n        ObjectHelper.requireNonNull(sourceSupplier, \"sourceSupplier is null\");\n        ObjectHelper.requireNonNull(resourceDisposer, \"disposer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common value type\n     * @param <R> the zipped result type\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * <i>n<\/i> items emitted, in sequence, by the <i>n<\/i> Publishers emitted by a specified Publisher.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the Publishers emitted\n     * by the source Publisher; the second item emitted by the new Publisher will be the result of the\n     * function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancel the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(just(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the value type of the inner Publishers\n     * @param <R> the zipped result type\n     * @param sources\n     *            a Publisher of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the Publishers emitted by\n     *            {@code ws}, results in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\", \"cast\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,\n            final Function<? super Object[], ? extends R> zipper) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return fromPublisher(sources).toList().flatMap((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);\n    }\n\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * two items emitted, in sequence, by two other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1} and the first item\n     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function\n     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results\n     *            in an item that will be emitted by the resulting Publisher\n     * @param delayError delay errors from any of the source Publishers till the other terminates\n     * @param bufferSize the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2,\n            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * three items emitted, in sequence, by three other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new\n     * Publisher will be the result of the function applied to the second item emitted by {@code o1}, the\n     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * four items emitted, in sequence, by four other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4,\n            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * five items emitted, in sequence, by five other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by {@code o1}, the first item\n     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and\n     * the first item emitted by {@code o5}; the second item emitted by the new Publisher will be the result of\n     * the function applied to the second item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5,\n            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * six items emitted, in sequence, by six other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * seven items emitted, in sequence, by seven other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7,\n            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * eight items emitted, in sequence, by eight other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8,\n            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * nine items emitted, in sequence, by nine other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each source Publisher, the\n     * second item emitted by the new Publisher will be the result of the function applied to the second item\n     * emitted by each of those Publishers, and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}\n     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest\n     * items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the value type of the first source\n     * @param <T2> the value type of the second source\n     * @param <T3> the value type of the third source\n     * @param <T4> the value type of the fourth source\n     * @param <T5> the value type of the fifth source\n     * @param <T6> the value type of the sixth source\n     * @param <T7> the value type of the seventh source\n     * @param <T8> the value type of the eighth source\n     * @param <T9> the value type of the ninth source\n     * @param <R> the zipped result type\n     * @param source1\n     *            the first source Publisher\n     * @param source2\n     *            a second source Publisher\n     * @param source3\n     *            a third source Publisher\n     * @param source4\n     *            a fourth source Publisher\n     * @param source5\n     *            a fifth source Publisher\n     * @param source6\n     *            a sixth source Publisher\n     * @param source7\n     *            a seventh source Publisher\n     * @param source8\n     *            an eighth source Publisher\n     * @param source9\n     *            a ninth source Publisher\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(\n            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,\n            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,\n            Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,\n            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {\n\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        ObjectHelper.requireNonNull(source5, \"source5 is null\");\n        ObjectHelper.requireNonNull(source6, \"source6 is null\");\n        ObjectHelper.requireNonNull(source7, \"source7 is null\");\n        ObjectHelper.requireNonNull(source8, \"source8 is null\");\n        ObjectHelper.requireNonNull(source9, \"source9 is null\");\n        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an array of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;\n     * a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T> the common element type\n     * @param <R> the result type\n     * @param sources\n     *            an array of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper,\n            boolean delayError, int bufferSize, Publisher<? extends T>... sources) {\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of\n     * items emitted, in sequence, by an Iterable of other Publishers.\n     * <p>\n     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher\n     * will be the result of the function applied to the first item emitted by each of the source Publishers;\n     * the second item emitted by the new Publisher will be the result of the function applied to the second\n     * item emitted by each of those Publishers; and so forth.\n     * <p>\n     * The resulting {@code Publisher<R>} returned from {@code zip} will invoke {@code onNext} as many times as\n     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     *\n     * @param sources\n     *            an Iterable of source Publishers\n     * @param zipper\n     *            a function that, when applied to an item emitted by each of the source Publishers, results in\n     *            an item that will be emitted by the resulting Publisher\n     * @param delayError\n     *            delay errors signalled by any of the source Publisher until all Publishers terminate\n     * @param bufferSize\n     *            the number of elements to prefetch from each source Publisher\n     * @param <T> the common source value type\n     * @param <R> the zipped result type\n     * @return a Flowable that emits the zipped results\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Flowable<R> zipIterable(Iterable<? extends Publisher<? extends T>> sources,\n            Function<? super Object[], ? extends R> zipper, boolean delayError,\n            int bufferSize) {\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError));\n    }\n\n    \/\/ ***************************************************************************************************\n    \/\/ Instance operators\n    \/\/ ***************************************************************************************************\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source\n     * Publisher satisfy a condition.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/all.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code all} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item and returns a Boolean\n     * @return a Single that emits {@code true} if all items emitted by the source Publisher satisfy the\n     *         predicate; otherwise, {@code false}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/all.html\">ReactiveX operators documentation: All<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> all(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAll<T>(this, predicate));\n    }\n\n    \/**\n     * Mirrors the Publisher (current or provided) that first either emits an item or sends a termination\n     * notification.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/amb.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with backpressure which is determined by the winning\n     *  {@code Publisher}'s backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ambWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher competing to react first. A subscription to this provided Publisher will occur after subscribing\n     *            to the current Publisher.\n     * @return a Flowable that emits the same sequence as whichever of the source Publishers first\n     *         emitted an item or sent a termination notification\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/amb.html\">ReactiveX operators documentation: Amb<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ambWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return ambArray(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a\n     * specified condition, otherwise {@code false}. <em>Note:<\/em> this always emits {@code false} if the\n     * source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/exists.png\" alt=\"\">\n     * <p>\n     * In Rx.Net this is the {@code any} Subscriber but we renamed it in RxJava to better match Java naming\n     * idioms.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code any} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the condition to test items emitted by the source Publisher\n     * @return a Single that emits a Boolean that indicates whether any item emitted by the source\n     *         Publisher satisfies the {@code predicate}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> any(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableAny<T>(this, predicate));\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if it emits no items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the first item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst() {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the first item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the first item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingFirst(T defaultItem) {\n        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Invokes a method on each item emitted by this {@code Flowable} and blocks until the Flowable\n     * completes.\n     * <p>\n     * <em>Note:<\/em> This will block even if the underlying Flowable is asynchronous.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.forEach.png\" alt=\"\">\n     * <p>\n     * This is similar to {@link Flowable#subscribe(Subscriber)}, but it blocks. Because it blocks it does not\n     * need the {@link Subscriber#onComplete()} or {@link Subscriber#onError(Throwable)} methods. If the\n     * underlying Flowable terminates with an error, rather than calling {@code onError}, this method will\n     * throw an exception.\n     *\n     * <p>The difference between this method and {@link #subscribe(Consumer)} is that the {@code onNext} action\n     * is executed on the emission thread instead of the current thread.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the {@link Consumer} to invoke for each item emitted by the {@code Flowable}\n     * @throws RuntimeException\n     *             if an error occurs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX documentation: Subscribe<\/a>\n     * @see #subscribe(Consumer)\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingForEach(Consumer<? super T> onNext) {\n        Iterator<T> it = blockingIterable().iterator();\n        while (it.hasNext()) {\n            try {\n                onNext.accept(it.next());\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                ((Disposable)it).dispose();\n                throw ExceptionHelper.wrapOrThrow(e);\n            }\n        }\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable() {\n        return blockingIterable(bufferSize());\n    }\n\n    \/**\n     * Converts this {@code Flowable} into an {@link Iterable}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toIterable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the upstream to honor backpressure otherwise the returned\n     *  Iterable's iterator will throw a {@code MissingBackpressureException}.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize the number of items to prefetch from the current Flowable\n     * @return an {@link Iterable} version of this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingIterable(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return new BlockingFlowableIterable<T>(this, bufferSize);\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or throws\n     * {@code NoSuchElementException} if this {@code Flowable} emits no items.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the last item emitted by this {@code Flowable}\n     * @throws NoSuchElementException\n     *             if this {@code Flowable} emits no items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast() {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        if (v != null) {\n            return v;\n        }\n        throw new NoSuchElementException();\n    }\n\n    \/**\n     * Returns the last item emitted by this {@code Flowable}, or a default value if it emits no\n     * items.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the last item emitted by the {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingLast(T defaultItem) {\n        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();\n        subscribe(s);\n        T v = s.blockingGet();\n        return v != null ? v : defaultItem;\n    }\n\n    \/**\n     * Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},\n     * waiting if necessary for one to become available.\n     * <p>\n     * If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,\n     * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.\n     * <p>\n     * Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}\n     * event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an Iterable that always returns the latest item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingLatest() {\n        return new BlockingFlowableLatest<T>(this);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that always returns the item most recently emitted by this\n     * {@code Flowable}.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.mostRecent.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param initialItem\n     *            the initial item that the {@link Iterable} sequence will yield if this\n     *            {@code Flowable} has not yet emitted an item\n     * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}\n     *         has most recently emitted\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingMostRecent(T initialItem) {\n        return new BlockingFlowableMostRecent<T>(this, initialItem);\n    }\n\n    \/**\n     * Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, then\n     * returns that item.\n     * <p>\n     * <img width=\"640\" height=\"490\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.next.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return an {@link Iterable} that blocks upon each iteration until this {@code Flowable} emits\n     *         a new item, whereupon the Iterable returns that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Iterable<T> blockingNext() {\n        return new BlockingFlowableNext<T>(this);\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item, otherwise\n     * throw a {@code NoSuchElementException}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the single item emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle() {\n        return singleOrError().blockingLast();\n    }\n\n    \/**\n     * If this {@code Flowable} completes after emitting a single item, return that item; if it emits\n     * more than one item, throw an {@code IllegalArgumentException}; if it emits no items, return a default\n     * value.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to return if this {@code Flowable} emits no items\n     * @return the single item emitted by this {@code Flowable}, or the default value if it emits no\n     *         items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final T blockingSingle(T defaultItem) {\n        return single(defaultItem).blockingLast();\n    }\n\n    \/**\n     * Returns a {@link Future} representing the single value emitted by this {@code Flowable}.\n     * <p>\n     * If the {@link Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an\n     * {@link java.lang.IllegalArgumentException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}\n     * will receive an {@link java.util.NoSuchElementException}.\n     * <p>\n     * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toBlocking().toFuture()}.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/images\/rx-operators\/B.toFuture.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Future} that expects a single item to be emitted by this {@code Flowable}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Future<T> toFuture() {\n        return subscribeWith(new FutureSubscriber<T>());\n    }\n\n    \/**\n     * Runs the source observable to a terminal event, ignoring any values and rethrowing any exception.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe() {\n        FlowableBlockingSubscribe.subscribe(this);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n\n    \/**\n     * Subscribes to the source and calls the given callbacks <strong>on the current thread<\/strong>.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param onNext the callback action for each source value\n     * @param onError the callback action for an error event\n     * @param onComplete the callback action for the completion event.\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {\n        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);\n    }\n\n    \/**\n     * Subscribes to the source and calls the Subscriber methods <strong>on the current thread<\/strong>.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The supplied {@code Subscriber} determines how backpressure is applied.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * The cancellation and backpressure is composed through.\n     * @param subscriber the subscriber to forward events and calls to in the current thread\n     * @since 2.0\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void blockingSubscribe(Subscriber<? super T> subscriber) {\n        FlowableBlockingSubscribe.subscribe(this, subscriber);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count) {\n        return buffer(count, count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> buffer(int count, int skip) {\n        return buffer(count, skip, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum size of each buffer before it should be emitted\n     * @param skip\n     *            how many items emitted by the source Publisher should be skipped before starting a new\n     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as\n     *            {@link #buffer(int)}.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and\n     *         containing at most {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as\n     *  well, although not enforced; violation <em>may<\/em> lead to {@code MissingBackpressureException} somewhere\n     *  downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param count\n     *            the maximum number of items in each buffer before it should be emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most\n     *         {@code count} items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {\n        return buffer(count, count, bufferSupplier);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits\n     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {\n        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the\n     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted\n     * @param timeskip\n     *            the period of time after which a new buffer will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after\n     *         a fixed timespan has elapsed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,\n            Scheduler scheduler, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {\n        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current buffer and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) {\n        return buffer(timespan, unit, Schedulers.computation(), count);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {\n        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by\n     * the {@code count} argument (whichever is reached first). When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @param count\n     *            the maximum size of each buffer before it is emitted\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @param restartTimerOnMaxSize if true the time window is restarted when the max capacity of the current buffer\n     *            is reached\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs\n     *         first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <U extends Collection<? super T>> Flowable<U> buffer(\n            long timespan, TimeUnit unit,\n            Scheduler scheduler, int count,\n            Callable<U> bufferSupplier,\n            boolean restartTimerOnMaxSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the\n     * {@code timespan} argument and on the specified {@code scheduler}. When the source Publisher completes or\n     * encounters an error, the resulting Publisher emits the current buffer and propagates the notification\n     * from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}\n     *      upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each buffer collects items before it is emitted and replaced with a new\n     *            buffer\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a buffer\n     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source\n     *         Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {\n        return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.<T>asCallable(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing> Flowable<List<T>> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {\n        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an\n     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"470\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <TOpening> the element type of the buffer-opening Publisher\n     * @param <TClosing> the element type of the individual buffer-closing Publishers\n     * @param openingIndicator\n     *            the Publisher that, when it emits an item, causes a new buffer to be created\n     * @param closingIndicator\n     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this\n     *            Publisher emits an item, the associated buffer is emitted.\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created\n     *         and closed when the specified Publishers emit items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(\n            Flowable<? extends TOpening> openingIndicator,\n            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {\n        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param initialCapacity\n     *            the initial capacity of each buffer chunk\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     * @see #buffer(Publisher)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the\n     * specified boundary Publisher emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer8.png\" alt=\"\">\n     * <p>\n     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the\n     * latest buffer and complete.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}\n     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey\n     *      downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B>\n     *            the boundary value type (ignored)\n     * @param boundaryIndicator\n     *            the boundary Publisher\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher\n     *         emits an item\n     * @see #buffer(Publisher, int)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.<T>asCallable());\n\n    }\n\n    \/**\n     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a\n     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"395\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/buffer1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it is instead controlled by the given Publishers and\n     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the collection subclass type to buffer into\n     * @param <B> the value type of the boundary-providing Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.\n     *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and\n     *            begins to fill a new one\n     * @param bufferSupplier\n     *            a factory function that returns an instance of the collection subclass to be used and returned\n     *            as the buffer\n     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher\n     *         each time the Publisher created with the {@code closingIndicator} argument emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/buffer.html\">ReactiveX operators documentation: Buffer<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier,\n            Callable<U> bufferSupplier) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.requireNonNull(bufferSupplier, \"bufferSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundaryIndicatorSupplier, bufferSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cache() {\n        return cacheWithInitialCapacity(16);\n    }\n\n    \/**\n     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events\n     * and replays them, in the same order as received, to all the downstream subscribers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cache.png\" alt=\"\">\n     * <p>\n     * This is useful when you want a Publisher to cache responses and you can't control the\n     * subscribe\/cancel behavior of all the {@link Subscriber}s.\n     * <p>\n     * The operator subscribes only when the first downstream subscriber subscribes and maintains\n     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}\n     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.\n     * <p>\n     * <em>Note:<\/em> You sacrifice the ability to cancel the origin when you use the {@code cache}\n     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number\n     * of items that will use up memory.\n     * A possible workaround is to apply `takeUntil` with a predicate or\n     * another source before (and perhaps after) the application of cache().\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * Since the operator doesn't allow clearing the cached values either, the possible workaround is\n     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous\n     * workaround:\n     * <pre><code>\n     * AtomicBoolean shouldStop = new AtomicBoolean();\n     *\n     * source.takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .cache()\n     *       .takeUntil(v -&gt; shouldStop.get())\n     *       .onTerminateDetach()\n     *       .subscribe(...);\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes this Publisher in an unbounded fashion but respects the backpressure\n     *  of each downstream Subscriber individually.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * <p>\n     * <em>Note:<\/em> The capacity hint is not an upper bound on cache size. For that, consider\n     * {@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.\n     *\n     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)\n     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the\n     *         benefit of subsequent subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {\n        ObjectHelper.verifyPositive(initialCapacity, \"initialCapacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher, converted to the specified\n     * type.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/cast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code cast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output value type cast to\n     * @param clazz\n     *            the target class type that {@code cast} will cast the items emitted by the source Publisher\n     *            into before emitting them from the resulting Publisher\n     * @return a Flowable that emits each item from the source Publisher after converting it to the\n     *         specified type\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> cast(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return map(Functions.castFunction(clazz));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collect} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItemSupplier\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItemSupplier, \"initialItemSupplier is null\");\n        ObjectHelper.requireNonNull(collector, \"collector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCollect<T, U>(this, initialItemSupplier, collector));\n    }\n\n    \/**\n     * Collects items emitted by the source Publisher into a single mutable data structure and returns\n     * a Single that emits this structure.\n     * <p>\n     * <img width=\"640\" height=\"330\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/collect.png\" alt=\"\">\n     * <p>\n     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure because by intent it will receive all values and reduce\n     *      them to a single {@code onNext}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code collectInto} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the accumulator and output type\n     * @param initialItem\n     *           the mutable data structure that will collect the items\n     * @param collector\n     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}\n     *           accordingly\n     * @return a Single that emits the result of collecting the values emitted by the source Publisher\n     *         into a single mutable data structure\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> collectInto(final U initialItem, BiConsumer<? super U, ? super T> collector) {\n        ObjectHelper.requireNonNull(initialItem, \"initialItem is null\");\n        return collect(Functions.justCallable(initialItem), collector);\n    }\n\n    \/**\n     * Transform a Publisher by applying a particular Transformer function to it.\n     * <p>\n     * This method operates on the Publisher itself whereas {@link #lift} operates on the Publisher's\n     * Subscribers or Subscribers.\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@link #lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator itself doesn't interfere with the backpressure behavior which only depends\n     *  on what kind of {@code Publisher} the transformer returns.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code compose} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the output Publisher\n     * @param composer implements the function that transforms the source Publisher\n     * @return the source Publisher, transformed by the transformer function\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {\n        return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, \"composer is null\")).apply(this));\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMap(mapper, 2);\n    }\n\n    \/**\n     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item\n     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items\n     * that result from concatenating those resulting Publishers.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the type of the inner Publisher sources and thus the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and concatenating the Publishers obtained from this transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }\n\n    \/**\n     * Maps each of the items into a Publisher, subscribes to them one after the other,\n     * one at a time and emits their values in order\n     * while delaying any error from either this or any of the inner Publishers\n     * till all of them terminate.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\n     *  backpressure, that <em>may<\/em> throw an {@code IllegalStateException} when that\n     *  {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param mapper the function that maps the items of this Publisher into the inner Publishers.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the concatenation behavior\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapEager(mapper, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param tillTheEnd\n     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,\n     *            if false, an error from the main source is signalled when the current Publisher source terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean tillTheEnd) {\n        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);\n    }\n\n    \/**\n     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single\n     * Publisher.\n     * <p>\n     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the\n     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in\n     * order, each one after the previous one completes.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources\n     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the value type\n     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be\n     *               eagerly concatenated\n     * @param maxConcurrency the maximum number of concurrent subscribed Publishers\n     * @param prefetch\n     *               the number of elements to prefetch from each source Publisher\n     * @param tillTheEnd\n     *               if true, exceptions from the current Flowable and all the inner Publishers are delayed until\n     *               all of them terminate, if false, exception from the current Flowable is delayed until the\n     *               currently running Publisher terminates\n     * @return the new Publisher instance with the specified concatenation behavior\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            int maxConcurrency, int prefetch, boolean tillTheEnd) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }\n\n    \/**\n     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, prefetch));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted from the current Publisher, then the next, one after\n     * the other, without interleaving them.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/concat.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be concatenated after the current\n     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,\n     *         without interleaving them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/concat.html\">ReactiveX operators documentation: Concat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> concatWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concat(this, other);\n    }\n\n    \/**\n     * Returns a Single that emits a Boolean that indicates whether the source Publisher emitted a\n     * specified item.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/contains.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code contains} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the item to search for in the emissions from the source Publisher\n     * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,\n     *         or {@code false} if the source Publisher completes without emitting that item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> contains(final Object item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return any(Functions.equalsWith(item));\n    }\n\n    \/**\n     * Returns a Single that counts the total number of items emitted by the source Publisher and emits\n     * this count as a 64-bit Long.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/longCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code count} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a\n     *         64-bit Long item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/count.html\">ReactiveX operators documentation: Count<\/a>\n     * @see #count()\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Long> count() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableCount<T>(this));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by another item within a computed debounce duration.\n     * <p>\n     * <img width=\"640\" height=\"425\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the {@code debounceSelector} to mark\n     *      boundaries.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the debounce value type (ignored)\n     * @param debounceIndicator\n     *            function to retrieve a sequence that indicates the throttle duration for each item\n     * @return a Flowable that omits items emitted by the source Publisher that are followed by another item\n     *         within a computed debounce duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {\n        ObjectHelper.requireNonNull(debounceIndicator, \"debounceIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on\n     * each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code debounce} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the {@link TimeUnit} for the timeout\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\n     * source Publisher that are followed by newer items before a timeout value expires on a specified\n     * Scheduler. The timer resets on each emission.\n     * <p>\n     * <em>Note:<\/em> If items keep being emitted by the source Publisher faster than the timeout then no items\n     * will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/debounce.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the time each item has to be \"the most recent\" of those emitted by the source Publisher to\n     *            ensure that it's not dropped\n     * @param unit\n     *            the unit of time for the specified timeout\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by\n     *         newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or a specified default item\n     * if the source Publisher is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/defaultIfEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, this operator is guaranteed to honor backpressure from downstream.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as well; if the rule is violated,\n     *  a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the item to emit if the source Publisher emits no items\n     * @return a Flowable that emits either the specified default item if the source Publisher emits no\n     *         items, or the items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/defaultifempty.html\">ReactiveX operators documentation: DefaultIfEmpty<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> defaultIfEmpty(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"item is null\");\n        return switchIfEmpty(just(defaultItem));\n    }\n\n    \/**\n     * Returns a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     * per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.o.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the function are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the item delay value type (ignored)\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the emissions of the source Publisher via another Publisher on a\n     *         per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelayIndicator) {\n        ObjectHelper.requireNonNull(itemDelayIndicator, \"itemDelayIndicator is null\");\n        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit) {\n        return delay(delay, unit, Schedulers.computation(), false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {\n        return delay(delay, unit, Schedulers.computation(), delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delay(delay, unit, scheduler, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a\n     * specified delay. Error notifications from the source Publisher are not delayed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the delay to shift the source by\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the {@link Scheduler} to use for delaying\n     * @param delayError\n     *            if true, the upstream exception is signalled with the given delay, after all preceding normal elements,\n     *            if false, the upstream exception is signalled immediately\n     * @return the source Publisher shifted in time by the specified delay\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelay<T>(this, Math.max(0L, delay), unit, scheduler, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to and emissions from the source Publisher via another\n     * Publisher on a per-item basis.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delay.oo.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> the resulting Publisher will immediately propagate any {@code onError} notification\n     * from the source Publisher.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.\n     *  All of the other {@code Publisher}s supplied by the functions are consumed\n     *  in an unbounded manner (i.e., no backpressure applied to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the subscription delay value type (ignored)\n     * @param <V>\n     *            the item delay value type (ignored)\n     * @param subscriptionIndicator\n     *            a function that returns a Publisher that triggers the subscription to the source Publisher\n     *            once it emits any item\n     * @param itemDelayIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher, which is\n     *            then used to delay the emission of that item by the resulting Publisher until the Publisher\n     *            returned from {@code itemDelay} emits an item\n     * @return a Flowable that delays the subscription and emissions of the source Publisher via another\n     *         Publisher on a per-item basis\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,\n            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {\n        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to this Publisher\n     * until the other Publisher emits an element or completes normally.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator forwards the backpressure requests to this Publisher once\n     *  the subscription happens and requests Long.MAX_VALUE from the other Publisher<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This method does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the value type of the other Publisher, irrelevant\n     * @param subscriptionIndicator the other Publisher that should trigger the subscription\n     *        to this Publisher.\n     * @return a Flowable that delays the subscription to this Publisher\n     *         until the other Publisher emits an element or completes normally.\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> delaySubscription(Publisher<U> subscriptionIndicator) {\n        ObjectHelper.requireNonNull(subscriptionIndicator, \"subscriptionIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, subscriptionIndicator));\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @return a Flowable that delays the subscription to the source Publisher by the given amount\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit) {\n        return delaySubscription(delay, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time,\n     * both waiting and subscribing on a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/delaySubscription.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param delay\n     *            the time to delay the subscription\n     * @param unit\n     *            the time unit of {@code delay}\n     * @param scheduler\n     *            the Scheduler on which the waiting and subscription will happen\n     * @return a Flowable that delays the subscription to the source Publisher by a given\n     *         amount, waiting and subscribing on the given Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/delay.html\">ReactiveX operators documentation: Delay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {\n        return delaySubscription(timer(delay, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the\n     * {@link Notification} objects emitted by the source Publisher into the items or notifications they\n     * represent.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/dematerialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code dematerialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T2> the output value type\n     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Dematerialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T2> Flowable<T2> dematerialize() {\n        @SuppressWarnings(\"unchecked\")\n        Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDematerialize<T2>(m));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits only those items emitted by the source Publisher that are distinct from\n     *         each other\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinct() {\n        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {\n        return distinct(keySelector, Functions.<K>createHashSet());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according\n     * to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinct.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @param collectionSupplier\n     *            function called for each individual Subscriber to return a Collection subtype for holding the extracted\n     *            keys and whose add() method's return indicates uniqueness.\n     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,\n            Callable<? extends Collection<? super K>> collectionSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged() {\n        return distinctUntilChanged(Functions.identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors, according to a key selector function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.key.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type\n     * @param keySelector\n     *            a function that projects an emitted item to a key value that is used to decide whether an item\n     *            is distinct from another one or not\n     * @return a Flowable that emits those items from the source Publisher whose keys are distinct from\n     *         those of their immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));\n    }\n\n    \/**\n     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their\n     * immediate predecessors when compared with each other via the provided comparator function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/distinctUntilChanged.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparer the function that receives the previous item and the current item and is\n     *                   expected to return true if the two are equal, thus skipping the current value.\n     * @return a Flowable that emits those items from the source Publisher that are distinct from their\n     *         immediate predecessors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/distinct.html\">ReactiveX operators documentation: Distinct<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {\n        ObjectHelper.requireNonNull(comparer, \"comparer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));\n    }\n\n    \/**\n     * Calls the specified action after this Flowable signals onError or onCompleted or gets cancelled by\n     * the downstream.\n     * <p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action\n     * is executed once per subscription.\n     * <p>Note that the {@code onFinally} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onFinally the action called when this Flowable terminates or gets cancelled\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doFinally(Action onFinally) {\n        ObjectHelper.requireNonNull(onFinally, \"onFinally is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));\n    }\n\n    \/**\n     * Calls the specified consumer with the current item after this item has been emitted to the downstream.\n     * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such\n     * should be thread-safe.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     *  <td><b>Operator-fusion:<\/b><\/dt>\n     *  <dd>This operator supports normal and conditional Subscribers as well as boundary-limited\n     *  synchronous or asynchronous queue-fusion.<\/dd>\n     * <\/dl>\n     * @param onAfterNext the Consumer that will be called after emitting an item from upstream to the downstream\n     * @return the new Flowable instance\n     * @since 2.0.1 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {\n        ObjectHelper.requireNonNull(onAfterNext, \"onAfterNext is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));\n    }\n\n    \/**\n     * Registers an {@link Action} to be called when this Publisher invokes either\n     * {@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/finallyDo.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onAfterTerminate\n     *            an {@link Action} to be invoked when the source Publisher finishes\n     * @return a Flowable that emits the same items as the source Publisher, then invokes the\n     *         {@link Action}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doOnTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, onAfterTerminate);\n    }\n\n    \/**\n     * Calls the cancel {@code Action} if the downstream cancels the sequence.\n     * <p>\n     * The action is shared between subscriptions and thus may be called concurrently from multiple\n     * threads; the action must be thread safe.\n     * <p>\n     * If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,\n     * sometimes as a {@code CompositeException} if there were multiple exceptions along the way.\n     * <p>\n     * Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnUnsubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure\n     *  behavior is preserved between its upstream and its downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onCancel\n     *            the action that gets called when the source {@code Publisher}'s Subscription is cancelled\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnCancel(Action onCancel) {\n        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnComplete.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onComplete\n     *            the action to invoke when the source Publisher calls {@code onComplete}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnComplete(Action onComplete) {\n        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),\n                onComplete, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same type\n     * passes through, before forwarding them to downstream.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Action onAfterTerminate) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action for each item it emits.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNotification\n     *            the action to invoke for each item emitted by the source Publisher\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {\n        ObjectHelper.requireNonNull(onNotification, \"consumer is null\");\n        return doOnEach(\n                Functions.notificationOnNext(onNotification),\n                Functions.notificationOnError(onNotification),\n                Functions.notificationOnComplete(onNotification),\n                Functions.EMPTY_ACTION\n            );\n    }\n\n    \/**\n     * Modifies the source Publisher so that it notifies a Subscriber for each item and terminal event it emits.\n     * <p>\n     * In case the {@code onError} of the supplied Subscriber throws, the downstream will receive a composite\n     * exception containing the original exception and the exception thrown by {@code onError}. If either the\n     * {@code onNext} or the {@code onComplete} method of the supplied Subscriber throws, the downstream will be\n     * terminated and will receive this thrown exception.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnEach.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param subscriber\n     *            the Subscriber to be notified about onNext, onError and onComplete events on its\n     *            respective methods before the actual downstream Subscriber gets notified.\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {\n        ObjectHelper.requireNonNull(subscriber, \"subscriber is null\");\n        return doOnEach(\n                FlowableInternalHelper.subscriberOnNext(subscriber),\n                FlowableInternalHelper.subscriberOnError(subscriber),\n                FlowableInternalHelper.subscriberOnComplete(subscriber),\n                Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action if it calls {@code onError}.\n     * <p>\n     * In case the {@code onError} action throws, the downstream will receive a composite exception containing\n     * the original exception and the exception thrown by {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onError\n     *            the action to invoke if the source Publisher calls {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {\n        return doOnEach(Functions.emptyConsumer(), onError,\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of\n     * the sequence (subscription, cancellation, requesting).\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *              a Consumer called with the Subscription sent via Subscriber.onSubscribe()\n     * @param onRequest\n     *              a LongConsumer called with the request amount sent via Subscription.request()\n     * @param onCancel\n     *              called when the downstream cancels the Subscription via cancel()\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,\n            final LongConsumer onRequest, final Action onCancel) {\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n        ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");\n        ObjectHelper.requireNonNull(onCancel, \"onCancel is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel));\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onNext}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnNext.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            the action to invoke when the source Publisher calls {@code onNext}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {\n        return doOnEach(onNext, Functions.emptyConsumer(),\n                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it receives a\n     * request for more items.\n     * <p>\n     * <b>Note:<\/b> This operator is for tracing the internal behavior of back-pressure request\n     * patterns and generally intended for debugging use.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     * <dt><b>Scheduler:<\/b><\/dt>\n     * <dd>{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onRequest\n     *            the action that gets called when a Subscriber requests items from this\n     *            {@code Publisher}\n     * @return the source {@code Publisher} modified so as to call this Action when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators\n     *      documentation: Do<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnRequest(LongConsumer onRequest) {\n        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from\n     * its subscribers. Each subscription will result in an invocation of the given action except when the\n     * source {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke\n     * the given action for the first subscription.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnSubscribe.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onSubscribe\n     *            the Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}\n     * @return the source {@code Publisher} modified so as to call this Consumer when appropriate\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {\n        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete} or\n     * {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/doOnTerminate.png\" alt=\"\">\n     * <p>\n     * This differs from {@code doAfterTerminate} in that this happens <em>before<\/em> the {@code onComplete} or\n     * {@code onError} notification.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onTerminate\n     *            the action to invoke when the source Publisher calls {@code onComplete} or {@code onError}\n     * @return the source Publisher with the side-effecting behavior applied\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/do.html\">ReactiveX operators documentation: Do<\/a>\n     * @see #doAfterTerminate(Action)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnTerminate(final Action onTerminate) {\n        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),\n                onTerminate, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from\n     * this Flowable or completes if this Flowable sequence has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Maybe that emits a single item: the item at the specified position in the sequence of\n     *         those emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable, or a default item if that index is out of range.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @param defaultItem\n     *            the default item\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAt(long index, T defaultItem) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from\n     * this Flowable or signals a {@link NoSuchElementException} if this Flowable has fewer elements than index.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/elementAtOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n     *  (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param index\n     *            the zero-based index of the item to retrieve\n     * @return a Flowable that emits the item at the specified position in the sequence emitted by the source\n     *         Publisher, or the default item if that index is outside the bounds of the source sequence\n     * @throws IndexOutOfBoundsException\n     *             if {@code index} is less than 0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/elementat.html\">ReactiveX operators documentation: ElementAt<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> elementAtOrError(long index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"index >= 0 required but it was \" + index);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableElementAt<T>(this, index, null, true));\n    }\n\n    \/**\n     * Filters items emitted by a Publisher by only emitting those that satisfy a specified predicate.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/filter.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code filter} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates each item emitted by the source Publisher, returning {@code true}\n     *            if it passes the filter\n     * @return a Flowable that emits only those items emitted by the source Publisher that the filter\n     *         evaluates as {@code true}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFilter<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Maybe that emits only the very first item emitted by this Flowable or\n     * completes if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstElement.m.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstElement() {\n        return elementAt(0);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable, or a default\n     * item if this Flowable completes without emitting anything.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/first.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code first} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher doesn't emit anything\n     * @return a Single that emits only the very first item from the source, or a default item if the\n     *         source Publisher completes without emitting any items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> first(T defaultItem) {\n        return elementAt(0, defaultItem);\n    }\n\n    \/**\n     * Returns a Single that emits only the very first item emitted by this Flowable or\n     * signals a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"237\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/firstOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code firstOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ take may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> firstOrError() {\n        return elementAtOrError(0);\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return flatMap(mapper, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {\n        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {\n        return flatMap(mapper, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted\n     * by the source Publisher, where that function returns a Publisher, and then merging those resulting\n     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMap.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the value type of the inner Publishers and the output type\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from each inner Publisher\n     * @return a Flowable that emits the result of applying the transformation function to each item emitted\n     *         by the source Publisher and merging the results of the Publishers obtained from this\n     *         transformation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,\n            boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));\n    }\n\n    \/**\n     * Returns a Flowable that applies a function to each item emitted or notification raised by the source\n     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items,\n     * while limiting the maximum number of concurrent subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.nce.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the result type\n     * @param onNextMapper\n     *            a function that returns a Publisher to merge for each item emitted by the source Publisher\n     * @param onErrorMapper\n     *            a function that returns a Publisher to merge for an onError notification from the source\n     *            Publisher\n     * @param onCompleteSupplier\n     *            a function that returns a Publisher to merge for an onComplete notification from the source\n     *            Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of merging the Publishers returned from applying the\n     *         specified functions to the emissions and notifications of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> flatMap(\n            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,\n            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper,\n            Callable<? extends Publisher<? extends R>> onCompleteSupplier,\n            int maxConcurrency) {\n        ObjectHelper.requireNonNull(onNextMapper, \"onNextMapper is null\");\n        ObjectHelper.requireNonNull(onErrorMapper, \"onErrorMapper is null\");\n        ObjectHelper.requireNonNull(onCompleteSupplier, \"onCompleteSupplier is null\");\n        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(\n                this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        return flatMap(mapper, combiner, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher.\n     * <p>\n     * <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\">\n     * <dl>\n     * <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner functions\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors) {\n        return flatMap(mapper, combiner, delayErrors, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency) {\n        return flatMap(mapper, combiner, delayErrors, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @param delayErrors\n     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n     *            if false, the first one signalling an exception will terminate the whole sequence immediately\n     * @param bufferSize\n     *            the number of elements to prefetch from the inner Publishers.\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the\n     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <!-- <img width=\"640\" height=\"390\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/mergeMap.r.png\" alt=\"\"> -->\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed\n     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).\n     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,\n     *  the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the inner Publishers\n     * @param <R>\n     *            the type of items emitted by the combiner function\n     * @param mapper\n     *            a function that returns a Publisher for each item emitted by the source Publisher\n     * @param combiner\n     *            a function that combines one item emitted by each of the source and collection Publishers and\n     *            returns an item to be emitted by the resulting Publisher\n     * @param maxConcurrency\n     *         the maximum number of Publishers that may be subscribed to concurrently\n     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n     *         source Publisher and the collection Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper,\n            BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {\n        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return flatMapIterable(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableFlattenIterable<T, U>(this, mapper, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of applying a function to the pair of values from the source\n     * Publisher and an Iterable corresponding to that item that is generated by a selector.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and the source {@code Publisher}s is\n     *  consumed in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the collection element type\n     * @param <V>\n     *            the type of item emitted by the resulting Iterable\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for each item emitted by the source\n     *            Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @return a Flowable that emits the items returned by {@code resultSelector} for each item in the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an\n     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent\n     * subscriptions to these Publishers.\n     * <p>\n     * <img width=\"640\" height=\"410\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flatMapIterable.f.r.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\n     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\n     *  signal a {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the element type of the inner Iterable sequences\n     * @param <V>\n     *            the type of item emitted by the resulting Publisher\n     * @param mapper\n     *            a function that returns an Iterable sequence of values for when given an item emitted by the\n     *            source Publisher\n     * @param resultSelector\n     *            a function that returns an item based on the item emitted by the source Publisher and the\n     *            Iterable returned for that item by the {@code collectionSelector}\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,\n            final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element.\n     * <p>\n     * Alias to {@link #subscribe(Consumer)}\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Consumer} to execute for each item.\n     * @return\n     *            a Disposable that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEach(Consumer<? super T> onNext) {\n        return subscribe(onNext);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element until the\n     * onNext Predicate returns false.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext) {\n        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and error events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {\n        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);\n    }\n\n    \/**\n     * Subscribes to the {@link Publisher} and receives notifications for each element and the terminal events until the\n     * onNext Predicate returns false.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *            {@link Predicate} to execute for each item.\n     * @param onError\n     *            {@link Consumer} to execute when an error is emitted.\n     * @param onComplete\n     *            {@link Action} to execute when completion is signalled.\n     * @return\n     *            a {@link Disposable} that allows cancelling an asynchronous sequence\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.NONE)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,\n            final Action onComplete) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n\n        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);\n        subscribe(s);\n        return s;\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {\n        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param <K>\n     *            the key type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {\n        return groupBy(keySelector, Functions.<T>identity(), delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector) {\n        return groupBy(keySelector, valueSelector, false, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector, boolean delayError) {\n        return groupBy(keySelector, valueSelector, delayError, bufferSize());\n    }\n\n    \/**\n     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these\n     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single\n     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the\n     * source terminates, the next emission by the source having the same key will trigger a new\n     * {@code GroupedPublisher} emission.\n     * <p>\n     * <img width=\"640\" height=\"360\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupBy.png\" alt=\"\">\n     * <p>\n     * <em>Note:<\/em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it\n     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those\n     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may\n     * discard their buffers by applying an operator like {@link #ignoreElements} to them.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}\n     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on\n     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use\n     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may<\/em>\n     *  lead to {@code OutOfMemoryError}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param keySelector\n     *            a function that extracts the key for each item\n     * @param valueSelector\n     *            a function that extracts the return element for each item\n     * @param delayError\n     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted\n     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.\n     * @param bufferSize\n     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered\n     * @param <K>\n     *            the key type\n     * @param <V>\n     *            the element type\n     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a\n     *         unique key value and each of which emits those items from the source Publisher that share that\n     *         key value\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/groupby.html\">ReactiveX operators documentation: GroupBy<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that correlates two Publishers when they overlap in time and groups the results.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/groupJoin.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code groupJoin} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the other Publisher to correlate items from the source Publisher with\n     * @param leftEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the source Publisher\n     * @param rightEnd\n     *            a function that returns a Publisher whose emissions indicate the duration of the values of\n     *            the {@code right} Publisher\n     * @param resultSelector\n     *            a function that takes an item emitted by each Publisher and returns the value to be emitted\n     *            by the resulting Publisher\n     * @return a Flowable that emits items based on combining those items emitted by the source Publishers\n     *         whose durations overlap\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n    \/**\n     * Hides the identity of this Flowable and its Subscription.\n     * <p>Allows hiding extra features such as {@link Processor}'s\n     * {@link Subscriber} methods or preventing certain identity-based\n     * optimizations (fusion).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure, the behavior is determined by the upstream's\n     *  backpressure behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     *\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> hide() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableHide<T>(this));\n    }\n\n    \/**\n     * Ignores all items emitted by the source Publisher and only calls {@code onComplete} or {@code onError}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ignoreElements.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator ignores backpressure as it doesn't emit any elements and consumes the source {@code Publisher}\n     *  in an unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is\n     *         called by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/ignoreelements.html\">ReactiveX operators documentation: IgnoreElements<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> ignoreElements() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n    }\n\n    \/**\n     * Returns a Single that emits {@code true} if the source Publisher is empty, otherwise {@code false}.\n     * <p>\n     * In Rx.Net this is negated as the {@code any} Subscriber but we renamed this in RxJava to better match Java\n     * naming idioms.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/isEmpty.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code isEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits a Boolean\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/contains.html\">ReactiveX operators documentation: Contains<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Boolean> isEmpty() {\n        return all(Functions.alwaysFalse());\n    }\n\n    \/**\n     * Correlates the items emitted by two Publishers based on overlapping durations.\n     * <p>\n     * There are no guarantees in what order the items get combined when multiple\n     * items from one or both source Publishers overlap.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/join_.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s in\n     *  an unbounded mode (i.e., not applying any backpressure to them).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code join} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <TRight> the value type of the right Publisher source\n     * @param <TLeftEnd> the element type of the left duration Publishers\n     * @param <TRightEnd> the element type of the right duration Publishers\n     * @param <R> the result type\n     * @param other\n     *            the second Publisher to join items from\n     * @param leftEnd\n     *            a function to select a duration for each item emitted by the source Publisher, used to\n     *            determine overlap\n     * @param rightEnd\n     *            a function to select a duration for each item emitted by the {@code right} Publisher, used to\n     *            determine overlap\n     * @param resultSelector\n     *            a function that computes an item to be emitted by the resulting Publisher for any two\n     *            overlapping items emitted by the two Publishers\n     * @return a Flowable that emits items correlating to items emitted by the source Publishers that have\n     *         overlapping durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/join.html\">ReactiveX operators documentation: Join<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join(\n            Publisher<? extends TRight> other,\n            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,\n            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,\n            BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\");\n        ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\");\n        ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>(\n                this, other, leftEnd, rightEnd, resultSelector));\n    }\n\n\n    \/**\n     * Returns a Maybe that emits the last item emitted by this Flowable or completes if\n     * this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/last.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a new Maybe instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable, or a default item\n     * if this Flowable completes without emitting any items.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code last} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            the default item to emit if the source Publisher is empty\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> last(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits only the last item emitted by this Flowable or signals\n     * a {@link NoSuchElementException} if this Flowable is empty.\n     * <p>\n     * <img width=\"640\" height=\"236\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/lastOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lastOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/last.html\">ReactiveX operators documentation: Last<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> lastOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLast<T>(this, null, true));\n    }\n\n    \/**\n     * <strong>This method requires advanced knowledge about building operators; please consider\n     * other standard composition methods first;<\/strong>\n     * Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass\n     * the values of the current Publisher through the Operator function.\n     * <p>\n     * In other words, this allows chaining Subscribers together on a Publisher for acting on the values within\n     * the Publisher.\n     * <p> {@code\n     * Publisher.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()\n     * }\n     * <p>\n     * If the operator you are creating is designed to act on the individual items emitted by a source\n     * Publisher, use {@code lift}. If your operator is designed to transform the source Publisher as a whole\n     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The {@code Operator} instance provided is responsible to be backpressure-aware or\n     *  document the fact that the consumer of the returned {@code Publisher} has to apply one of\n     *  the {@code onBackpressureXXX} operators.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output value type\n     * @param lifter the Operator that implements the Publisher-operating function to be applied to the source\n     *             Publisher\n     * @return a Flowable that is the result of applying the lifted Operator to the source Publisher\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {\n        ObjectHelper.requireNonNull(lifter, \"lifter is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableLift<R, T>(this, lifter));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified function to each item emitted by the source Publisher and\n     * emits the results of these function applications.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/map.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the output type\n     * @param mapper\n     *            a function to apply to each item emitted by the Publisher\n     * @return a Flowable that emits the items from the source Publisher, transformed by the specified\n     *         function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/map.html\">ReactiveX operators documentation: Map<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMap<T, R>(this, mapper));\n    }\n\n    \/**\n     * Returns a Flowable that represents all of the emissions <em>and<\/em> notifications from the source\n     * Publisher into emissions marked with their original types within {@link Notification} objects.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/materialize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and expects it from the source {@code Publisher}.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits items that are the result of materializing the items and notifications\n     *         of the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/materialize-dematerialize.html\">ReactiveX operators documentation: Materialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Notification<T>> materialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableMaterialize<T>(this));\n    }\n\n    \/**\n     * Flattens this and another Publisher into a single Publisher, without any transformation.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/merge.png\" alt=\"\">\n     * <p>\n     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by\n     * using the {@code mergeWith} method.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honor\n     *  backpressure; if violated, the operator <em>may<\/em> signal {@code MissingBackpressureException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code mergeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher to be merged\n     * @return a Flowable that emits all of the items emitted by the source Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/merge.html\">ReactiveX operators documentation: Merge<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> mergeWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return merge(this, other);\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of {@link #bufferSize()} slots.\n     *\n     * <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly\n     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler, boolean)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean, int)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) {\n        return observeOn(scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},\n     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.\n     * <p>\n     * <img width=\"640\" height=\"308\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this\n     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception\n     *  pops up; look for sources up the chain that don't support backpressure,\n     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any\n     *  of the {@code onBackpressureXXX} operators <strong>before<\/strong> applying {@code observeOn} itself.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to notify {@link Subscriber}s on\n     * @param delayError\n     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the\n     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received\n     *            from upstream\n     * @param bufferSize the size of the buffer.\n     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/observeon.html\">ReactiveX operators documentation: ObserveOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #subscribeOn\n     * @see #observeOn(Scheduler)\n     * @see #observeOn(Scheduler, boolean)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n\n    \/**\n     * Filters the items emitted by a Publisher, only emitting those of the specified type.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/ofClass.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the output type\n     * @param clazz\n     *            the class type to filter the items emitted by the source Publisher\n     * @return a Flowable that emits items from the source Publisher of type {@code clazz}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/filter.html\">ReactiveX operators documentation: Filter<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> ofType(final Class<U> clazz) {\n        ObjectHelper.requireNonNull(clazz, \"clazz is null\");\n        return filter(Functions.isInstanceOf(clazz)).cast(clazz);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer() {\n        return onBackpressureBuffer(bufferSize(), false, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these\n     * items indefinitely until they can be emitted.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source Publisher modified to buffer items to the extent system resources allow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(boolean delayError) {\n        return onBackpressureBuffer(bufferSize(), delayError, true);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity) {\n        return onBackpressureBuffer(capacity, false, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) {\n        return onBackpressureBuffer(capacity, delayError, false);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, and cancelling the source.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) {\n        ObjectHelper.verifyPositive(capacity, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, Functions.EMPTY_ACTION));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param delayError\n     *                if true, an exception from the current Flowable is delayed until all buffered elements have been\n     *                consumed by the downstream; if false, an exception is immediately signalled to the downstream, skipping\n     *                any buffered element\n     * @param unbounded\n     *                if true, the capacity value is interpreted as the internal \"island\" size of the unbounded buffer\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,\n            Action onOverflow) {\n        ObjectHelper.requireNonNull(onOverflow, \"onOverflow is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBuffer<T>(this, capacity, unbounded, delayError, onOverflow));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will {@code onError} emitting\n     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered\n     * items, cancelling the source, and notifying the producer with {@code onOverflow}.\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @return the source {@code Publisher} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) {\n        return onBackpressureBuffer(capacity, false, false, onOverflow);\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to\n     * a given amount of items until they can be emitted. The resulting Publisher will behave as determined\n     * by {@code overflowStrategy} if the buffer capacity is exceeded.\n     *\n     * <ul>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR} (default) will {@code onError} dropping all undelivered items,\n     *     cancelling the source, and notifying the producer with {@code onOverflow}. <\/li>\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST} will drop any new items emitted by the producer while\n     *     the buffer is full, without generating any {@code onError}.  Each drop will however invoke {@code onOverflow}\n     *     to signal the overflow to the producer.<\/li>j\n     *     <li>{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST} will drop the oldest items in the buffer in order to make\n     *     room for newly emitted ones. Overflow will not generate an{@code onError}, but each drop will invoke\n     *     {@code onOverflow} to signal the overflow to the producer.<\/li>\n     * <\/ul>\n     *\n     * <p>\n     * <img width=\"640\" height=\"300\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.buffer.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacity number of slots available in the buffer.\n     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.\n     * @param overflowStrategy how should the {@code Publisher} react to buffer overflows.  Null is not allowed.\n     * @return the source {@code Flowable} modified to buffer items up to the given capacity\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {\n        ObjectHelper.requireNonNull(overflowStrategy, \"strategy is null\");\n        ObjectHelper.verifyPositive(capacity, \"capacity\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureBufferStrategy<T>(this, capacity, onOverflow, overflowStrategy));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,\n     * rather than emit, those items that its Subscriber is not prepared to observe.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.drop.png\" alt=\"\">\n     * <p>\n     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until\n     * the Subscriber invokes {@code request(n)} again to increase the request count.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.\n     * @return the source Publisher modified to drop {@code onNext} notifications on overflow\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/backpressure.html\">ReactiveX operators documentation: backpressure operators<\/a>\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {\n        ObjectHelper.requireNonNull(onDrop, \"onDrop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));\n    }\n\n    \/**\n     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to\n     * hold onto the latest value and emit that on request.\n     * <p>\n     * <img width=\"640\" height=\"245\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/bp.obp.latest.png\" alt=\"\">\n     * <p>\n     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that\n     * the downstream is not blocking while requesting more values.\n     * <p>\n     * Note that if the upstream Publisher does support backpressure, this operator ignores that capability\n     * and doesn't propagate any backpressure requests from downstream.\n     * <p>\n     * Note that due to the nature of how backpressure requests are propagated through subscribeOn\/observeOn,\n     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.\n     * <p>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded\n     *  manner (i.e., not applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified so that it emits the most recently-received item upon request\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onBackpressureLatest() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnBackpressureLatest<T>(this));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass a function that returns a Publisher ({@code resumeFunction}) to\n     * {@code onErrorResumeNext}, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to the Publisher returned from\n     * {@code resumeFunction}, which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an error happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  a {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param resumeFunction\n     *            a function that returns a Publisher that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {\n        ObjectHelper.requireNonNull(resumeFunction, \"resumeFunction is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorResumeNext.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this\n     * behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onErrorResumeNext} method, if the original Publisher encounters an error, instead of invoking its\n     * Subscriber's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which\n     * will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,\n     * because no Publisher necessarily invokes {@code onError}, the Subscriber may never know that an error\n     * happened.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher source that will take over if the source Publisher encounters\n     *            an error\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return onErrorResumeNext(Functions.justFunction(next));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param valueSupplier\n     *            a function that returns a single value that will be emitted along with a regular onComplete in case\n     *            the current Flowable signals an onError event\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {\n        ObjectHelper.requireNonNull(valueSupplier, \"valueSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorReturn<T>(this, valueSupplier));\n    }\n\n    \/**\n     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an error.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onErrorReturn.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to\n     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this\n     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}\n     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's\n     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.\n     * <p>\n     * You can use this to prevent errors from propagating or to supply fallback data should errors be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor\n     *  backpressure as well. If it this expectation is violated, the operator <em>may<\/em> throw\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param item\n     *            the value that is emitted along with a regular onComplete in case the current\n     *            Flowable signals an exception\n     * @return the original Publisher with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onErrorReturnItem(final T item) {\n        ObjectHelper.requireNonNull(item, \"item is null\");\n        return onErrorReturn(Functions.justFunction(item));\n    }\n\n    \/**\n     * Instructs a Publisher to pass control to another Publisher rather than invoking\n     * {@link Subscriber#onError onError} if it encounters an {@link java.lang.Exception}.\n     * <p>\n     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}\n     * or {@link java.lang.Error} but lets those continue through.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/onExceptionResumeNextViaPublisher.png\" alt=\"\">\n     * <p>\n     * By default, when a Publisher encounters an exception that prevents it from emitting the expected item\n     * to its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits\n     * without invoking any more of its Subscriber's methods. The {@code onExceptionResumeNext} method changes\n     * this behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's\n     * {@code onExceptionResumeNext} method, if the original Publisher encounters an exception, instead of\n     * invoking its Subscriber's {@code onError} method, it will instead relinquish control to\n     * {@code resumeSequence} which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is\n     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber\n     * may never know that an exception happened.\n     * <p>\n     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be\n     * encountered.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}s\n     *  are expected to honor backpressure as well.\n     *  If any of them violate this expectation, the operator <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes or\n     *  {@code MissingBackpressureException} is signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param next\n     *            the next Publisher that will take over if the source Publisher encounters\n     *            an exception\n     * @return the original Publisher, with appropriately modified behavior\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/catch.html\">ReactiveX operators documentation: Catch<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableOnErrorNext<T>(this, Functions.justFunction(next), true));\n    }\n\n    \/**\n     * Nulls out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Flowable which out references to the upstream producer and downstream Subscriber if\n     * the sequence is terminated or downstream cancels\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> onTerminateDetach() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableDetach<T>(this));\n    }\n\n    \/**\n     * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel() {\n        return ParallelFlowable.from(this);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        return ParallelFlowable.from(this, parallelism);\n    }\n\n    \/**\n     * Parallelizes the flow by creating the specified number of 'rails'\n     * and dispatches the upstream items to them in a round-robin fashion and\n     * uses the defined per-'rail' prefetch amount.\n     * <p>\n     * Note that the rails don't execute in parallel on their own and one needs to\n     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where\n     * each rail will execute.\n     * <p>\n     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.\n     * <p>\n     * <img width=\"640\" height=\"547\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/flowable.parallel.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressure\n     *  as well.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code parallel} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param parallelism the number of 'rails' to use\n     * @param prefetch the number of items each 'rail' should prefetch\n     * @return the new ParallelFlowable instance\n     * @since 2.0.5 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @CheckReturnValue\n    @Experimental\n    public final ParallelFlowable<T> parallel(int parallelism, int prefetch) {\n        ObjectHelper.verifyPositive(parallelism, \"parallelism\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return ParallelFlowable.from(this, parallelism, prefetch);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish() {\n        return publish(bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        return publish(selector, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a\n     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects the source {@code Publisher} to honor backpressure and if this expectation is\n     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}\n     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be\n     *  independent from the provided {@code Publisher} to the function, the output's backpressure behavior\n     *  is determined by this returned {@code Publisher}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a function that can use the multicasted source sequence as many times as needed, without\n     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will\n     *            receive all notifications of the source from the time of the subscription forward.\n     * @param prefetch\n     *            the number of elements to prefetch from the current Flowable\n     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<? extends R>> selector, int prefetch) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(prefetch, \"prefetch\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowablePublishMulticast<T, R>(this, selector, prefetch, false));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its\n     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those\n     * {@link Subscriber}s that have subscribed to it.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishConnect.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s\n     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,\n     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the number of elements to prefetch from the current Flowable\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/publish.html\">ReactiveX operators documentation: Publish<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> publish(int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowablePublish.create(this, bufferSize);\n    }\n\n    \/**\n     * Requests {@code n} initially from the upstream and then 75% of {@code n} subsequently\n     * after 75% of {@code n} values have been emitted to the downstream.\n     *\n     * <p>This operator allows preventing the downstream to trigger unbounded mode via {@code request(Long.MAX_VALUE)}\n     * or compensate for the per-item overhead of small and frequent requests.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator expects backpressure from upstream and honors backpressure from downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param n the initial request amount, further request will happen after 75% of this value\n     * @return the Publisher that rebatches request amounts from downstream\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> rebatchRequests(int n) {\n        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);\n    }\n\n    \/**\n     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * and emits the final result from the final call to your function as its sole item.\n     * <p>\n     * If the source is empty, a {@code NoSuchElementException} is signalled.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduce.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be used in the next accumulator call\n     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by\n     *         the source Flowable\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduce<T>(this, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seed\n     *            the initial (seed) accumulator value\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seed, \"seed is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceSeed<T, R>(this, seed, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a specified seed value, then feeds the result of that function along with the second item\n     * emitted by a Publisher into the same function, and so on until all items have been emitted by the\n     * source Publisher, emitting the final result from the final call to your function as its sole item.\n     * <p>\n     * <img width=\"640\" height=\"325\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/reduceSeed.png\" alt=\"\">\n     * <p>\n     * This technique, which is called \"reduce\" here, is sometimes called \"aggregate,\" \"fold,\" \"accumulate,\"\n     * \"compress,\" or \"inject\" in other programming contexts. Groovy, for instance, has an {@code inject} method\n     * that does a similar operation on lists.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its downstream consumer and consumes the\n     *  upstream source in unbounded mode.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code reduceWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the accumulator and output value type\n     * @param seedSupplier\n     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber\n     * @param reducer\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n     *            result of which will be used in the next accumulator call\n     * @return a Flowable that emits a single item that is the result of accumulating the output from the\n     *         items emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/reduce.html\">ReactiveX operators documentation: Reduce<\/a>\n     * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(reducer, \"reducer is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableReduceWith<T, R>(this, seedSupplier, reducer));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher indefinitely.\n     * <p>\n     * <img width=\"640\" height=\"309\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher repeatedly and in sequence\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat() {\n        return repeat(Long.MAX_VALUE);\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     * {@code count} times.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param times\n     *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty\n     *            sequence\n     * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most\n     *         {@code count} times\n     * @throws IllegalArgumentException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeat(long times) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        if (times == 0) {\n            return empty();\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeat<T>(this, times));\n    }\n\n    \/**\n     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher until\n     * the provided stop function returns true.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeat.on.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stop\n     *                a boolean supplier that is called when the current Flowable completes and unless it returns\n     *                false, the current Flowable is resubscribed\n     * @return the new Flowable instance\n     * @throws NullPointerException\n     *             if {@code stop} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatUntil(BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatUntil<T>(this, stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of\n     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will\n     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/repeatWhen.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.\n     * @return the source Publisher modified with repeat logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/repeat.html\">ReactiveX operators documentation: Repeat<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRepeatWhen<T>(this, handler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher\n     * that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its\n     *         items to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay() {\n        return FlowableReplay.createFrom(this);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on the items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"450\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @return a Flowable that emits items that are the results of invoking the selector on a\n     *         {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying {@code bufferSize} notifications.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            the selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher\n     *         replaying no more than {@code bufferSize} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {\n        return replay(selector, bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fnts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and\n     *         replays no more than {@code bufferSize} items that were emitted within the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(\n                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying a maximum of {@code bufferSize} items.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param bufferSize\n     *            the buffer size that limits the number of items the connectable Publisher can replay\n     * @param scheduler\n     *            the Scheduler on which the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying no more than {@code bufferSize} notifications\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),\n                FlowableInternalHelper.replayFunction(selector, scheduler)\n        );\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"435\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ft.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {\n        return replay(selector, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     * replaying all items that were emitted within a specified time window.\n     * <p>\n     * <img width=\"640\" height=\"440\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is the time source for the window\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items that were emitted within the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the results of invoking a specified selector on items\n     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"445\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.fs.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param selector\n     *            a selector function, which can use the multicasted sequence as many times as needed, without\n     *            causing multiple subscriptions to the Publisher\n     * @param scheduler\n     *            the Scheduler where the replay is observed\n     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by\n     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,\n     *         replaying all items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(selector, \"selector is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),\n                FlowableInternalHelper.replayFunction(selector, scheduler));\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items emitted by that Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final ConnectableFlowable<T> replay(final int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable\n     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is\n     * subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nt.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {\n        return replay(bufferSize, time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A\n     * Connectable Publisher resembles an ordinary Publisher, except that it does not begin emitting items\n     * when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.nts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler that is used as a time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted during the window defined by\n     *         {@code time}\n     * @throws IllegalArgumentException\n     *             if {@code bufferSize} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles\n     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only\n     * when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param bufferSize\n     *            the buffer size that limits the number of items that can be replayed\n     * @param scheduler\n     *            the scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays at most {@code bufferSize} items that were emitted by the Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(bufferSize), scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final ConnectableFlowable<T> replay(long time, TimeUnit unit) {\n        return replay(time, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher\n     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,\n     * but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the duration of the window in which the replayed items must have been emitted\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that is the time source for the window\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and\n     *         replays the items that were emitted during the window defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.create(this, time, unit, scheduler);\n    }\n\n    \/**\n     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     * will replay all of its items and notifications to any future {@link Subscriber} on the given\n     * {@link Scheduler}. A Connectable Publisher resembles an ordinary Publisher, except that it does not\n     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.\n     * <p>\n     * <img width=\"640\" height=\"515\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/replay.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child\n     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will\n     *  request 100 elements from the underlying Publisher sequence.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the Scheduler on which the Subscribers will observe the emitted items\n     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that\n     *         will replay all of its items and notifications to any future {@link Subscriber} on the given\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/replay.html\">ReactiveX operators documentation: Replay<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final ConnectableFlowable<T> replay(final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return FlowableReplay.observeOn(replay(), scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * (infinite retry count).\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher rather than propagating the {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry() {\n        return retry(Long.MAX_VALUE, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * and the predicate returns true for that specific exception and retry count.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            the predicate that determines if a resubscription may happen in case of a specific exception\n     *            and retry count\n     * @return the source Publisher modified with retry logic\n     * @see #retry()\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryBiPredicate<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}\n     * up to a specified number of retries.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retry.png\" alt=\"\">\n     * <p>\n     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source\n     * Publisher for a maximum of {@code count} resubscriptions rather than propagating the\n     * {@code onError} call.\n     * <p>\n     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even\n     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits\n     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence\n     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of retry attempts before failing\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long count) {\n        return retry(count, Functions.alwaysTrue());\n    }\n\n    \/**\n     * Retries at most times or until the predicate returns false, whichever happens first.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param times the number of times to repeat\n     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) {\n        if (times < 0) {\n            throw new IllegalArgumentException(\"times >= 0 required but it was \" + times);\n        }\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate));\n    }\n\n    \/**\n     * Retries the current Flowable if the predicate returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {\n        return retry(Long.MAX_VALUE, predicate);\n    }\n\n    \/**\n     * Retries until the given stop function returns true.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param stop the function that should return true to stop retrying\n     * @return the new Flowable instance\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryUntil(final BooleanSupplier stop) {\n        ObjectHelper.requireNonNull(stop, \"stop is null\");\n        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));\n    }\n\n    \/**\n     * Returns a Flowable that emits the same values as the source Publisher with the exception of an\n     * {@code onError}. An {@code onError} notification from the source will result in the emission of a\n     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}\n     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call\n     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will\n     * resubscribe to the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"430\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/retryWhen.f.png\" alt=\"\">\n     *\n     * Example:\n     *\n     * This retries 3 times, each time incrementing the number of seconds it waits.\n     *\n     * <pre><code>\n     *  Publisher.create((Subscriber<? super String> s) -> {\n     *      System.out.println(\"subscribing\");\n     *      s.onError(new RuntimeException(\"always fails\"));\n     *  }).retryWhen(attempts -> {\n     *      return attempts.zipWith(Publisher.range(1, 3), (n, i) -> i).flatMap(i -> {\n     *          System.out.println(\"delay retry by \" + i + \" second(s)\");\n     *          return Publisher.timer(i, TimeUnit.SECONDS);\n     *      });\n     *  }).blockingForEach(System.out::println);\n     * <\/code><\/pre>\n     *\n     * Output is:\n     *\n     * <pre> {@code\n     * subscribing\n     * delay retry by 1 second(s)\n     * subscribing\n     * delay retry by 2 second(s)\n     * subscribing\n     * delay retry by 3 second(s)\n     * subscribing\n     * } <\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator <em>may<\/em> throw an {@code IllegalStateException}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code retryWhen} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param handler\n     *            receives a Publisher of notifications with which a user can complete or error, aborting the\n     *            retry\n     * @return the source Publisher modified with retry logic\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/retry.html\">ReactiveX operators documentation: Retry<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> retryWhen(\n            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n        ObjectHelper.requireNonNull(handler, \"handler is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableRetryWhen<T>(this, handler));\n    }\n\n    \/**\n     * Subscribes to the current Flowable and wraps the given Subscriber into a SafeSubscriber\n     * (if not already a SafeSubscriber) that\n     * deals with exceptions thrown by a misbehaving Subscriber (that doesn't follow the\n     * Reactive-Streams specification).\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>This operator leaves the reactive world and the backpressure behavior depends on the Subscriber's behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the incoming Subscriber instance\n     * @throws NullPointerException if s is null\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final void safeSubscribe(Subscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        if (s instanceof SafeSubscriber) {\n            subscribe((SafeSubscriber<? super T>)s);\n        } else {\n            subscribe(new SafeSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> sample(long period, TimeUnit unit) {\n        return sample(period, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) {\n        return sample(period, unit, Schedulers.computation(), emitLast);\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher\n     * within periodic time intervals, where the intervals are defined on a particular Scheduler\n     * and optionally emit the very last upstream item when the upstream completes.\n     * <p>\n     * <img width=\"640\" height=\"276\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.s.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param period\n     *            the sampling rate\n     * @param unit\n     *            the {@link TimeUnit} in which {@code period} is defined\n     * @param scheduler\n     *            the {@link Scheduler} to use when sampling\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at\n     *         the specified time interval\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #throttleLast(long, TimeUnit, Scheduler)\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    @Experimental\n    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.nolast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> sample(Publisher<U> sampler) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));\n    }\n\n    \/**\n     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,\n     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous\n     * emission from the {@code sampler} Publisher\n     * and optionally emit the very last upstream item when the upstream or other Publisher complete.\n     * <p>\n     * <img width=\"640\" height=\"289\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/sample.o.emitlast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}\n     *      Publisher to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the sampler Publisher\n     * @param sampler\n     *            the Publisher to use for sampling the source Publisher\n     * @param emitLast\n     *            if true and the upstream completes while there is still an unsampled item available,\n     *            that item is emitted to downstream before completion\n     *            if false, an unsampled last item is ignored.\n     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever\n     *         the {@code sampler} Publisher emits an item or completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @since 2.0.5 - experimental\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final <U> Flowable<T> sample(Publisher<U> sampler, boolean emitLast) {\n        ObjectHelper.requireNonNull(sampler, \"sampler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, emitLast));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher, then feeds the result of that function along with the second item emitted by the source\n     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,\n     * emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scan.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits the results of each call to the accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> scan(BiFunction<T, T, T> accumulator) {\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScan<T>(this, accumulator));\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scan} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param initialValue\n     *            the initial (seed) accumulator item\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(initialValue, \"seed is null\");\n        return scanWith(Functions.justCallable(initialValue), accumulator);\n    }\n\n    \/**\n     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source\n     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by\n     * the source Publisher into the same function, and so on until all items have been emitted by the source\n     * Publisher, emitting the result of each of these iterations.\n     * <p>\n     * <img width=\"640\" height=\"320\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/scanSeed.png\" alt=\"\">\n     * <p>\n     * This sort of function is sometimes called an accumulator.\n     * <p>\n     * Note that the Publisher that results from this method will emit {@code initialValue} as its first\n     * emitted item.\n     * <p>\n     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher\n     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer\n     * the application of this operator via {@link #defer(Callable)}:\n     * <pre><code>\n     * Publisher&lt;T> source = ...\n     * Publisher.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));\n     *\n     * \/\/ alternatively, by using compose to stay fluent\n     *\n     * source.compose(o ->\n     *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))\n     * );\n     * <\/code><\/pre>\n     * <p>\n     * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\n     *  Violating this expectation, a {@code MissingBackpressureException} <em>may<\/em> get signalled somewhere downstream.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code scanWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the initial, accumulator and result type\n     * @param seedSupplier\n     *            a Callable that returns the initial (seed) accumulator item for each individual Subscriber\n     * @param accumulator\n     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose\n     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the\n     *            next accumulator call\n     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the\n     *         accumulator function\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/scan.html\">ReactiveX operators documentation: Scan<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {\n        ObjectHelper.requireNonNull(seedSupplier, \"seedSupplier is null\");\n        ObjectHelper.requireNonNull(accumulator, \"accumulator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));\n    }\n\n    \/**\n     * Forces a Publisher's emissions and notifications to be serialized and for it to obey\n     * <a href=\"http:\/\/reactivex.io\/documentation\/contract.html\">the Publisher contract<\/a> in other ways.\n     * <p>\n     * It is possible for a Publisher to invoke its Subscribers' methods asynchronously, perhaps from\n     * different threads. This could make such a Publisher poorly-behaved, in that it might try to invoke\n     * {@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call\n     * {@code onNext} from two different threads concurrently. You can force such a Publisher to be\n     * well-behaved and sequential by applying the {@code serialize} method to it.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/synchronize.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code serialize} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Publisher} that is guaranteed to be well-behaved and to make only serialized calls to\n     *         its Subscribers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/serialize.html\">ReactiveX operators documentation: Serialize<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> serialize() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSerialized<T>(this));\n    }\n\n    \/**\n     * Returns a new {@link Publisher} that multicasts (shares) the original {@link Publisher}. As long as\n     * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.\n     * When all subscribers have cancelled it will cancel the source {@link Publisher}.\n     * <p>\n     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount()}.\n     * <p>\n     * <img width=\"640\" height=\"510\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/publishRefCount.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure and and expects the source {@code Publisher} to honor backpressure as well.\n     *  If this expectation is violated, the operator will signal a {@code MissingBackpressureException} to\n     *  its {@code Subscriber}s.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code share} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@code Publisher} that upon connection causes the source {@code Publisher} to emit items\n     *         to its {@link Subscriber}s\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/refcount.html\">ReactiveX operators documentation: RefCount<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> share() {\n        return publish().refCount();\n    }\n\n    \/**\n     * Returns a Maybe that completes if this Flowable is empty, signals one item if this Flowable\n     * signals exactly one item or signals an {@code IllegalArgumentException} if this Flowable signals\n     * more than one item.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/single.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Maybe that emits the single item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleElement() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher\n     * emits only a single item, or a default item if the source Publisher emits no items. If the source\n     * Publisher emits more than one item, an {@code IllegalArgumentException} is signalled instead.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrDefault.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code single} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param defaultItem\n     *            a default value to emit if the source Publisher emits no item\n     * @return a Single that emits the single item emitted by the source Publisher, or a default item if\n     *         the source Publisher is empty\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> single(T defaultItem) {\n        ObjectHelper.requireNonNull(defaultItem, \"defaultItem is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, defaultItem, false));\n    }\n\n    \/**\n     * Returns a Single that emits the single item emitted by this Flowable, if this Flowable\n     * emits only a single item, otherwise\n     * if this Flowable completes without emitting any items a {@link NoSuchElementException} will be signalled and\n     * if this Flowable emits more than one item, an {@code IllegalArgumentException} will be signalled.\n     * <p>\n     * <img width=\"640\" height=\"205\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/singleOrError.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code singleOrError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return the new Single instance\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/first.html\">ReactiveX operators documentation: First<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> singleOrError() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSingle<T>(this, null, true));\n    }\n\n    \/**\n     * Returns a Flowable that skips the first {@code count} items emitted by the source Publisher and emits\n     * the remainder.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skip} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the number of items to skip\n     * @return a Flowable that is identical to the source Publisher except that it does not emit the first\n     *         {@code count} items that the source Publisher emits\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long count) {\n        if (count <= 0L) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkip<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skip} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} elapses and the emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skip(long time, TimeUnit unit) {\n        return skipUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window\n     * on a specified {@link Scheduler} elapses.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skip.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for the timed skipping<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window to skip\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} on which the timed wait happens\n     * @return a Flowable that skips values emitted by the source Publisher before the time window defined\n     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skip.html\">ReactiveX operators documentation: Skip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that drops a specified number of items from the end of the sequence emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.png\" alt=\"\">\n     * <p>\n     * This Subscriber accumulates a queue long enough to store the first {@code count} items. As more items are\n     * received, items are taken from the front of the queue and emitted by the returned Publisher. This causes\n     * such items to be delayed.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            number of items to drop from the end of the source sequence\n     * @return a Flowable that emits the items emitted by the source Publisher except for the dropped ones\n     *         at the end\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit) {\n        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.t.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) {\n        return skipLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return skipLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use to track the current time<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return skipLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window\n     * (defined on a specified scheduler) before the source completes.\n     * <p>\n     * <img width=\"640\" height=\"340\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipLast.ts.png\" alt=\"\">\n     * <p>\n     * Note: this action will cache the latest items arriving in the specified time window.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't support backpressure as it uses time to skip arbitrary number of elements and\n     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the scheduler used as the time source\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be skipped\n     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the\n     *         source completes defined by {@code time} and {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skiplast.html\">ReactiveX operators documentation: SkipLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        \/\/ the internal buffer holds pairs of (timestamp, value) so double the default buffer size\n        int s = bufferSize << 1;\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that skips items emitted by the source Publisher until a second Publisher emits\n     * an item.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param other\n     *            the second Publisher that has to emit an item before the source Publisher's elements begin\n     *            to be mirrored by the resulting Publisher\n     * @return a Flowable that skips items from the source Publisher until the second Publisher emits an\n     *         item, then emits the remaining items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipuntil.html\">ReactiveX operators documentation: SkipUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> skipUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that skips all items emitted by the source Publisher as long as a specified\n     * condition holds true, but emits all further source items as soon as the condition becomes false.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/skipWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code skipWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function to test each item emitted from the source Publisher\n     * @return a Flowable that begins emitting items emitted by the source Publisher when the specified\n     *         predicate becomes false\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/skipwhile.html\">ReactiveX operators documentation: SkipWhile<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));\n    }\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted() {\n        return toList().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the events emitted by source Publisher, in a\n     * sorted order based on a specified comparison function.\n     *\n     * <p>Note that calling {@code sorted} with long, non-terminating or infinite sources\n     * might cause {@link OutOfMemoryError}\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param sortFunction\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Flowable that emits the items emitted by the source Publisher in sorted order\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Iterable} before it begins to emit items\n     * emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            an Iterable that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Iterable<? extends T> items) {\n        return concatArray(fromIterable(items), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the items in a specified {@link Publisher} before it begins to emit\n     * items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.o.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            a Publisher that contains the items you want the modified Publisher to emit first\n     * @return a Flowable that emits the items in the specified {@link Publisher} and then emits the items\n     *         emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return concatArray(other, this);\n    }\n\n    \/**\n     * Returns a Flowable that emits a specified item before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param value\n     *            the item to emit first\n     * @return a Flowable that emits the specified item before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWith(T value) {\n        ObjectHelper.requireNonNull(value, \"item is null\");\n        return concatArray(just(value), this);\n    }\n\n    \/**\n     * Returns a Flowable that emits the specified items before it begins to emit items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/startWith.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The source {@code Publisher}\n     *  is expected to honor backpressure as well. If it violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code startWithArray} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param items\n     *            the array of values to emit first\n     * @return a Flowable that emits the specified items before it begins to emit items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/startwith.html\">ReactiveX operators documentation: StartWith<\/a>\n     *\/\n    @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> startWithArray(T... items) {\n        Flowable<T> fromArray = fromArray(items);\n        if (fromArray == empty()) {\n            return RxJavaFlowablePlugins.onAssembly(this);\n        }\n        return concatArray(fromArray, this);\n    }\n\n    \/**\n     * Ensures that the event flow between the upstream and downstream follow\n     * the Reactive-Streams 1.0 specification by honoring the 3 additional rules\n     * (which are omitted in standard operators due to performance reasons).\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns<\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel<\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException)<\/li>\n     * <\/ul>\n     * In addition, if rule \u00a72.12 (onSubscribe must be called at most once) is violated,\n     * the sequence is cancelled an onError(IllegalStateException) is emitted.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code strict} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new Flowable instance\n     * @since 2.0.5 - experimental\n     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict\n     *\/\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    @CheckReturnValue\n    @Deprecated\n    public final Flowable<T> strict() {\n        return this;\n    }\n\n    \/**\n     * Subscribes to a Publisher and ignores {@code onNext} and {@code onComplete} emissions.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe() {\n        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides a callback to handle the items it emits.\n     * <p>\n     * If the Flowable emits an error, it is wrapped into an\n     * {@link io.reactivex.common.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n     * and routed to the RxJavaFlowablePlugins.onError handler.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext) {\n        return subscribe(onNext, Functions.ON_ERROR_MISSING,\n                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error\n     * notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {\n        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete) {\n        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);\n    }\n\n    \/**\n     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or\n     * completion notification it issues.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no\n     *  backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param onNext\n     *             the {@code Consumer<T>} you have designed to accept emissions from the Publisher\n     * @param onError\n     *             the {@code Consumer<Throwable>} you have designed to accept any error notification from the\n     *             Publisher\n     * @param onComplete\n     *             the {@code Action} you have designed to accept a completion notification from the\n     *             Publisher\n     * @param onSubscribe\n     *             the {@code Consumer} that receives the upstream's Subscription\n     * @return a {@link Disposable} reference with which the caller can stop receiving items before\n     *         the Publisher has finished sending them\n     * @throws NullPointerException\n     *             if {@code onNext} is null, or\n     *             if {@code onError} is null, or\n     *             if {@code onComplete} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribe.html\">ReactiveX operators documentation: Subscribe<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,\n            Action onComplete, Consumer<? super Subscription> onSubscribe) {\n        ObjectHelper.requireNonNull(onNext, \"onNext is null\");\n        ObjectHelper.requireNonNull(onError, \"onError is null\");\n        ObjectHelper.requireNonNull(onComplete, \"onComplete is null\");\n        ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\");\n\n        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);\n\n        subscribe(ls);\n\n        return ls;\n    }\n\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Override\n    public final void subscribe(Subscriber<? super T> s) {\n        if (s instanceof RelaxedSubscriber) {\n            subscribe((RelaxedSubscriber<? super T>)s);\n        } else {\n            ObjectHelper.requireNonNull(s, \"s is null\");\n            subscribe(new StrictSubscriber<T>(s));\n        }\n    }\n\n    \/**\n     * Establish a connection between this Flowable and the given RelaxedSubscriber and\n     * start streaming events based on the demand of the RelaxedSubscriber.\n     * <p>\n     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n     * <p>\n     * Each {@link Subscription} will work for only a single {@link RelaxedSubscriber}.\n     * <p>\n     * If the same {@link RelaxedSubscriber} instance is subscribed to multiple {@link Flowable}s and\/or the\n     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}\n     * methods manually.\n     * <p>\n     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal\n     * the error via {@link RelaxedSubscriber#onError(Throwable)}.\n     * <p>\n     * This subscribe method relaxes the following Reactive-Streams rules:\n     * <ul>\n     * <li>\u00a71.3: onNext should not be called concurrently until onSubscribe returns.\n     *     <b>RelaxedSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.<\/b><\/li>\n     * <li>\u00a72.3: onError or onComplete must not call cancel.\n     *     <b>Calling request() or cancel() is NOP at this point.<\/b><\/li>\n     * <li>\u00a72.12: onSubscribe must be called at most once on the same instance.\n     *     <b>RelaxedSubscriber reuse is not checked and if happens, it is the responsibility of\n     *     the RelaxedSubscriber to ensure proper serialization of its onXXX methods.<\/b><\/li>\n     * <li>\u00a73.9: negative requests should emit an onError(IllegalArgumentException).\n     *     <b>Non-positive requests signal via RxJavaFlowablePlugins.onError and the stream is not affected.<\/b><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code RelaxedSubscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param s the RelaxedSubscriber that will consume signals from this Flowable\n     * @since 2.0.7 - experimental\n     *\/\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @Experimental\n    public final void subscribe(RelaxedSubscriber<? super T> s) {\n        ObjectHelper.requireNonNull(s, \"s is null\");\n        try {\n            Subscriber<? super T> z = RxJavaFlowablePlugins.onSubscribe(this, s);\n\n            ObjectHelper.requireNonNull(z, \"Plugin returned null Subscriber\");\n\n            subscribeActual(z);\n        } catch (NullPointerException e) { \/\/ NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            \/\/ can't call onError because no way to know if a Subscription has been set or not\n            \/\/ can't call onSubscribe because the call might have set a Subscription already\n            RxJavaCommonPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n\n    \/**\n     * Operator implementations (both source and intermediate) should implement this method that\n     * performs the necessary business logic.\n     * <p>There is no need to call any of the plugin hooks on the current Flowable instance or\n     * the Subscriber.\n     * @param s the incoming Subscriber, never null\n     *\/\n    protected abstract void subscribeActual(Subscriber<? super T> s);\n\n    \/**\n     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given\n     * Subscriber as is.\n     * <p>Usage example:\n     * <pre><code>\n     * Flowable&lt;Integer> source = Flowable.range(1, 10);\n     * CompositeDisposable composite = new CompositeDisposable();\n     *\n     * ResourceSubscriber&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n     *     \/\/ ...\n     * };\n     *\n     * composite.add(source.subscribeWith(rs));\n     * <\/code><\/pre>\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The backpressure behavior\/expectation is determined by the supplied {@code Subscriber}.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <E> the type of the Subscriber to use and return\n     * @param subscriber the Subscriber (subclass) to use and return, not null\n     * @return the input {@code subscriber}\n     * @throws NullPointerException if {@code subscriber} is null\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n        subscribe(subscriber);\n        return subscriber;\n    }\n\n    \/**\n     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/subscribeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform subscription actions on\n     * @return the source Publisher modified so that its subscriptions happen on the\n     *         specified {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     * @see <a href=\"http:\/\/www.grahamlea.com\/2014\/07\/rxjava-threading-examples\/\">RxJava Threading Examples<\/a>\n     * @see #observeOn\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher or the items of an alternate\n     * Publisher if the source Publisher is empty.\n     * <img width=\"640\" height=\"255\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchifempty.png\" alt=\"\">\n     * <p\/>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>If the source {@code Publisher} is empty, the alternate {@code Publisher} is expected to honor backpressure.\n     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as instead.\n     *  In either case, if violated, a {@code MissingBackpressureException} <em>may<\/em> get\n     *  signalled somewhere downstream.\n     *  <\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *              the alternate Publisher to subscribe to if the source does not emit any items\n     * @return  a Publisher that emits the items emitted by the source Publisher or the items of an\n     *          alternate Publisher if the source Publisher is empty.\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMap(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, false);\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return switchMapDelayError(mapper, bufferSize());\n    }\n\n    \/**\n     * Returns a new Publisher by applying a function that you supply to each item emitted by the source\n     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted\n     * of these Publishers and delays any error until all Publishers terminate.\n     * <p>\n     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.\n     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is\n     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signalled.\n     * <p>\n     * <img width=\"640\" height=\"350\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/switchMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an\n     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor\n     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}\n     *  but the violation <em>may<\/em> lead to {@code OutOfMemoryError} due to internal buffer bloat.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the element type of the inner Publishers and the output\n     * @param mapper\n     *            a function that, when applied to an item emitted by the source Publisher, returns an\n     *            Publisher\n     * @param bufferSize\n     *            the number of elements to prefetch from the current active inner Publisher\n     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\">ReactiveX operators documentation: FlatMap<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {\n        return switchMap0(mapper, bufferSize, true);\n    }\n\n    <R> Flowable<R> switchMap0(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize, boolean delayError) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (this instanceof ConstantValuePublisher) {\n            @SuppressWarnings(\"unchecked\")\n            T v = ((ConstantValuePublisher<T>)this).value();\n            if (v == null) {\n                return empty();\n            }\n            return FlowableScalarXMap.scalarXMap(v, mapper);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableSwitchMap<T, R>(this, mapper, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.png\" alt=\"\">\n     * <p>\n     * This method returns a Publisher that will invoke a subscribing {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking\n     * {@link Subscriber#onComplete onComplete}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior in case the first request is smaller than the {@code count}. Otherwise, the source {@code Publisher}\n     *  is consumed in an unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @return a Flowable that emits only the first {@code count} items emitted by the source Publisher, or\n     *         all of the items from the source Publisher if that Publisher emits fewer than {@code count} items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL) \/\/ may trigger UNBOUNDED_IN\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> take(long count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTake<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time runs\n     * out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> take(long time, TimeUnit unit) {\n        return takeUntil(timer(time, unit));\n    }\n\n    \/**\n     * Returns a Flowable that emits those items emitted by source Publisher before a specified time (on a\n     * specified Scheduler) runs out.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/take.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler used for time source\n     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out,\n     *         according to the specified Scheduler\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/take.html\">ReactiveX operators documentation: Take<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeUntil(timer(time, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than\n     * {@code count} items then all of its items are emitted.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.n.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream if the {@code count} is non-zero; ignores\n     *  backpressure if the {@code count} is zero as it doesn't signal any values.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit from the end of the sequence of items emitted by the source\n     *            Publisher\n     * @return a Flowable that emits at most the last {@code count} items emitted by the source Publisher\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(int count) {\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        } else\n        if (count == 0) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableIgnoreElements<T>(this));\n        } else\n        if (count == 1) {\n            return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastOne<T>(this));\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLast<T>(this, count));\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeLast} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {\n        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(count, time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were\n     * emitted in a specified window of time before the Publisher completed, where the timing information is\n     * provided by a given Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.tns.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use for tracking the current time<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum number of items to emit\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the {@link Scheduler} that provides the timestamps for the observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted\n     *         in a specified window of time before the Publisher completed, where the timing information is\n     *         provided by the given {@code scheduler}\n     * @throws IndexOutOfBoundsException\n     *             if {@code count} is less than zero\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"count >= 0 required but it was \" + count);\n        }\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit) {\n        return takeLast(time, unit, Schedulers.computation(), false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.t.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.<\/dd>\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) {\n        return takeLast(time, unit, Schedulers.computation(), delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {\n        return takeLast(time, unit, scheduler, false, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n        return takeLast(time, unit, scheduler, delayError, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified\n     * window of time before the Publisher completed, where the timing information is provided by a specified\n     * Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeLast.ts.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may<\/em>\n     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.\n     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param time\n     *            the length of the time window\n     * @param unit\n     *            the time unit of {@code time}\n     * @param scheduler\n     *            the Scheduler that provides the timestamps for the Observed items\n     * @param delayError\n     *            if true, an exception signalled by the current Flowable is delayed until the regular elements are consumed\n     *            by the downstream; if false, an exception is immediately signalled and all regular elements dropped\n     * @param bufferSize\n     *            the hint about how many elements to expect to be last\n     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of\n     *         time before the Publisher completed specified by {@code time}, where the timing information is\n     *         provided by {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takelast.html\">ReactiveX operators documentation: TakeLast<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {\n        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher, checks the specified predicate\n     * for each item, and then completes when the condition is satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.p.png\" alt=\"\">\n     * <p>\n     * The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition is\n     * evaluated <em>after<\/em> the item is emitted.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstream\n     *  source and the downstream consumer.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param stopPredicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that first emits items emitted by the source Publisher, checks the specified\n     *         condition after each item, and then completes when the condition is satisfied.\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     * @see Flowable#takeWhile(Predicate)\n     * @since 1.1.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {\n        ObjectHelper.requireNonNull(stopPredicate, \"stopPredicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits the items emitted by the source Publisher until a second Publisher\n     * emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeUntil.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param other\n     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items\n     *            from the source Publisher\n     * @param <U>\n     *            the type of items emitted by {@code other}\n     * @return a Flowable that emits the items emitted by the source Publisher until such time as {@code other} emits its first item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takeuntil.html\">ReactiveX operators documentation: TakeUntil<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<T> takeUntil(Publisher<U> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits items emitted by the source Publisher so long as each item satisfied a\n     * specified condition, and then completes as soon as this condition is not satisfied.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/takeWhile.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param predicate\n     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean\n     * @return a Flowable that emits the items from the source Publisher so long as each item satisfies the\n     *         condition defined by {@code predicate}, then completes\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\">ReactiveX operators documentation: TakeWhile<\/a>\n     * @see Flowable#takeUntil(Predicate)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param windowDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code windowDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {\n        return throttleFirst(windowDuration, unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the windows are managed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas\n     * {@link #throttleLast} ticks at scheduled intervals.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleFirst.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param skipDuration\n     *            time to wait before emitting another item after emitting the last item\n     * @param unit\n     *            the unit of time of {@code skipDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {\n        return sample(intervalDuration, unit);\n    }\n\n    \/**\n     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential\n     * time windows of a specified duration, where the duration is governed by a specified Scheduler.\n     * <p>\n     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas\n     * {@link #throttleFirst} does not tick, it just tracks passage of time.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleLast.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param intervalDuration\n     *            duration of windows within which the last item emitted by the source Publisher will be\n     *            emitted\n     * @param unit\n     *            the unit of time of {@code intervalDuration}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each\n     *            event\n     * @return a Flowable that performs the throttle operation\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/sample.html\">ReactiveX operators documentation: Sample<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #sample(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {\n        return sample(intervalDuration, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) {\n        return debounce(timeout, unit);\n    }\n\n    \/**\n     * Returns a Flowable that only emits those items emitted by the source Publisher that are not followed\n     * by another emitted item within a specified time window, where the time window is governed by a specified\n     * Scheduler.\n     * <p>\n     * <em>Note:<\/em> If the source Publisher keeps emitting items more frequently than the length of the time\n     * window then no items will be emitted by the resulting Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/throttleWithTimeout.s.png\" alt=\"\">\n     * <p>\n     * Information on debounce vs throttle:\n     * <p>\n     * <ul>\n     * <li><a href=\"http:\/\/drupalmotion.com\/article\/debounce-and-throttle-visual-explanation\">Debounce and Throttle: visual explanation<\/a><\/li>\n     * <li><a href=\"http:\/\/unscriptable.com\/2009\/03\/20\/debouncing-javascript-methods\/\">Debouncing: javascript methods<\/a><\/li>\n     * <li><a href=\"http:\/\/www.illyriad.co.uk\/blog\/index.php\/2011\/09\/javascript-dont-spam-your-server-debounce-and-throttle\/\">Javascript - don't spam your server: debounce and throttle<\/a><\/li>\n     * <\/ul>\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as it uses time to control data flow.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            the length of the window of time that must pass after the emission of an item from the source\n     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the\n     *            resulting Publisher\n     * @param unit\n     *            the {@link TimeUnit} of {@code timeout}\n     * @param scheduler\n     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each\n     *            item\n     * @return a Flowable that filters out items that are too quickly followed by newer items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/debounce.html\">ReactiveX operators documentation: Debounce<\/a>\n     * @see <a href=\"https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Backpressure\">RxJava wiki: Backpressure<\/a>\n     * @see #debounce(long, TimeUnit, Scheduler)\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {\n        return debounce(timeout, unit, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval() {\n        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(Scheduler scheduler) {\n        return timeInterval(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {\n        return timeInterval(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the\n     * source Publisher, where this interval is computed on a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeInterval.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>The operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} used to compute time intervals\n     * @return a Flowable that emits time interval information items\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeinterval.html\">ReactiveX operators documentation: TimeInterval<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if an item emitted by the source Publisher doesn't arrive within a window of\n     * time after the emission of the previous item, where that period of time is measured by a Publisher that\n     * is a function of the previous item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout3.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source\n     *            Publisher and that determines the timeout window for the subsequent item\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if an item emitted by the source Publisher takes longer to arrive than\n     *         the time window defined by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        return timeout0(null, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but that switches to a fallback Publisher if\n     * an item emitted by the source Publisher doesn't arrive within a window of time after the emission of the\n     * previous item, where that period of time is measured by a Publisher that is a function of the previous\n     * item.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout4.png\" alt=\"\">\n     * <p>\n     * Note: The arrival of the first source item is never timed out.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <V>\n     *            the timeout value type (ignored)\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher, for each item emitted by the source Publisher, that\n     *            determines the timeout window for the subsequent item\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to mirroring a fallback Publisher\n     *         if an item emitted by the source Publisher takes longer to arrive than the time window defined\n     *         by the selector for the previously emitted item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator, Flowable<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(null, itemTimeoutIndicator, other);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher terminates and notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between emitted items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument.\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {\n        return timeout0(timeout, timeUnit, null, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,\n     * the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param other\n     *            the fallback Publisher to use in case of a timeout\n     * @return the source Publisher modified to switch to the fallback Publisher in case of a timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration\n     * starting from its predecessor, the resulting Publisher begins instead to mirror a fallback Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.2s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the {@link Scheduler} to run the timeout timers on\n     * @param other\n     *            the Publisher to use as the fallback in case of a timeout\n     * @return the source Publisher modified so that it will switch to the fallback Publisher in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(timeout, timeUnit, other, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted\n     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the\n     * specified timeout duration starting from its predecessor, the resulting Publisher terminates and\n     * notifies Subscribers of a {@code TimeoutException}.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout.1s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timeout\n     *            maximum duration between items before a timeout occurs\n     * @param timeUnit\n     *            the unit of time that applies to the {@code timeout} argument\n     * @param scheduler\n     *            the Scheduler to run the timeout timers on\n     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a\n     *         timeout\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {\n        return timeout0(timeout, timeUnit, null, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     * {@code TimeoutException} if either the first item emitted by the source Publisher or any subsequent item\n     * doesn't arrive within time windows defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s\n     *  are expected to honor backpressure as well. If any of then violates this rule, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher that determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a\n     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within\n     *         the time windows specified by the timeout selectors\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutIndicator is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);\n    }\n\n    \/**\n     * Returns a Flowable that mirrors the source Publisher, but switches to a fallback Publisher if either\n     * the first item emitted by the source Publisher or any subsequent item doesn't arrive within time windows\n     * defined by other Publishers.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timeout6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream. The {@code Publisher}\n     *  sources are expected to honor backpressure as well.\n     *  If any of the source {@code Publisher}s violate this, it <em>may<\/em> throw an\n     *  {@code IllegalStateException} when the source {@code Publisher} completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timeout} does not operates by default on any {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the first timeout value type (ignored)\n     * @param <V>\n     *            the subsequent timeout value type (ignored)\n     * @param firstTimeoutIndicator\n     *            a function that returns a Publisher which determines the timeout window for the first source\n     *            item\n     * @param itemTimeoutIndicator\n     *            a function that returns a Publisher for each item emitted by the source Publisher and that\n     *            determines the timeout window in which the subsequent source item must arrive in order to\n     *            continue the sequence\n     * @param other\n     *            the fallback Publisher to switch to if the source Publisher times out\n     * @return a Flowable that mirrors the source Publisher, but switches to the {@code other} Publisher if\n     *         either the first item emitted by the source Publisher or any subsequent item doesn't arrive\n     *         within time windows defined by the timeout selectors\n     * @throws NullPointerException\n     *             if {@code itemTimeoutIndicator} is null\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timeout.html\">ReactiveX operators documentation: Timeout<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<T> timeout(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(firstTimeoutIndicator, \"firstTimeoutSelector is null\");\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, other);\n    }\n\n    private Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,\n            Scheduler scheduler) {\n        ObjectHelper.requireNonNull(timeUnit, \"timeUnit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other));\n    }\n\n    private <U, V> Flowable<T> timeout0(\n            Publisher<U> firstTimeoutIndicator,\n            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator,\n                    Publisher<? extends T> other) {\n        ObjectHelper.requireNonNull(itemTimeoutIndicator, \"itemTimeoutIndicator is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableTimeout<T, U, V>(this, firstTimeoutIndicator, itemTimeoutIndicator, other));\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp() {\n        return timestamp(TimeUnit.MILLISECONDS, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {\n        return timestamp(TimeUnit.MILLISECONDS, scheduler);\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code timestamp} does not operate on any particular scheduler but uses the current time\n     *  from the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @return a Flowable that emits timestamped items from the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Timed<T>> timestamp(TimeUnit unit) {\n        return timestamp(unit, Schedulers.computation());\n    }\n\n    \/**\n     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a\n     * {@link Timed} object whose timestamps are provided by a specified Scheduler.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/timestamp.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate on any particular scheduler but uses the current time\n     *  from the specified {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param unit the time unit for the current time\n     * @param scheduler\n     *            the {@link Scheduler} to use as a time source\n     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by\n     *         the {@code scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/timestamp.html\">ReactiveX operators documentation: Timestamp<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE) \/\/ Supplied scheduler is only used for creating timestamps.\n    public final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return map(Functions.<T>timestampWith(unit, scheduler));\n    }\n\n    \/**\n     * Calls the specified converter function during assembly time and returns its resulting value.\n     * <p>\n     * This allows fluent conversion to any other type.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The backpressure behavior depends on what happens in the {@code converter} function.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code to} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param <R> the resulting object type\n     * @param converter the function that receives the current Flowable instance and returns a value\n     * @return the value returned by the function\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> R to(Function<? super Flowable<T>, R> converter) {\n        try {\n            return ObjectHelper.requireNonNull(converter, \"converter is null\").apply(this);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList() {\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, ArrayListSupplier.<T>asCallable()));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *         the number of elements expected from the current Flowable\n     * @return a Flowable that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toList(final int capacityHint) {\n        ObjectHelper.verifyPositive(capacityHint, \"capacityHint\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));\n    }\n\n    \/**\n     * Returns a Single that emits a single item, a list composed of all the items emitted by the source\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toList.png\" alt=\"\">\n     * <p>\n     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s\n     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the\n     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}\n     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to\n     * calling its {@link #subscribe} method.\n     * <p>\n     * Be careful not to use this operator on Publishers that emit infinite or very large numbers of items, as\n     * you do not have the option to cancel.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the subclass of a collection of Ts\n     * @param collectionSupplier\n     *               the Callable returning the collection (for each individual Subscriber) to be filled in\n     * @return a Single that emits a single item: a List containing all of the items emitted by the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U extends Collection<? super T>> Flowable<U> toList(Callable<U> collectionSupplier) {\n        ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableToList<T, U>(this, collectionSupplier));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing all items emitted by the source Publisher,\n     * mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        return collect(HashMapSupplier.<K, T>asCallable(), Functions.toMapKeySelector(keySelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap containing values corresponding to items emitted by the\n     * source Publisher, mapped by the keys returned by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <p>\n     * If more than one source item maps to the same key, the HashMap will contain a single entry that\n     * corresponds to the latest of those items.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the HashMap\n     * @param valueSelector\n     *            the function that extracts the value from a source item to be used in the HashMap\n     * @return a Single that emits a single item: a HashMap containing the mapped items from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(HashMapSupplier.<K, V>asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains keys and values extracted from the items emitted by the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts the key from a source item to be used in the Map\n     * @param valueSelector\n     *            the function that extracts the value from the source items to be used as value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Flowable that emits a single item: a Map that contains the mapped items emitted by the\n     *         source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, V>> mapSupplier) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of items emitted by the\n     * source Publisher keyed by a specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param keySelector\n     *            the function that extracts the key from the source items to be used as key in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K> Flowable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {\n        Function<T, T> valueSelector = Functions.identity();\n        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single HashMap that contains an ArrayList of values extracted by a\n     * specified {@code valueSelector} function from items emitted by the source Publisher, keyed by a\n     * specified {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as key in the HashMap\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as value in the HashMap\n     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {\n        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();\n        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();\n        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from\n     * items emitted by the source Publisher, and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @param collectionFactory\n     *            the function that returns a Collection instance for a particular key to be used in the Map\n     * @return a Single that emits a single item: a Map that contains the collection of mapped items from\n     *         the source Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            final Function<? super T, ? extends K> keySelector,\n            final Function<? super T, ? extends V> valueSelector,\n            final Callable<? extends Map<K, Collection<V>>> mapSupplier,\n            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {\n        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n        ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n        ObjectHelper.requireNonNull(mapSupplier, \"mapSupplier is null\");\n        ObjectHelper.requireNonNull(collectionFactory, \"collectionFactory is null\");\n        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));\n    }\n\n    \/**\n     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that\n     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items\n     * emitted by the source Publisher and keyed by the {@code keySelector} function.\n     * <p>\n     * <img width=\"640\" height=\"305\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toMultiMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <K> the key type of the Map\n     * @param <V> the value type of the Map\n     * @param keySelector\n     *            the function that extracts a key from the source items to be used as the key in the Map\n     * @param valueSelector\n     *            the function that extracts a value from the source items to be used as the value in the Map\n     * @param mapSupplier\n     *            the function that returns a Map instance to be used\n     * @return a Single that emits a single item: a Map that contains a list items mapped from the source\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(\n            Function<? super T, ? extends K> keySelector,\n            Function<? super T, ? extends V> valueSelector,\n            Callable<Map<K, Collection<V>>> mapSupplier\n            ) {\n        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList() {\n        return toSortedList(Functions.naturalComparator());\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList().map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Single that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order based on a specified comparison function.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.f.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param comparator\n     *            a function that compares two items emitted by the source Publisher and returns an Integer\n     *            that indicates their sort order\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Single that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) {\n        ObjectHelper.requireNonNull(comparator, \"comparator is null\");\n        return toList(capacityHint).map(Functions.listSorter(comparator));\n    }\n\n    \/**\n     * Returns a Flowable that emits a list that contains the items emitted by the source Publisher, in a\n     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all\n     * other items in the sequence.\n     *\n     * <p>If any item emitted by this Flowable does not implement {@link Comparable} with respect to\n     *             all other items emitted by this Flowable, no items will be emitted and the\n     *             sequence is terminated with a {@link ClassCastException}.\n     * <p>\n     * <img width=\"640\" height=\"310\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/toSortedList.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\n     *  unbounded manner (i.e., without applying backpressure to it).<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param capacityHint\n     *             the initial capacity of the ArrayList used to accumulate items before sorting\n     * @return a Flowable that emits a list that contains the items emitted by the source Publisher in\n     *         sorted order\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/to.html\">ReactiveX operators documentation: To<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<List<T>> toSortedList(int capacityHint) {\n        return toSortedList(Functions.naturalComparator(), capacityHint);\n    }\n\n    \/**\n     * Modifies the source Publisher so that subscribers will cancel it on a specified\n     * {@link Scheduler}.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n     *  behavior.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param scheduler\n     *            the {@link Scheduler} to perform cancellation actions on\n     * @return the source Publisher modified so that its cancellations happen on the specified\n     *         {@link Scheduler}\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/subscribeon.html\">ReactiveX operators documentation: SubscribeOn<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each containing {@code count} items. When the source\n     * Publisher completes or encounters an error, the resulting Publisher emits the current window and\n     * propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"400\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window3.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows, each containing at most\n     *         {@code count} items from the source Publisher\n     * @throws IllegalArgumentException if either count is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count) {\n        return window(count, count, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip) {\n        return window(count, skip, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When\n     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window\n     * and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"365\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window4.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an\n     *  unbounded buffer that may hold at most {@code count} elements.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param skip\n     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and\n     *            {@code count} are equal this is the same operation as {@link #window(long)}.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items\n     *         from the source Publisher\n     * @throws IllegalArgumentException if either count or skip is non-positive\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {\n        ObjectHelper.verifyPositive(skip, \"skip\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {\n        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {\n        return window(timespan, timeskip, unit, scheduler, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits\n     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source\n     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"335\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window7.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted\n     * @param timeskip\n     *            the period of time after which a new window will be created\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits new windows periodically as a fixed timespan elapses\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.verifyPositive(timespan, \"timespan\");\n        ObjectHelper.verifyPositive(timeskip, \"timeskip\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @return a Flowable that emits connected, non-overlapping windows representing items emitted by the\n     *         source Publisher during fixed, consecutive durations\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) {\n        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count) {\n        return window(timespan, unit, Schedulers.computation(), count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is\n     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher\n     * emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time that applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            long count, boolean restart) {\n        return window(timespan, unit, Schedulers.computation(), count, restart);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the\n     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting\n     * Publisher emits the current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"375\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window5.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows containing items emitted by the\n     *         source Publisher within a fixed duration\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler) {\n        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count) {\n        return window(timespan, unit, scheduler, count, false);\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,\n            Scheduler scheduler, long count, boolean restart) {\n        return window(timespan, unit, scheduler, count, restart, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the\n     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached\n     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the\n     * current window and propagates the notification from the source Publisher.\n     * <p>\n     * <img width=\"640\" height=\"370\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window6.s.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  time to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure and may hold up to {@code count} elements at most.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>You specify which {@link Scheduler} this operator will use<\/dd>\n     * <\/dl>\n     *\n     * @param timespan\n     *            the period of time each window collects items before it should be emitted and replaced with a\n     *            new window\n     * @param unit\n     *            the unit of time which applies to the {@code timespan} argument\n     * @param count\n     *            the maximum size of each window before it should be emitted\n     * @param scheduler\n     *            the {@link Scheduler} to use when determining the end and start of a window\n     * @param restart\n     *            if true, when a window reaches the capacity limit, the timer is restarted as well\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity\n     *         (whichever occurs first)\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<Flowable<T>> window(\n            long timespan, TimeUnit unit, Scheduler scheduler,\n            long count, boolean restart, int bufferSize) {\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.verifyPositive(count, \"count\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator) {\n        return window(boundaryIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     * where the boundary of each window is determined by the items emitted from a specified boundary-governing\n     * Publisher.\n     * <p>\n     * <img width=\"640\" height=\"475\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window8.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data\n     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B>\n     *            the window element type (ignored)\n     * @param boundaryIndicator\n     *            a Publisher whose emitted items close and open windows\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher\n     *         where the boundary of each window is determined by the items emitted from the {@code boundary}\n     *         Publisher\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicator, \"boundaryIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundaryIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator) {\n        return window(openingIndicator, closingIndicator, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits windows that contain those items emitted by the source Publisher between the time when\n     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by\n     * {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"550\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window2.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The outer Publisher of this operator doesn't support backpressure because the emission of new\n     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.\n     *  The inner Publishers honor backpressure and buffer everything until the associated closing\n     *  Publisher signals or completes.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the window-opening Publisher\n     * @param <V> the element type of the window-closing Publishers\n     * @param openingIndicator\n     *            a Publisher that, when it emits an item, causes another window to be created\n     * @param closingIndicator\n     *            a {@link Function} that produces a Publisher for every window created. When this Publisher\n     *            emits an item, the associated window is closed and emitted\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by\n     *         the specified window-governing Publishers\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, V> Flowable<Flowable<T>> window(\n            Publisher<U> openingIndicator,\n            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {\n        ObjectHelper.requireNonNull(openingIndicator, \"openingIndicator is null\");\n        ObjectHelper.requireNonNull(closingIndicator, \"closingIndicator is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {\n        return window(boundaryIndicatorSupplier, bufferSize());\n    }\n\n    \/**\n     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting\n     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one\n     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.\n     * <p>\n     * <img width=\"640\" height=\"455\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/window1.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator consumes the source {@code Publisher} in an unbounded manner.\n     *  The returned {@code Publisher} doesn't support backpressure as it uses\n     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor\n     *  backpressure but have an unbounded inner buffer that <em>may<\/em> lead to {@code OutOfMemoryError}\n     *  if left unconsumed.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <B> the element type of the boundary Publisher\n     * @param boundaryIndicatorSupplier\n     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.\n     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins\n     *            a new one.\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher\n     *         whenever {@code closingSelector} emits an item\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/window.html\">ReactiveX operators documentation: Window<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {\n        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, \"boundaryIndicatorSupplier is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));\n    }\n\n    \/**\n     * Merges the specified Publisher into this Publisher sequence by using the {@code resultSelector}\n     * function only when the source Publisher (this instance) emits an item.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/withLatestFrom.png\" alt=\"\">\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>The operator is a pass-through for backpressure: the backpressure support\n     *  depends on the upstream and downstream's backpressure behavior. The other Publisher\n     *  is consumed in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator, by default, doesn't run any particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U> the element type of the other Publisher\n     * @param <R> the result type of the combination\n     * @param other\n     *            the other Publisher\n     * @param combiner\n     *            the function to call when this Publisher emits an item and the other Publisher has already\n     *            emitted an item, to generate the item to be emitted by the resulting Publisher\n     * @return a Flowable that merges the specified Publisher into this Publisher by using the\n     *         {@code resultSelector} function only when the source Publisher sequence (this instance) emits an\n     *         item\n     * @since 2.0\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/combinelatest.html\">ReactiveX operators documentation: CombineLatest<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> withLatestFrom(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> combiner) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFrom<T, U, R>(this, combiner, other));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> source1, Publisher<T2> source2,\n            Function3<? super T, ? super T1, ? super T2, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3,\n            Function4<? super T, ? super T1, ? super T2, ? super T3, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <T1> the first other source's value type\n     * @param <T2> the second other source's value type\n     * @param <T3> the third other source's value type\n     * @param <T4> the fourth other source's value type\n     * @param <R> the result value type\n     * @param source1 the first other Publisher\n     * @param source2 the second other Publisher\n     * @param source3 the third other Publisher\n     * @param source4 the fourth other Publisher\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <T1, T2, T3, T4, R> Flowable<R> withLatestFrom(\n            Publisher<T1> source1, Publisher<T2> source2,\n            Publisher<T3> source3, Publisher<T4> source4,\n            Function5<? super T, ? super T1, ? super T2, ? super T3, ? super T4, R> combiner) {\n        ObjectHelper.requireNonNull(source1, \"source1 is null\");\n        ObjectHelper.requireNonNull(source2, \"source2 is null\");\n        ObjectHelper.requireNonNull(source3, \"source3 is null\");\n        ObjectHelper.requireNonNull(source4, \"source4 is null\");\n        Function<Object[], R> f = Functions.toFunction(combiner);\n        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the array of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Publisher<?>[] others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Combines the value emission from this Publisher with the latest emissions from the\n     * other Publishers via a function to produce the output item.\n     *\n     * <p>Note that this operator doesn't emit anything until all other sources have produced at\n     * least one value. The resulting emission only happens when this Publisher emits (and\n     * not when any of the other sources emit, unlike combineLatest).\n     * If a source doesn't produce any value and just completes, the sequence is completed immediately.\n     *\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><\/dt>\n     *  <dd>This operator is a pass-through for backpressure behavior between the source {@code Publisher}\n     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>This operator does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <R> the result value type\n     * @param others the iterable of other sources\n     * @param combiner the function called with an array of values from each participating Publisher\n     * @return the new Publisher instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> withLatestFrom(Iterable<? extends Publisher<?>> others, Function<? super Object[], R> combiner) {\n        ObjectHelper.requireNonNull(others, \"others is null\");\n        ObjectHelper.requireNonNull(combiner, \"combiner is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableWithLatestFromMany<T, R>(this, others, combiner));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and a specified Iterable sequence.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.i.png\" alt=\"\">\n     * <p>\n     * Note that the {@code other} Iterable is evaluated as items are observed from the source Publisher; it is\n     * not pre-consumed. This allows you to zip infinite streams on either side.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items in the {@code other} Iterable\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the Iterable sequence\n     * @param zipper\n     *            a function that combines the pairs of items from the Publisher and the Iterable to generate\n     *            the items to be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Iterable\n     *         sequence and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaFlowablePlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        return zip(this, other, zipper);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {\n        return zip(this, other, zipper, delayError);\n    }\n\n    \/**\n     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of\n     * values, one each from the source Publisher and another specified Publisher.\n     * <p>\n     * <p>\n     * The operator subscribes to its sources in order they are specified and completes eagerly if\n     * one of the sources is shorter than the rest while cancelling the other sources. Therefore, it\n     * is possible those other sources will never be able to run to completion (and thus not calling\n     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if\n     * source A completes and B has been consumed and is about to complete, the operator detects A won't\n     * be sending further values and it will cancel B immediately. For example:\n     * <pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)<\/code><\/pre>\n     * {@code action1} will be called but {@code action2} won't.\n     * <br>To work around this termination property,\n     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion\n     * or cancellation.\n     *\n     * <img width=\"640\" height=\"380\" src=\"https:\/\/raw.github.com\/wiki\/ReactiveX\/RxJava\/images\/rx-operators\/zip.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.\n     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use\n     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     *\n     * @param <U>\n     *            the type of items emitted by the {@code other} Publisher\n     * @param <R>\n     *            the type of items emitted by the resulting Publisher\n     * @param other\n     *            the other Publisher\n     * @param zipper\n     *            a function that combines the pairs of items from the two Publishers to generate the items to\n     *            be emitted by the resulting Publisher\n     * @param bufferSize\n     *            the capacity hint for the buffer in the inner windows\n     * @param delayError\n     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate\n     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher\n     *         and emits the results of {@code zipFunction} applied to these pairs\n     * @see <a href=\"http:\/\/reactivex.io\/documentation\/operators\/zip.html\">ReactiveX operators documentation: Zip<\/a>\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,\n            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {\n        return zip(this, other, zipper, delayError, bufferSize);\n    }\n\n    \/\/ -------------------------------------------------------------------------\n    \/\/ Fluent test support, super handy and reduces test preparation boilerplate\n    \/\/ -------------------------------------------------------------------------\n    \/**\n     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber consumes this Flowable in an unbounded fashion.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test() { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>();\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        subscribe(ts);\n        return ts;\n    }\n\n    \/**\n     * Creates a TestSubscriber with the given initial request amount,\n     * optionally cancels it before the subscription and subscribes\n     * it to this Flowable.\n     * <dl>\n     *  <dt><b>Backpressure:<\/b><dt>\n     *  <dd>The returned TestSubscriber requests the given {@code initialRequest} amount upfront.<\/dd>\n     *  <dt><b>Scheduler:<\/b><\/dt>\n     *  <dd>{@code test} does not operate by default on a particular {@link Scheduler}.<\/dd>\n     * <\/dl>\n     * @param initialRequest the initial request amount, positive\n     * @param cancel should the TestSubscriber be cancelled before the subscription?\n     * @return the new TestSubscriber instance\n     * @since 2.0\n     *\/\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final TestSubscriber<T> test(long initialRequest, boolean cancel) { \/\/ NoPMD\n        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);\n        if (cancel) {\n            ts.cancel();\n        }\n        subscribe(ts);\n        return ts;\n    }\n\n}\n","subject":"","message":"Changed minimum value of rx2.buffer-size to 1\n\nBefore the minimum value you could set with the system variable `rx2.buffer-size` was 16. With this commit, that is changed to 1.\n","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"85557ce424bfb2a4f98c0e68198fb557e17ebbf4","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"3d04b8095f2e7c9c4f79af5cf7df57bf30289d1e","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"RxJava3-preview","url":"https:\/\/github.com\/akarnokd\/RxJava3-preview","stars":238,"test_cases":{},"commit":"","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":true}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"67dd594c348b87d8cd481483dbea6c8e304737e4","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"d363b3cdced473939f3762d727a269d188d40206","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"d363b3cdced473939f3762d727a269d188d40206","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
{"name":"pentaho-metaverse","url":"https:\/\/github.com\/pentaho\/pentaho-metaverse","stars":7,"test_cases":{},"commit":"77c22b424d1d6fda5c29b1e9a81f57bd20abe36f","old_file":" ","new_file":" ","old_contents":"","new_contents":" ","subject":"","message":"R","lang":"Java","license":"","repos":"","is_last_commit":false}
